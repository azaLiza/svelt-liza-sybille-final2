
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_options(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            option.selected = ~value.indexOf(option.__value);
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.32.1' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.32.1 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (209:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(209:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (202:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(202:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap$1(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading");

    	return wrap({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    	try {
    		window.history.replaceState(undefined, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event("hashchange"));
    }

    function link(node, hrefVar) {
    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	updateLink(node, hrefVar || node.getAttribute("href"));

    	return {
    		update(updated) {
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, href) {
    	// Destination must start with '/'
    	if (!href || href.length < 1 || href.charAt(0) != "/") {
    		throw Error("Invalid value for \"href\" attribute: " + href);
    	}

    	// Add # to the href attribute
    	node.setAttribute("href", "#" + href);

    	node.addEventListener("click", scrollstateHistoryHandler);
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {HTMLElementEventMap} event - an onclick event attached to an anchor tag
     */
    function scrollstateHistoryHandler(event) {
    	// Prevent default anchor onclick behaviour
    	event.preventDefault();

    	const href = event.currentTarget.getAttribute("href");

    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument - strings must start with / or *");
    			}

    			const { pattern, keys } = regexparam(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == "string") {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || "/";
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || "/";
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {bool} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	if (restoreScrollState) {
    		window.addEventListener("popstate", event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		});

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.scrollX, previousScrollState.scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick("conditionsFailed", detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoading", Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == "object" && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    	});

    	const writable_props = ["routes", "prefix", "restoreScrollState"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble($$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		derived,
    		tick,
    		_wrap: wrap,
    		wrap: wrap$1,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		scrollstateHistoryHandler,
    		createEventDispatcher,
    		afterUpdate,
    		regexparam,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		lastLoc,
    		componentObj
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("previousScrollState" in $$props) previousScrollState = $$props.previousScrollState;
    		if ("lastLoc" in $$props) lastLoc = $$props.lastLoc;
    		if ("componentObj" in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			 history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }

    function isObject(value) {
      const type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    function getColumnSizeClass(isXs, colWidth, colSize) {
      if (colSize === true || colSize === '') {
        return isXs ? 'col' : `col-${colWidth}`;
      } else if (colSize === 'auto') {
        return isXs ? 'col-auto' : `col-${colWidth}-auto`;
      }

      return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
    }

    function toClassName(value) {
      let result = '';

      if (typeof value === 'string' || typeof value === 'number') {
        result += value;
      } else if (typeof value === 'object') {
        if (Array.isArray(value)) {
          result = value.map(toClassName).filter(Boolean).join(' ');
        } else {
          for (let key in value) {
            if (value[key]) {
              result && (result += ' ');
              result += key;
            }
          }
        }
      }

      return result;
    }

    function classnames(...args) {
      return args.map(toClassName).filter(Boolean).join(' ');
    }

    /* node_modules\sveltestrap\src\Alert.svelte generated by Svelte v3.32.1 */
    const file = "node_modules\\sveltestrap\\src\\Alert.svelte";

    // (22:0) {#if isOpen}
    function create_if_block$1(ctx) {
    	let div;
    	let t;
    	let current_block_type_index;
    	let if_block1;
    	let div_transition;
    	let current;
    	let if_block0 = /*toggle*/ ctx[3] && create_if_block_2(ctx);
    	const if_block_creators = [create_if_block_1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*children*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let div_levels = [/*$$restProps*/ ctx[7], { class: /*classes*/ ctx[5] }, { role: "alert" }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if_block1.c();
    			set_attributes(div, div_data);
    			add_location(div, file, 22, 2, 637);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*toggle*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
    				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
    				{ role: "alert" }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, /*transition*/ ctx[4], true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, /*transition*/ ctx[4], false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(22:0) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    // (28:4) {#if toggle}
    function create_if_block_2(ctx) {
    	let button;
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			span = element("span");
    			span.textContent = "×";
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file, 33, 8, 900);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", /*closeClassNames*/ ctx[6]);
    			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
    			add_location(button, file, 28, 6, 767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, span);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*toggle*/ ctx[3])) /*toggle*/ ctx[3].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*closeClassNames*/ 64) {
    				attr_dev(button, "class", /*closeClassNames*/ ctx[6]);
    			}

    			if (dirty & /*closeAriaLabel*/ 2) {
    				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(28:4) {#if toggle}",
    		ctx
    	});

    	return block;
    }

    // (39:4) {:else}
    function create_else_block$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(39:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#if children}
    function create_if_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*children*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(37:4) {#if children}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*isOpen*/ ctx[2] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let classes;
    	let closeClassNames;

    	const omit_props_names = [
    		"class","children","color","closeClassName","closeAriaLabel","isOpen","toggle","fade","transition"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Alert", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { children = undefined } = $$props;
    	let { color = "success" } = $$props;
    	let { closeClassName = "" } = $$props;
    	let { closeAriaLabel = "Close" } = $$props;
    	let { isOpen = true } = $$props;
    	let { toggle = undefined } = $$props;
    	let { fade: fade$1 = true } = $$props;
    	let { transition = { duration: fade$1 ? 400 : 0 } } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ("children" in $$new_props) $$invalidate(0, children = $$new_props.children);
    		if ("color" in $$new_props) $$invalidate(9, color = $$new_props.color);
    		if ("closeClassName" in $$new_props) $$invalidate(10, closeClassName = $$new_props.closeClassName);
    		if ("closeAriaLabel" in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ("isOpen" in $$new_props) $$invalidate(2, isOpen = $$new_props.isOpen);
    		if ("toggle" in $$new_props) $$invalidate(3, toggle = $$new_props.toggle);
    		if ("fade" in $$new_props) $$invalidate(11, fade$1 = $$new_props.fade);
    		if ("transition" in $$new_props) $$invalidate(4, transition = $$new_props.transition);
    		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fadeTransition: fade,
    		classnames,
    		className,
    		children,
    		color,
    		closeClassName,
    		closeAriaLabel,
    		isOpen,
    		toggle,
    		fade: fade$1,
    		transition,
    		classes,
    		closeClassNames
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
    		if ("children" in $$props) $$invalidate(0, children = $$new_props.children);
    		if ("color" in $$props) $$invalidate(9, color = $$new_props.color);
    		if ("closeClassName" in $$props) $$invalidate(10, closeClassName = $$new_props.closeClassName);
    		if ("closeAriaLabel" in $$props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ("isOpen" in $$props) $$invalidate(2, isOpen = $$new_props.isOpen);
    		if ("toggle" in $$props) $$invalidate(3, toggle = $$new_props.toggle);
    		if ("fade" in $$props) $$invalidate(11, fade$1 = $$new_props.fade);
    		if ("transition" in $$props) $$invalidate(4, transition = $$new_props.transition);
    		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
    		if ("closeClassNames" in $$props) $$invalidate(6, closeClassNames = $$new_props.closeClassNames);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, color, toggle*/ 776) {
    			 $$invalidate(5, classes = classnames(className, "alert", `alert-${color}`, { "alert-dismissible": toggle }));
    		}

    		if ($$self.$$.dirty & /*closeClassName*/ 1024) {
    			 $$invalidate(6, closeClassNames = classnames("close", closeClassName));
    		}
    	};

    	return [
    		children,
    		closeAriaLabel,
    		isOpen,
    		toggle,
    		transition,
    		classes,
    		closeClassNames,
    		$$restProps,
    		className,
    		color,
    		closeClassName,
    		fade$1,
    		$$scope,
    		slots
    	];
    }

    class Alert extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
    			class: 8,
    			children: 0,
    			color: 9,
    			closeClassName: 10,
    			closeAriaLabel: 1,
    			isOpen: 2,
    			toggle: 3,
    			fade: 11,
    			transition: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Alert",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get class() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeClassName() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeClassName(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeAriaLabel() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeAriaLabel(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fade() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fade(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Button.svelte generated by Svelte v3.32.1 */
    const file$1 = "node_modules\\sveltestrap\\src\\Button.svelte";

    // (48:0) {:else}
    function create_else_block_1(ctx) {
    	let button;
    	let button_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	let button_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ value: /*value*/ ctx[5] },
    		{
    			"aria-label": button_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			button = element("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(button, button_data);
    			add_location(button, file$1, 48, 2, 985);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*close, children, $$scope*/ 65539) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*value*/ 32) && { value: /*value*/ ctx[5] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8])) && { "aria-label": button_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(48:0) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (33:0) {#if href}
    function create_if_block$2(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let a_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$1, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*children*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ href: /*href*/ ctx[3] },
    		{
    			"aria-label": a_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$1, 33, 2, 752);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[18], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*href*/ 8) && { href: /*href*/ ctx[3] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/ ctx[6] || /*defaultAriaLabel*/ ctx[8])) && { "aria-label": a_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(33:0) {#if href}",
    		ctx
    	});

    	return block_1;
    }

    // (62:6) {:else}
    function create_else_block_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(62:6) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (60:25) 
    function create_if_block_3(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(60:25) ",
    		ctx
    	});

    	return block_1;
    }

    // (58:6) {#if close}
    function create_if_block_2$1(ctx) {
    	let span;

    	const block_1 = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "×";
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$1, 58, 8, 1171);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(58:6) {#if close}",
    		ctx
    	});

    	return block_1;
    }

    // (57:10)        
    function fallback_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$1, create_if_block_3, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*close*/ ctx[1]) return 0;
    		if (/*children*/ ctx[0]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(57:10)        ",
    		ctx
    	});

    	return block_1;
    }

    // (44:4) {:else}
    function create_else_block$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(44:4) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (42:4) {#if children}
    function create_if_block_1$1(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 1) set_data_dev(t, /*children*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(42:4) {#if children}",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let ariaLabel;
    	let classes;
    	let defaultAriaLabel;

    	const omit_props_names = [
    		"class","active","block","children","close","color","disabled","href","outline","size","style","value"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Button", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { active = false } = $$props;
    	let { block = false } = $$props;
    	let { children = undefined } = $$props;
    	let { close = false } = $$props;
    	let { color = "secondary" } = $$props;
    	let { disabled = false } = $$props;
    	let { href = "" } = $$props;
    	let { outline = false } = $$props;
    	let { size = null } = $$props;
    	let { style = "" } = $$props;
    	let { value = "" } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(10, className = $$new_props.class);
    		if ("active" in $$new_props) $$invalidate(11, active = $$new_props.active);
    		if ("block" in $$new_props) $$invalidate(12, block = $$new_props.block);
    		if ("children" in $$new_props) $$invalidate(0, children = $$new_props.children);
    		if ("close" in $$new_props) $$invalidate(1, close = $$new_props.close);
    		if ("color" in $$new_props) $$invalidate(13, color = $$new_props.color);
    		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ("href" in $$new_props) $$invalidate(3, href = $$new_props.href);
    		if ("outline" in $$new_props) $$invalidate(14, outline = $$new_props.outline);
    		if ("size" in $$new_props) $$invalidate(15, size = $$new_props.size);
    		if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
    		if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
    		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		active,
    		block,
    		children,
    		close,
    		color,
    		disabled,
    		href,
    		outline,
    		size,
    		style,
    		value,
    		ariaLabel,
    		classes,
    		defaultAriaLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(10, className = $$new_props.className);
    		if ("active" in $$props) $$invalidate(11, active = $$new_props.active);
    		if ("block" in $$props) $$invalidate(12, block = $$new_props.block);
    		if ("children" in $$props) $$invalidate(0, children = $$new_props.children);
    		if ("close" in $$props) $$invalidate(1, close = $$new_props.close);
    		if ("color" in $$props) $$invalidate(13, color = $$new_props.color);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ("href" in $$props) $$invalidate(3, href = $$new_props.href);
    		if ("outline" in $$props) $$invalidate(14, outline = $$new_props.outline);
    		if ("size" in $$props) $$invalidate(15, size = $$new_props.size);
    		if ("style" in $$props) $$invalidate(4, style = $$new_props.style);
    		if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
    		if ("ariaLabel" in $$props) $$invalidate(6, ariaLabel = $$new_props.ariaLabel);
    		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
    		if ("defaultAriaLabel" in $$props) $$invalidate(8, defaultAriaLabel = $$new_props.defaultAriaLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(6, ariaLabel = $$props["aria-label"]);

    		if ($$self.$$.dirty & /*className, close, outline, color, size, block, active*/ 64514) {
    			 $$invalidate(7, classes = classnames(className, { close }, close || "btn", close || `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "btn-block" : false, { active }));
    		}

    		if ($$self.$$.dirty & /*close*/ 2) {
    			 $$invalidate(8, defaultAriaLabel = close ? "Close" : null);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		children,
    		close,
    		disabled,
    		href,
    		style,
    		value,
    		ariaLabel,
    		classes,
    		defaultAriaLabel,
    		$$restProps,
    		className,
    		active,
    		block,
    		color,
    		outline,
    		size,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
    			class: 10,
    			active: 11,
    			block: 12,
    			children: 0,
    			close: 1,
    			color: 13,
    			disabled: 2,
    			href: 3,
    			outline: 14,
    			size: 15,
    			style: 4,
    			value: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get block() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set block(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set close(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const createContext = () => writable({});

    /* node_modules\sveltestrap\src\Dropdown.svelte generated by Svelte v3.32.1 */

    const { Error: Error_1$1 } = globals;
    const file$2 = "node_modules\\sveltestrap\\src\\Dropdown.svelte";

    // (100:0) {:else}
    function create_else_block$3(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$2, 100, 2, 2405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[19](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[19](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(100:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (96:0) {#if nav}
    function create_if_block$3(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let li_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$2, 96, 2, 2314);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding*/ ctx[18](li);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding*/ ctx[18](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(96:0) {#if nav}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$3, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let subItemIsActive;
    	let classes;

    	const omit_props_names = [
    		"class","direction","group","isOpen","nav","active","addonType","size","toggle","inNavbar","setActiveFromChild","dropup"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Dropdown", slots, ['default']);
    	let context = createContext();
    	setContext("dropdownContext", context);
    	let { class: className = "" } = $$props;
    	let { direction = "down" } = $$props;
    	let { group = false } = $$props;
    	let { isOpen = false } = $$props;
    	let { nav = false } = $$props;
    	let { active = false } = $$props;
    	let { addonType = false } = $$props;
    	let { size = "" } = $$props;
    	let { toggle = undefined } = $$props;
    	let { inNavbar = false } = $$props;
    	let { setActiveFromChild = false } = $$props;
    	let { dropup = false } = $$props;
    	const validDirections = ["up", "down", "left", "right"];

    	if (validDirections.indexOf(direction) === -1) {
    		throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right'`);
    	}

    	let component;

    	function handleDocumentClick(e) {
    		if (e && (e.which === 3 || e.type === "keyup" && e.which !== 9)) return;

    		if (component.contains(e.target) && component !== e.target && (e.type !== "keyup" || e.which === 9)) {
    			return;
    		}

    		toggle(e);
    	}

    	function li_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			component = $$value;
    			$$invalidate(1, component);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			component = $$value;
    			$$invalidate(1, component);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ("direction" in $$new_props) $$invalidate(5, direction = $$new_props.direction);
    		if ("group" in $$new_props) $$invalidate(6, group = $$new_props.group);
    		if ("isOpen" in $$new_props) $$invalidate(7, isOpen = $$new_props.isOpen);
    		if ("nav" in $$new_props) $$invalidate(0, nav = $$new_props.nav);
    		if ("active" in $$new_props) $$invalidate(8, active = $$new_props.active);
    		if ("addonType" in $$new_props) $$invalidate(9, addonType = $$new_props.addonType);
    		if ("size" in $$new_props) $$invalidate(10, size = $$new_props.size);
    		if ("toggle" in $$new_props) $$invalidate(11, toggle = $$new_props.toggle);
    		if ("inNavbar" in $$new_props) $$invalidate(12, inNavbar = $$new_props.inNavbar);
    		if ("setActiveFromChild" in $$new_props) $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ("dropup" in $$new_props) $$invalidate(14, dropup = $$new_props.dropup);
    		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		classnames,
    		createContext,
    		context,
    		className,
    		direction,
    		group,
    		isOpen,
    		nav,
    		active,
    		addonType,
    		size,
    		toggle,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		validDirections,
    		component,
    		handleDocumentClick,
    		subItemIsActive,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("context" in $$props) $$invalidate(20, context = $$new_props.context);
    		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
    		if ("direction" in $$props) $$invalidate(5, direction = $$new_props.direction);
    		if ("group" in $$props) $$invalidate(6, group = $$new_props.group);
    		if ("isOpen" in $$props) $$invalidate(7, isOpen = $$new_props.isOpen);
    		if ("nav" in $$props) $$invalidate(0, nav = $$new_props.nav);
    		if ("active" in $$props) $$invalidate(8, active = $$new_props.active);
    		if ("addonType" in $$props) $$invalidate(9, addonType = $$new_props.addonType);
    		if ("size" in $$props) $$invalidate(10, size = $$new_props.size);
    		if ("toggle" in $$props) $$invalidate(11, toggle = $$new_props.toggle);
    		if ("inNavbar" in $$props) $$invalidate(12, inNavbar = $$new_props.inNavbar);
    		if ("setActiveFromChild" in $$props) $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ("dropup" in $$props) $$invalidate(14, dropup = $$new_props.dropup);
    		if ("component" in $$props) $$invalidate(1, component = $$new_props.component);
    		if ("subItemIsActive" in $$props) $$invalidate(15, subItemIsActive = $$new_props.subItemIsActive);
    		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*setActiveFromChild, component*/ 8194) {
    			 $$invalidate(15, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === "function" && component.querySelector(".active")));
    		}

    		if ($$self.$$.dirty & /*className, direction, nav, active, setActiveFromChild, subItemIsActive, addonType, group, size, isOpen*/ 42993) {
    			 $$invalidate(2, classes = classnames(className, direction !== "down" && `drop${direction}`, nav && active ? "active" : false, setActiveFromChild && subItemIsActive ? "active" : false, {
    				[`input-group-${addonType}`]: addonType,
    				"btn-group": group,
    				[`btn-group-${size}`]: !!size,
    				dropdown: !group && !addonType,
    				show: isOpen,
    				"nav-item": nav
    			}));
    		}

    		if ($$self.$$.dirty & /*isOpen*/ 128) {
    			 {
    				if (typeof document !== "undefined") {
    					if (isOpen) {
    						["click", "touchstart", "keyup"].forEach(event => document.addEventListener(event, handleDocumentClick, true));
    					} else {
    						["click", "touchstart", "keyup"].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*toggle, isOpen, direction, dropup, inNavbar*/ 22688) {
    			 {
    				context.update(() => {
    					return {
    						toggle,
    						isOpen,
    						direction: direction === "down" && dropup ? "up" : direction,
    						inNavbar
    					};
    				});
    			}
    		}
    	};

    	return [
    		nav,
    		component,
    		classes,
    		$$restProps,
    		className,
    		direction,
    		group,
    		isOpen,
    		active,
    		addonType,
    		size,
    		toggle,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		subItemIsActive,
    		$$scope,
    		slots,
    		li_binding,
    		div_binding
    	];
    }

    class Dropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			class: 4,
    			direction: 5,
    			group: 6,
    			isOpen: 7,
    			nav: 0,
    			active: 8,
    			addonType: 9,
    			size: 10,
    			toggle: 11,
    			inNavbar: 12,
    			setActiveFromChild: 13,
    			dropup: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dropdown",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get class() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addonType() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addonType(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inNavbar() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inNavbar(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setActiveFromChild() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setActiveFromChild(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropup() {
    		throw new Error_1$1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropup(value) {
    		throw new Error_1$1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Card.svelte generated by Svelte v3.32.1 */
    const file$3 = "node_modules\\sveltestrap\\src\\Card.svelte";

    function create_fragment$4(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[2],
    		{ class: /*classes*/ ctx[1] },
    		{ style: /*style*/ ctx[0] }
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$3, 20, 0, 437);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*style*/ 1) && { style: /*style*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","body","color","inverse","outline","style"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Card", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { body = false } = $$props;
    	let { color = "" } = $$props;
    	let { inverse = false } = $$props;
    	let { outline = false } = $$props;
    	let { style = "" } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ("body" in $$new_props) $$invalidate(4, body = $$new_props.body);
    		if ("color" in $$new_props) $$invalidate(5, color = $$new_props.color);
    		if ("inverse" in $$new_props) $$invalidate(6, inverse = $$new_props.inverse);
    		if ("outline" in $$new_props) $$invalidate(7, outline = $$new_props.outline);
    		if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		body,
    		color,
    		inverse,
    		outline,
    		style,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
    		if ("body" in $$props) $$invalidate(4, body = $$new_props.body);
    		if ("color" in $$props) $$invalidate(5, color = $$new_props.color);
    		if ("inverse" in $$props) $$invalidate(6, inverse = $$new_props.inverse);
    		if ("outline" in $$props) $$invalidate(7, outline = $$new_props.outline);
    		if ("style" in $$props) $$invalidate(0, style = $$new_props.style);
    		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, inverse, body, color, outline*/ 248) {
    			 $$invalidate(1, classes = classnames(className, "card", inverse ? "text-white" : false, body ? "card-body" : false, color ? `${outline ? "border" : "bg"}-${color}` : false));
    		}
    	};

    	return [
    		style,
    		classes,
    		$$restProps,
    		className,
    		body,
    		color,
    		inverse,
    		outline,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			class: 3,
    			body: 4,
    			color: 5,
    			inverse: 6,
    			outline: 7,
    			style: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get class() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get body() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set body(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inverse() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inverse(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\CardBody.svelte generated by Svelte v3.32.1 */
    const file$4 = "node_modules\\sveltestrap\\src\\CardBody.svelte";

    function create_fragment$5(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$4, 9, 0, 164);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardBody", slots, ['default']);
    	let { class: className = "" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 4) {
    			 $$invalidate(0, classes = classnames(className, "card-body"));
    		}
    	};

    	return [classes, $$restProps, className, $$scope, slots];
    }

    class CardBody extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardBody",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get class() {
    		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\CardHeader.svelte generated by Svelte v3.32.1 */
    const file$5 = "node_modules\\sveltestrap\\src\\CardHeader.svelte";

    // (15:0) {:else}
    function create_else_block$4(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$5, 15, 2, 291);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler_1*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(15:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (11:0) {#if tag === 'h3'}
    function create_if_block$4(ctx) {
    	let h3;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let h3_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
    	let h3_data = {};

    	for (let i = 0; i < h3_levels.length; i += 1) {
    		h3_data = assign(h3_data, h3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			if (default_slot) default_slot.c();
    			set_attributes(h3, h3_data);
    			add_location(h3, file$5, 11, 2, 213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);

    			if (default_slot) {
    				default_slot.m(h3, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(h3, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(h3, h3_data = get_spread_update(h3_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(11:0) {#if tag === 'h3'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$4, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[0] === "h3") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","tag"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardHeader", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { tag = "div" } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, tag, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
    		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
    		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 8) {
    			 $$invalidate(1, classes = classnames(className, "card-header"));
    		}
    	};

    	return [
    		tag,
    		classes,
    		$$restProps,
    		className,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1
    	];
    }

    class CardHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { class: 3, tag: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardHeader",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get class() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\CardSubtitle.svelte generated by Svelte v3.32.1 */
    const file$6 = "node_modules\\sveltestrap\\src\\CardSubtitle.svelte";

    function create_fragment$7(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$6, 9, 0, 168);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardSubtitle", slots, ['default']);
    	let { class: className = "" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 4) {
    			 $$invalidate(0, classes = classnames(className, "card-subtitle"));
    		}
    	};

    	return [classes, $$restProps, className, $$scope, slots];
    }

    class CardSubtitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardSubtitle",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get class() {
    		throw new Error("<CardSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CardSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\CardText.svelte generated by Svelte v3.32.1 */
    const file$7 = "node_modules\\sveltestrap\\src\\CardText.svelte";

    function create_fragment$8(ctx) {
    	let p;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let p_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let p_data = {};

    	for (let i = 0; i < p_levels.length; i += 1) {
    		p_data = assign(p_data, p_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			p = element("p");
    			if (default_slot) default_slot.c();
    			set_attributes(p, p_data);
    			add_location(p, file$7, 9, 0, 164);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);

    			if (default_slot) {
    				default_slot.m(p, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			set_attributes(p, p_data = get_spread_update(p_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardText", slots, ['default']);
    	let { class: className = "" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 4) {
    			 $$invalidate(0, classes = classnames(className, "card-text"));
    		}
    	};

    	return [classes, $$restProps, className, $$scope, slots];
    }

    class CardText extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardText",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get class() {
    		throw new Error("<CardText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CardText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\CardTitle.svelte generated by Svelte v3.32.1 */
    const file$8 = "node_modules\\sveltestrap\\src\\CardTitle.svelte";

    function create_fragment$9(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$8, 9, 0, 165);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CardTitle", slots, ['default']);
    	let { class: className = "" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 4) {
    			 $$invalidate(0, classes = classnames(className, "card-title"));
    		}
    	};

    	return [classes, $$restProps, className, $$scope, slots];
    }

    class CardTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardTitle",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get class() {
    		throw new Error("<CardTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CardTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Col.svelte generated by Svelte v3.32.1 */
    const file$9 = "node_modules\\sveltestrap\\src\\Col.svelte";

    function create_fragment$a(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[1],
    		{
    			class: div_class_value = /*colClasses*/ ctx[0].join(" ")
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$9, 58, 0, 1388);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				{ class: div_class_value }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class","xs","sm","md","lg","xl"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Col", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { xs = undefined } = $$props;
    	let { sm = undefined } = $$props;
    	let { md = undefined } = $$props;
    	let { lg = undefined } = $$props;
    	let { xl = undefined } = $$props;
    	const colClasses = [];
    	const lookup = { xs, sm, md, lg, xl };

    	Object.keys(lookup).forEach(colWidth => {
    		const columnProp = lookup[colWidth];

    		if (!columnProp && columnProp !== "") {
    			return; //no value for this width
    		}

    		const isXs = colWidth === "xs";

    		if (isObject(columnProp)) {
    			const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
    			const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

    			if (columnProp.size || columnProp.size === "") {
    				colClasses.push(colClass);
    			}

    			if (columnProp.push) {
    				colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
    			}

    			if (columnProp.pull) {
    				colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
    			}

    			if (columnProp.offset) {
    				colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
    			}
    		} else {
    			colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
    		}
    	});

    	if (!colClasses.length) {
    		colClasses.push("col");
    	}

    	if (className) {
    		colClasses.push(className);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("xs" in $$new_props) $$invalidate(3, xs = $$new_props.xs);
    		if ("sm" in $$new_props) $$invalidate(4, sm = $$new_props.sm);
    		if ("md" in $$new_props) $$invalidate(5, md = $$new_props.md);
    		if ("lg" in $$new_props) $$invalidate(6, lg = $$new_props.lg);
    		if ("xl" in $$new_props) $$invalidate(7, xl = $$new_props.xl);
    		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getColumnSizeClass,
    		isObject,
    		className,
    		xs,
    		sm,
    		md,
    		lg,
    		xl,
    		colClasses,
    		lookup
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("xs" in $$props) $$invalidate(3, xs = $$new_props.xs);
    		if ("sm" in $$props) $$invalidate(4, sm = $$new_props.sm);
    		if ("md" in $$props) $$invalidate(5, md = $$new_props.md);
    		if ("lg" in $$props) $$invalidate(6, lg = $$new_props.lg);
    		if ("xl" in $$props) $$invalidate(7, xl = $$new_props.xl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [colClasses, $$restProps, className, xs, sm, md, lg, xl, $$scope, slots];
    }

    class Col extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			class: 2,
    			xs: 3,
    			sm: 4,
    			md: 5,
    			lg: 6,
    			xl: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Col",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get class() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xs() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xs(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sm() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sm(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lg() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lg(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xl() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xl(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Collapse.svelte generated by Svelte v3.32.1 */
    const file$a = "node_modules\\sveltestrap\\src\\Collapse.svelte";

    // (57:0) {#if isOpen}
    function create_if_block$5(ctx) {
    	let div;
    	let div_style_value;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	let div_levels = [
    		{
    			style: div_style_value = /*navbar*/ ctx[1] ? undefined : "overflow: hidden;"
    		},
    		/*$$restProps*/ ctx[8],
    		{ class: /*classes*/ ctx[7] }
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$a, 57, 2, 1231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "introstart", /*introstart_handler*/ ctx[15], false, false, false),
    					listen_dev(div, "introend", /*introend_handler*/ ctx[16], false, false, false),
    					listen_dev(div, "outrostart", /*outrostart_handler*/ ctx[17], false, false, false),
    					listen_dev(div, "outroend", /*outroend_handler*/ ctx[18], false, false, false),
    					listen_dev(
    						div,
    						"introstart",
    						function () {
    							if (is_function(/*onEntering*/ ctx[2])) /*onEntering*/ ctx[2].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"introend",
    						function () {
    							if (is_function(/*onEntered*/ ctx[3])) /*onEntered*/ ctx[3].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"outrostart",
    						function () {
    							if (is_function(/*onExiting*/ ctx[4])) /*onExiting*/ ctx[4].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div,
    						"outroend",
    						function () {
    							if (is_function(/*onExited*/ ctx[5])) /*onExited*/ ctx[5].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8192) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*navbar*/ 2 && div_style_value !== (div_style_value = /*navbar*/ ctx[1] ? undefined : "overflow: hidden;")) && { style: div_style_value },
    				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(57:0) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[19]);
    	let if_block = /*isOpen*/ ctx[0] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[19]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"isOpen","class","navbar","onEntering","onEntered","onExiting","onExited","expand"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Collapse", slots, ['default']);
    	const noop = () => undefined;
    	let { isOpen = false } = $$props;
    	let { class: className = "" } = $$props;
    	let { navbar = false } = $$props;
    	let { onEntering = noop } = $$props;
    	let { onEntered = noop } = $$props;
    	let { onExiting = noop } = $$props;
    	let { onExited = noop } = $$props;
    	let { expand = false } = $$props;
    	let windowWidth = 0;
    	let _wasMaximazed = false;
    	const minWidth = {};
    	minWidth["xs"] = 0;
    	minWidth["sm"] = 576;
    	minWidth["md"] = 768;
    	minWidth["lg"] = 992;
    	minWidth["xl"] = 1200;
    	const dispatch = createEventDispatcher();

    	function notify() {
    		dispatch("update", { isOpen });
    	}

    	function introstart_handler(event) {
    		bubble($$self, event);
    	}

    	function introend_handler(event) {
    		bubble($$self, event);
    	}

    	function outrostart_handler(event) {
    		bubble($$self, event);
    	}

    	function outroend_handler(event) {
    		bubble($$self, event);
    	}

    	function onwindowresize() {
    		$$invalidate(6, windowWidth = window.innerWidth);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
    		if ("navbar" in $$new_props) $$invalidate(1, navbar = $$new_props.navbar);
    		if ("onEntering" in $$new_props) $$invalidate(2, onEntering = $$new_props.onEntering);
    		if ("onEntered" in $$new_props) $$invalidate(3, onEntered = $$new_props.onEntered);
    		if ("onExiting" in $$new_props) $$invalidate(4, onExiting = $$new_props.onExiting);
    		if ("onExited" in $$new_props) $$invalidate(5, onExited = $$new_props.onExited);
    		if ("expand" in $$new_props) $$invalidate(10, expand = $$new_props.expand);
    		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		createEventDispatcher,
    		slide,
    		noop,
    		isOpen,
    		className,
    		navbar,
    		onEntering,
    		onEntered,
    		onExiting,
    		onExited,
    		expand,
    		windowWidth,
    		_wasMaximazed,
    		minWidth,
    		dispatch,
    		notify,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
    		if ("navbar" in $$props) $$invalidate(1, navbar = $$new_props.navbar);
    		if ("onEntering" in $$props) $$invalidate(2, onEntering = $$new_props.onEntering);
    		if ("onEntered" in $$props) $$invalidate(3, onEntered = $$new_props.onEntered);
    		if ("onExiting" in $$props) $$invalidate(4, onExiting = $$new_props.onExiting);
    		if ("onExited" in $$props) $$invalidate(5, onExited = $$new_props.onExited);
    		if ("expand" in $$props) $$invalidate(10, expand = $$new_props.expand);
    		if ("windowWidth" in $$props) $$invalidate(6, windowWidth = $$new_props.windowWidth);
    		if ("_wasMaximazed" in $$props) $$invalidate(11, _wasMaximazed = $$new_props._wasMaximazed);
    		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, navbar*/ 514) {
    			 $$invalidate(7, classes = classnames(className, // collapseClass,
    			navbar && "navbar-collapse"));
    		}

    		if ($$self.$$.dirty & /*navbar, expand, windowWidth, minWidth, isOpen, _wasMaximazed*/ 7235) {
    			 if (navbar && expand) {
    				if (windowWidth >= minWidth[expand] && !isOpen) {
    					$$invalidate(0, isOpen = true);
    					$$invalidate(11, _wasMaximazed = true);
    					notify();
    				} else if (windowWidth < minWidth[expand] && _wasMaximazed) {
    					$$invalidate(0, isOpen = false);
    					$$invalidate(11, _wasMaximazed = false);
    					notify();
    				}
    			}
    		}
    	};

    	return [
    		isOpen,
    		navbar,
    		onEntering,
    		onEntered,
    		onExiting,
    		onExited,
    		windowWidth,
    		classes,
    		$$restProps,
    		className,
    		expand,
    		_wasMaximazed,
    		minWidth,
    		$$scope,
    		slots,
    		introstart_handler,
    		introend_handler,
    		outrostart_handler,
    		outroend_handler,
    		onwindowresize
    	];
    }

    class Collapse extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			isOpen: 0,
    			class: 9,
    			navbar: 1,
    			onEntering: 2,
    			onEntered: 3,
    			onExiting: 4,
    			onExited: 5,
    			expand: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Collapse",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get isOpen() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navbar() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navbar(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEntering() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEntering(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEntered() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEntered(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExiting() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExiting(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExited() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExited(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Container.svelte generated by Svelte v3.32.1 */
    const file$b = "node_modules\\sveltestrap\\src\\Container.svelte";

    function create_fragment$c(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$b, 10, 0, 220);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","fluid"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Container", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { fluid = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("fluid" in $$new_props) $$invalidate(3, fluid = $$new_props.fluid);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, fluid, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("fluid" in $$props) $$invalidate(3, fluid = $$new_props.fluid);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, fluid*/ 12) {
    			 $$invalidate(0, classes = classnames(className, fluid ? "container-fluid" : "container"));
    		}
    	};

    	return [classes, $$restProps, className, fluid, $$scope, slots];
    }

    class Container extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { class: 2, fluid: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Container",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get class() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fluid() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fluid(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\DropdownItem.svelte generated by Svelte v3.32.1 */
    const file$c = "node_modules\\sveltestrap\\src\\DropdownItem.svelte";

    // (49:0) {:else}
    function create_else_block$5(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let button_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$c, 49, 2, 1086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler_2*/ ctx[15], false, false, false),
    					listen_dev(button, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(49:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:15) 
    function create_if_block_2$2(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[6],
    		{ click: "" },
    		{ href: /*href*/ ctx[2] },
    		{ class: /*classes*/ ctx[3] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$c, 45, 2, 979);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*handleItemClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				{ click: "" },
    				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(45:15) ",
    		ctx
    	});

    	return block;
    }

    // (41:18) 
    function create_if_block_1$2(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let div_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$c, 41, 2, 864);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*click_handler_1*/ ctx[14], false, false, false),
    					listen_dev(div, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(41:18) ",
    		ctx
    	});

    	return block;
    }

    // (37:0) {#if header}
    function create_if_block$6(ctx) {
    	let h6;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let h6_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let h6_data = {};

    	for (let i = 0; i < h6_levels.length; i += 1) {
    		h6_data = assign(h6_data, h6_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			if (default_slot) default_slot.c();
    			set_attributes(h6, h6_data);
    			add_location(h6, file$c, 37, 2, 748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);

    			if (default_slot) {
    				default_slot.m(h6, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(h6, "click", /*click_handler*/ ctx[13], false, false, false),
    					listen_dev(h6, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			}

    			set_attributes(h6, h6_data = get_spread_update(h6_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(37:0) {#if header}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$6, create_if_block_1$2, create_if_block_2$2, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*header*/ ctx[1]) return 0;
    		if (/*divider*/ ctx[0]) return 1;
    		if (/*href*/ ctx[2]) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","active","disabled","divider","header","toggle","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DropdownItem", slots, ['default']);
    	const context = getContext("dropdownContext");
    	validate_store(context, "context");
    	component_subscribe($$self, context, value => $$invalidate(16, $context = value));
    	let { class: className = "" } = $$props;
    	let { active = false } = $$props;
    	let { disabled = false } = $$props;
    	let { divider = false } = $$props;
    	let { header = false } = $$props;
    	let { toggle = true } = $$props;
    	let { href = "" } = $$props;

    	function handleItemClick(e) {
    		if (disabled || header || divider) {
    			e.preventDefault();
    			return;
    		}

    		if (toggle) {
    			$context.toggle(e);
    		}
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function click_handler_2(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ("active" in $$new_props) $$invalidate(8, active = $$new_props.active);
    		if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ("divider" in $$new_props) $$invalidate(0, divider = $$new_props.divider);
    		if ("header" in $$new_props) $$invalidate(1, header = $$new_props.header);
    		if ("toggle" in $$new_props) $$invalidate(10, toggle = $$new_props.toggle);
    		if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		context,
    		className,
    		active,
    		disabled,
    		divider,
    		header,
    		toggle,
    		href,
    		handleItemClick,
    		classes,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
    		if ("active" in $$props) $$invalidate(8, active = $$new_props.active);
    		if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ("divider" in $$props) $$invalidate(0, divider = $$new_props.divider);
    		if ("header" in $$props) $$invalidate(1, header = $$new_props.header);
    		if ("toggle" in $$props) $$invalidate(10, toggle = $$new_props.toggle);
    		if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, disabled, divider, header, active*/ 899) {
    			 $$invalidate(3, classes = classnames(className, {
    				disabled,
    				"dropdown-item": !divider && !header,
    				active,
    				"dropdown-header": header,
    				"dropdown-divider": divider
    			}));
    		}
    	};

    	return [
    		divider,
    		header,
    		href,
    		classes,
    		context,
    		handleItemClick,
    		$$restProps,
    		className,
    		active,
    		disabled,
    		toggle,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class DropdownItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			class: 7,
    			active: 8,
    			disabled: 9,
    			divider: 0,
    			header: 1,
    			toggle: 10,
    			href: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownItem",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get divider() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set divider(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\DropdownMenu.svelte generated by Svelte v3.32.1 */
    const file$d = "node_modules\\sveltestrap\\src\\DropdownMenu.svelte";

    function create_fragment$e(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$d, 16, 0, 352);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","right"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DropdownMenu", slots, ['default']);
    	const context = getContext("dropdownContext");
    	validate_store(context, "context");
    	component_subscribe($$self, context, value => $$invalidate(5, $context = value));
    	let { class: className = "" } = $$props;
    	let { right = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ("right" in $$new_props) $$invalidate(4, right = $$new_props.right);
    		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		context,
    		className,
    		right,
    		classes,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
    		if ("right" in $$props) $$invalidate(4, right = $$new_props.right);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, right, $context*/ 56) {
    			 $$invalidate(0, classes = classnames(className, "dropdown-menu", {
    				"dropdown-menu-right": right,
    				show: $context.isOpen
    			}));
    		}
    	};

    	return [classes, context, $$restProps, className, right, $context, $$scope, slots];
    }

    class DropdownMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { class: 3, right: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownMenu",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\DropdownToggle.svelte generated by Svelte v3.32.1 */
    const file$e = "node_modules\\sveltestrap\\src\\DropdownToggle.svelte";

    // (67:0) {:else}
    function create_else_block$6(ctx) {
    	let button;
    	let current;

    	const button_spread_levels = [
    		/*$$restProps*/ ctx[10],
    		{ ariaHaspopup: /*ariaHaspopup*/ ctx[1] },
    		{ class: /*classes*/ ctx[7] },
    		{ color: /*color*/ ctx[0] },
    		{ size: /*size*/ ctx[4] },
    		{ outline: /*outline*/ ctx[6] }
    	];

    	let button_props = {
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < button_spread_levels.length; i += 1) {
    		button_props = assign(button_props, button_spread_levels[i]);
    	}

    	button = new Button({ props: button_props, $$inline: true });
    	button.$on("click", /*click_handler_2*/ ctx[18]);
    	button.$on("click", /*toggleButton*/ ctx[9]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = (dirty & /*$$restProps, ariaHaspopup, classes, color, size, outline*/ 1235)
    			? get_spread_update(button_spread_levels, [
    					dirty & /*$$restProps*/ 1024 && get_spread_object(/*$$restProps*/ ctx[10]),
    					dirty & /*ariaHaspopup*/ 2 && { ariaHaspopup: /*ariaHaspopup*/ ctx[1] },
    					dirty & /*classes*/ 128 && { class: /*classes*/ ctx[7] },
    					dirty & /*color*/ 1 && { color: /*color*/ ctx[0] },
    					dirty & /*size*/ 16 && { size: /*size*/ ctx[4] },
    					dirty & /*outline*/ 64 && { outline: /*outline*/ ctx[6] }
    				])
    			: {};

    			if (dirty & /*$$scope, ariaLabel*/ 524292) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(67:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:25) 
    function create_if_block_1$3(ctx) {
    	let span;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

    	let span_levels = [
    		/*$$restProps*/ ctx[10],
    		{ ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    		{ class: /*classes*/ ctx[7] },
    		{ color: /*color*/ ctx[0] },
    		{ size: /*size*/ ctx[4] }
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(span, span_data);
    			add_location(span, file$e, 54, 2, 1098);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "click", /*click_handler_1*/ ctx[17], false, false, false),
    					listen_dev(span, "click", /*toggleButton*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 524288) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*ariaLabel*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
    				(!current || dirty & /*ariaHaspopup*/ 2) && { ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*color*/ 1) && { color: /*color*/ ctx[0] },
    				(!current || dirty & /*size*/ 16) && { size: /*size*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(54:25) ",
    		ctx
    	});

    	return block;
    }

    // (42:0) {#if nav}
    function create_if_block$7(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[10],
    		{ href: "#nav" },
    		{ ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    		{ class: /*classes*/ ctx[7] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(a, a_data);
    			add_location(a, file$e, 42, 2, 872);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[16], false, false, false),
    					listen_dev(a, "click", /*toggleButton*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 524288) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*ariaLabel*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
    				{ href: "#nav" },
    				(!current || dirty & /*ariaHaspopup*/ 2) && { ariahaspopup: /*ariaHaspopup*/ ctx[1] },
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(42:0) {#if nav}",
    		ctx
    	});

    	return block;
    }

    // (77:10)        
    function fallback_block_2(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*ariaLabel*/ ctx[2]);
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$e, 77, 6, 1483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(77:10)        ",
    		ctx
    	});

    	return block;
    }

    // (68:2) <Button     {...$$restProps}     on:click     on:click={toggleButton}     {ariaHaspopup}     class={classes}     {color}     {size}     {outline}>
    function create_default_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 524288) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*ariaLabel*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(68:2) <Button     {...$$restProps}     on:click     on:click={toggleButton}     {ariaHaspopup}     class={classes}     {color}     {size}     {outline}>",
    		ctx
    	});

    	return block;
    }

    // (63:10)        
    function fallback_block_1(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*ariaLabel*/ ctx[2]);
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$e, 63, 6, 1246);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(63:10)        ",
    		ctx
    	});

    	return block;
    }

    // (50:10)        
    function fallback_block$1(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*ariaLabel*/ ctx[2]);
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$e, 50, 6, 1010);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 4) set_data_dev(t, /*ariaLabel*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(50:10)        ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_if_block_1$3, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[3]) return 0;
    		if (/*tag*/ ctx[5] === "span") return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","caret","color","disabled","ariaHaspopup","ariaLabel","split","nav","size","tag","outline"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DropdownToggle", slots, ['default']);
    	const context = getContext("dropdownContext");
    	validate_store(context, "context");
    	component_subscribe($$self, context, value => $$invalidate(20, $context = value));
    	let { class: className = "" } = $$props;
    	let { caret = false } = $$props;
    	let { color = "secondary" } = $$props;
    	let { disabled = false } = $$props;
    	let { ariaHaspopup = true } = $$props;
    	let { ariaLabel = "Toggle Dropdown" } = $$props;
    	let { split = false } = $$props;
    	let { nav = false } = $$props;
    	let { size = "" } = $$props;
    	let { tag = null } = $$props;
    	let { outline = false } = $$props;

    	function toggleButton(e) {
    		if (disabled) {
    			e.preventDefault();
    			return;
    		}

    		if (nav) {
    			e.preventDefault();
    		}

    		$context.toggle(e);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function click_handler_2(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(11, className = $$new_props.class);
    		if ("caret" in $$new_props) $$invalidate(12, caret = $$new_props.caret);
    		if ("color" in $$new_props) $$invalidate(0, color = $$new_props.color);
    		if ("disabled" in $$new_props) $$invalidate(13, disabled = $$new_props.disabled);
    		if ("ariaHaspopup" in $$new_props) $$invalidate(1, ariaHaspopup = $$new_props.ariaHaspopup);
    		if ("ariaLabel" in $$new_props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    		if ("split" in $$new_props) $$invalidate(14, split = $$new_props.split);
    		if ("nav" in $$new_props) $$invalidate(3, nav = $$new_props.nav);
    		if ("size" in $$new_props) $$invalidate(4, size = $$new_props.size);
    		if ("tag" in $$new_props) $$invalidate(5, tag = $$new_props.tag);
    		if ("outline" in $$new_props) $$invalidate(6, outline = $$new_props.outline);
    		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		Button,
    		context,
    		className,
    		caret,
    		color,
    		disabled,
    		ariaHaspopup,
    		ariaLabel,
    		split,
    		nav,
    		size,
    		tag,
    		outline,
    		toggleButton,
    		classes,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(11, className = $$new_props.className);
    		if ("caret" in $$props) $$invalidate(12, caret = $$new_props.caret);
    		if ("color" in $$props) $$invalidate(0, color = $$new_props.color);
    		if ("disabled" in $$props) $$invalidate(13, disabled = $$new_props.disabled);
    		if ("ariaHaspopup" in $$props) $$invalidate(1, ariaHaspopup = $$new_props.ariaHaspopup);
    		if ("ariaLabel" in $$props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    		if ("split" in $$props) $$invalidate(14, split = $$new_props.split);
    		if ("nav" in $$props) $$invalidate(3, nav = $$new_props.nav);
    		if ("size" in $$props) $$invalidate(4, size = $$new_props.size);
    		if ("tag" in $$props) $$invalidate(5, tag = $$new_props.tag);
    		if ("outline" in $$props) $$invalidate(6, outline = $$new_props.outline);
    		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, caret, split, nav*/ 22536) {
    			 $$invalidate(7, classes = classnames(className, {
    				"dropdown-toggle": caret || split,
    				"dropdown-toggle-split": split,
    				"nav-link": nav
    			}));
    		}
    	};

    	return [
    		color,
    		ariaHaspopup,
    		ariaLabel,
    		nav,
    		size,
    		tag,
    		outline,
    		classes,
    		context,
    		toggleButton,
    		$$restProps,
    		className,
    		caret,
    		disabled,
    		split,
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		$$scope
    	];
    }

    class DropdownToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			class: 11,
    			caret: 12,
    			color: 0,
    			disabled: 13,
    			ariaHaspopup: 1,
    			ariaLabel: 2,
    			split: 14,
    			nav: 3,
    			size: 4,
    			tag: 5,
    			outline: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownToggle",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caret() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caret(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaHaspopup() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaHaspopup(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaLabel() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get split() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set split(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Form.svelte generated by Svelte v3.32.1 */
    const file$f = "node_modules\\sveltestrap\\src\\Form.svelte";

    function create_fragment$g(ctx) {
    	let form;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let form_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let form_data = {};

    	for (let i = 0; i < form_levels.length; i += 1) {
    		form_data = assign(form_data, form_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			form = element("form");
    			if (default_slot) default_slot.c();
    			set_attributes(form, form_data);
    			add_location(form, file$f, 10, 0, 212);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);

    			if (default_slot) {
    				default_slot.m(form, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", /*submit_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(form, form_data = get_spread_update(form_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","inline"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Form", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { inline = false } = $$props;

    	function submit_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("inline" in $$new_props) $$invalidate(3, inline = $$new_props.inline);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, inline, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("inline" in $$props) $$invalidate(3, inline = $$new_props.inline);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, inline*/ 12) {
    			 $$invalidate(0, classes = classnames(className, inline ? "form-inline" : false));
    		}
    	};

    	return [classes, $$restProps, className, inline, $$scope, slots, submit_handler];
    }

    class Form extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { class: 2, inline: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Form",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get class() {
    		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inline() {
    		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inline(value) {
    		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Icon.svelte generated by Svelte v3.32.1 */
    const file$g = "node_modules\\sveltestrap\\src\\Icon.svelte";

    function create_fragment$h(ctx) {
    	let i;
    	let i_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let i_data = {};

    	for (let i = 0; i < i_levels.length; i += 1) {
    		i_data = assign(i_data, i_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			i = element("i");
    			set_attributes(i, i_data);
    			add_location(i, file$g, 14, 0, 301);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(i, i_data = get_spread_update(i_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				dirty & /*classes*/ 1 && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","name"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Icon", slots, []);
    	let { class: className = "" } = $$props;
    	let { name = "" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("name" in $$new_props) $$invalidate(3, name = $$new_props.name);
    	};

    	$$self.$capture_state = () => ({ classnames, className, name, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("name" in $$props) $$invalidate(3, name = $$new_props.name);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, name*/ 12) {
    			 $$invalidate(0, classes = classnames(className, `bi-${name}`));
    		}
    	};

    	return [classes, $$restProps, className, name];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { class: 2, name: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get class() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Input.svelte generated by Svelte v3.32.1 */
    const file$h = "node_modules\\sveltestrap\\src\\Input.svelte";

    // (356:40) 
    function create_if_block_16(ctx) {
    	let select;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

    	let select_levels = [
    		/*$$restProps*/ ctx[12],
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ readonly: /*readonly*/ ctx[4] }
    	];

    	let select_data = {};

    	for (let i = 0; i < select_levels.length; i += 1) {
    		select_data = assign(select_data, select_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			if (default_slot) default_slot.c();
    			set_attributes(select, select_data);
    			if (/*value*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[152].call(select));
    			add_location(select, file$h, 356, 2, 7097);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			if (select_data.multiple) select_options(select, select_data.value);
    			select_option(select, /*value*/ ctx[1]);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "blur", /*blur_handler_16*/ ctx[133], false, false, false),
    					listen_dev(select, "focus", /*focus_handler_16*/ ctx[134], false, false, false),
    					listen_dev(select, "change", /*change_handler_15*/ ctx[135], false, false, false),
    					listen_dev(select, "input", /*input_handler_15*/ ctx[136], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[152])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 2097152) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, null, null);
    				}
    			}

    			set_attributes(select, select_data = get_spread_update(select_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
    				(!current || dirty[0] & /*name*/ 64) && { name: /*name*/ ctx[6] },
    				(!current || dirty[0] & /*disabled*/ 256) && { disabled: /*disabled*/ ctx[8] },
    				(!current || dirty[0] & /*readonly*/ 16) && { readonly: /*readonly*/ ctx[4] }
    			]));

    			if (dirty[0] & /*$$restProps, classes, name, disabled, readonly*/ 4944 && select_data.multiple) select_options(select, select_data.value);

    			if (dirty[0] & /*value*/ 2) {
    				select_option(select, /*value*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(356:40) ",
    		ctx
    	});

    	return block;
    }

    // (340:29) 
    function create_if_block_15(ctx) {
    	let textarea;
    	let mounted;
    	let dispose;

    	let textarea_levels = [
    		/*$$restProps*/ ctx[12],
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] },
    		{ readOnly: /*readonly*/ ctx[4] }
    	];

    	let textarea_data = {};

    	for (let i = 0; i < textarea_levels.length; i += 1) {
    		textarea_data = assign(textarea_data, textarea_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			set_attributes(textarea, textarea_data);
    			add_location(textarea, file$h, 340, 2, 6830);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			set_input_value(textarea, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "blur", /*blur_handler_15*/ ctx[126], false, false, false),
    					listen_dev(textarea, "focus", /*focus_handler_15*/ ctx[127], false, false, false),
    					listen_dev(textarea, "keydown", /*keydown_handler_15*/ ctx[128], false, false, false),
    					listen_dev(textarea, "keypress", /*keypress_handler_15*/ ctx[129], false, false, false),
    					listen_dev(textarea, "keyup", /*keyup_handler_15*/ ctx[130], false, false, false),
    					listen_dev(textarea, "change", /*change_handler_14*/ ctx[131], false, false, false),
    					listen_dev(textarea, "input", /*input_handler_14*/ ctx[132], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[151])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(textarea, /*value*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(340:29) ",
    		ctx
    	});

    	return block;
    }

    // (82:0) {#if tag === 'input'}
    function create_if_block$8(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*type*/ ctx[3] === "text") return create_if_block_1$4;
    		if (/*type*/ ctx[3] === "password") return create_if_block_2$3;
    		if (/*type*/ ctx[3] === "email") return create_if_block_3$1;
    		if (/*type*/ ctx[3] === "file") return create_if_block_4;
    		if (/*type*/ ctx[3] === "checkbox") return create_if_block_5;
    		if (/*type*/ ctx[3] === "radio") return create_if_block_6;
    		if (/*type*/ ctx[3] === "url") return create_if_block_7;
    		if (/*type*/ ctx[3] === "number") return create_if_block_8;
    		if (/*type*/ ctx[3] === "date") return create_if_block_9;
    		if (/*type*/ ctx[3] === "time") return create_if_block_10;
    		if (/*type*/ ctx[3] === "datetime") return create_if_block_11;
    		if (/*type*/ ctx[3] === "color") return create_if_block_12;
    		if (/*type*/ ctx[3] === "range") return create_if_block_13;
    		if (/*type*/ ctx[3] === "search") return create_if_block_14;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(82:0) {#if tag === 'input'}",
    		ctx
    	});

    	return block;
    }

    // (322:2) {:else}
    function create_else_block$7(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: /*type*/ ctx[3] },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] },
    		{ value: /*value*/ ctx[1] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 322, 4, 6503);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.value = input_data.value;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_14*/ ctx[121], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_14*/ ctx[122], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_14*/ ctx[123], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_14*/ ctx[124], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_14*/ ctx[125], false, false, false),
    					listen_dev(input, "input", /*handleInput*/ ctx[11], false, false, false),
    					listen_dev(input, "change", /*handleInput*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				dirty[0] & /*type*/ 8 && { type: /*type*/ ctx[3] },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] },
    				dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1] && { value: /*value*/ ctx[1] }
    			]));

    			if ("value" in input_data) {
    				input.value = input_data.value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(322:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (305:30) 
    function create_if_block_14(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "search" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 305, 4, 6220);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_13*/ ctx[114], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_13*/ ctx[115], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_13*/ ctx[116], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_13*/ ctx[117], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_13*/ ctx[118], false, false, false),
    					listen_dev(input, "change", /*change_handler_13*/ ctx[119], false, false, false),
    					listen_dev(input, "input", /*input_handler_13*/ ctx[120], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_9*/ ctx[150])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "search" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(305:30) ",
    		ctx
    	});

    	return block;
    }

    // (288:29) 
    function create_if_block_13(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "range" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 288, 4, 5917);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_12*/ ctx[107], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_12*/ ctx[108], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_12*/ ctx[109], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_12*/ ctx[110], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_12*/ ctx[111], false, false, false),
    					listen_dev(input, "change", /*change_handler_12*/ ctx[112], false, false, false),
    					listen_dev(input, "input", /*input_handler_12*/ ctx[113], false, false, false),
    					listen_dev(input, "change", /*input_change_input_handler*/ ctx[149]),
    					listen_dev(input, "input", /*input_change_input_handler*/ ctx[149])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "range" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(288:29) ",
    		ctx
    	});

    	return block;
    }

    // (271:29) 
    function create_if_block_12(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "color" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 271, 4, 5615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_11*/ ctx[100], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_11*/ ctx[101], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_11*/ ctx[102], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_11*/ ctx[103], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_11*/ ctx[104], false, false, false),
    					listen_dev(input, "change", /*change_handler_11*/ ctx[105], false, false, false),
    					listen_dev(input, "input", /*input_handler_11*/ ctx[106], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_8*/ ctx[148])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "color" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(271:29) ",
    		ctx
    	});

    	return block;
    }

    // (254:32) 
    function create_if_block_11(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "datetime" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 254, 4, 5310);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_10*/ ctx[93], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_10*/ ctx[94], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_10*/ ctx[95], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_10*/ ctx[96], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_10*/ ctx[97], false, false, false),
    					listen_dev(input, "change", /*change_handler_10*/ ctx[98], false, false, false),
    					listen_dev(input, "input", /*input_handler_10*/ ctx[99], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_7*/ ctx[147])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "datetime" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(254:32) ",
    		ctx
    	});

    	return block;
    }

    // (237:28) 
    function create_if_block_10(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "time" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 237, 4, 5006);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_9*/ ctx[86], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_9*/ ctx[87], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_9*/ ctx[88], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_9*/ ctx[89], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_9*/ ctx[90], false, false, false),
    					listen_dev(input, "change", /*change_handler_9*/ ctx[91], false, false, false),
    					listen_dev(input, "input", /*input_handler_9*/ ctx[92], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_6*/ ctx[146])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "time" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(237:28) ",
    		ctx
    	});

    	return block;
    }

    // (220:28) 
    function create_if_block_9(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "date" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 220, 4, 4706);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_8*/ ctx[79], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_8*/ ctx[80], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_8*/ ctx[81], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_8*/ ctx[82], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_8*/ ctx[83], false, false, false),
    					listen_dev(input, "change", /*change_handler_8*/ ctx[84], false, false, false),
    					listen_dev(input, "input", /*input_handler_8*/ ctx[85], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_5*/ ctx[145])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "date" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(220:28) ",
    		ctx
    	});

    	return block;
    }

    // (203:30) 
    function create_if_block_8(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "number" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 203, 4, 4404);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_7*/ ctx[72], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_7*/ ctx[73], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_7*/ ctx[74], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_7*/ ctx[75], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_7*/ ctx[76], false, false, false),
    					listen_dev(input, "change", /*change_handler_7*/ ctx[77], false, false, false),
    					listen_dev(input, "input", /*input_handler_7*/ ctx[78], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_4*/ ctx[144])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "number" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2 && to_number(input.value) !== /*value*/ ctx[1]) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(203:30) ",
    		ctx
    	});

    	return block;
    }

    // (186:27) 
    function create_if_block_7(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "url" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 186, 4, 4103);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_6*/ ctx[65], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_6*/ ctx[66], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_6*/ ctx[67], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_6*/ ctx[68], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_6*/ ctx[69], false, false, false),
    					listen_dev(input, "change", /*change_handler_6*/ ctx[70], false, false, false),
    					listen_dev(input, "input", /*input_handler_6*/ ctx[71], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_3*/ ctx[143])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "url" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(186:27) ",
    		ctx
    	});

    	return block;
    }

    // (169:29) 
    function create_if_block_6(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "radio" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 169, 4, 3803);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_5*/ ctx[58], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_5*/ ctx[59], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_5*/ ctx[60], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_5*/ ctx[61], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_5*/ ctx[62], false, false, false),
    					listen_dev(input, "change", /*change_handler_5*/ ctx[63], false, false, false),
    					listen_dev(input, "input", /*input_handler_5*/ ctx[64], false, false, false),
    					listen_dev(input, "change", /*input_change_handler_2*/ ctx[142])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "radio" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(169:29) ",
    		ctx
    	});

    	return block;
    }

    // (151:32) 
    function create_if_block_5(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "checkbox" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 151, 4, 3479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = /*checked*/ ctx[0];
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_4*/ ctx[51], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_4*/ ctx[52], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_4*/ ctx[53], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_4*/ ctx[54], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_4*/ ctx[55], false, false, false),
    					listen_dev(input, "change", /*change_handler_4*/ ctx[56], false, false, false),
    					listen_dev(input, "input", /*input_handler_4*/ ctx[57], false, false, false),
    					listen_dev(input, "change", /*input_change_handler_1*/ ctx[141])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "checkbox" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*checked*/ 1) {
    				input.checked = /*checked*/ ctx[0];
    			}

    			if (dirty[0] & /*value*/ 2) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(151:32) ",
    		ctx
    	});

    	return block;
    }

    // (134:28) 
    function create_if_block_4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "file" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 134, 4, 3175);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_3*/ ctx[44], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_3*/ ctx[45], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_3*/ ctx[46], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_3*/ ctx[47], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_3*/ ctx[48], false, false, false),
    					listen_dev(input, "change", /*change_handler_3*/ ctx[49], false, false, false),
    					listen_dev(input, "input", /*input_handler_3*/ ctx[50], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[140])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "file" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(134:28) ",
    		ctx
    	});

    	return block;
    }

    // (117:29) 
    function create_if_block_3$1(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "email" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 117, 4, 2874);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_2*/ ctx[37], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_2*/ ctx[38], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_2*/ ctx[39], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_2*/ ctx[40], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_2*/ ctx[41], false, false, false),
    					listen_dev(input, "change", /*change_handler_2*/ ctx[42], false, false, false),
    					listen_dev(input, "input", /*input_handler_2*/ ctx[43], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_2*/ ctx[139])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "email" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(117:29) ",
    		ctx
    	});

    	return block;
    }

    // (100:32) 
    function create_if_block_2$3(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "password" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 100, 4, 2569);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_1*/ ctx[30], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_1*/ ctx[31], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_1*/ ctx[32], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_1*/ ctx[33], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_1*/ ctx[34], false, false, false),
    					listen_dev(input, "change", /*change_handler_1*/ ctx[35], false, false, false),
    					listen_dev(input, "input", /*input_handler_1*/ ctx[36], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_1*/ ctx[138])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "password" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(100:32) ",
    		ctx
    	});

    	return block;
    }

    // (83:2) {#if type === 'text'}
    function create_if_block_1$4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[12],
    		{ type: "text" },
    		{ readOnly: /*readonly*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ name: /*name*/ ctx[6] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$h, 83, 4, 2265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler*/ ctx[23], false, false, false),
    					listen_dev(input, "focus", /*focus_handler*/ ctx[24], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler*/ ctx[25], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler*/ ctx[26], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler*/ ctx[27], false, false, false),
    					listen_dev(input, "change", /*change_handler*/ ctx[28], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[29], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[137])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12],
    				{ type: "text" },
    				dirty[0] & /*readonly*/ 16 && { readOnly: /*readonly*/ ctx[4] },
    				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*name*/ 64 && { name: /*name*/ ctx[6] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 128 && { placeholder: /*placeholder*/ ctx[7] }
    			]));

    			if (dirty[0] & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
    				set_input_value(input, /*value*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(83:2) {#if type === 'text'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_if_block_15, create_if_block_16];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[10] === "input") return 0;
    		if (/*tag*/ ctx[10] === "textarea") return 1;
    		if (/*tag*/ ctx[10] === "select" && !/*multiple*/ ctx[5]) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"class","type","size","bsSize","color","checked","valid","invalid","plaintext","addon","value","files","readonly","multiple","name","placeholder","disabled"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Input", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { type = "text" } = $$props;
    	let { size = undefined } = $$props;
    	let { bsSize = undefined } = $$props;
    	let { color = undefined } = $$props;
    	let { checked = false } = $$props;
    	let { valid = false } = $$props;
    	let { invalid = false } = $$props;
    	let { plaintext = false } = $$props;
    	let { addon = false } = $$props;
    	let { value = "" } = $$props;
    	let { files = "" } = $$props;
    	let { readonly = undefined } = $$props;
    	let { multiple = undefined } = $$props;
    	let { name = "" } = $$props;
    	let { placeholder = "" } = $$props;
    	let { disabled = undefined } = $$props;
    	let classes;
    	let tag;

    	const handleInput = event => {
    		$$invalidate(1, value = event.target.value);
    	};

    	function blur_handler(event) {
    		bubble($$self, event);
    	}

    	function focus_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_1(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_1(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_1(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_1(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble($$self, event);
    	}

    	function change_handler_1(event) {
    		bubble($$self, event);
    	}

    	function input_handler_1(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_2(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_2(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_2(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_2(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble($$self, event);
    	}

    	function change_handler_2(event) {
    		bubble($$self, event);
    	}

    	function input_handler_2(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_3(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_3(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_3(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_3(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_3(event) {
    		bubble($$self, event);
    	}

    	function change_handler_3(event) {
    		bubble($$self, event);
    	}

    	function input_handler_3(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_4(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_4(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_4(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_4(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_4(event) {
    		bubble($$self, event);
    	}

    	function change_handler_4(event) {
    		bubble($$self, event);
    	}

    	function input_handler_4(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_5(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_5(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_5(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_5(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_5(event) {
    		bubble($$self, event);
    	}

    	function change_handler_5(event) {
    		bubble($$self, event);
    	}

    	function input_handler_5(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_6(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_6(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_6(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_6(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_6(event) {
    		bubble($$self, event);
    	}

    	function change_handler_6(event) {
    		bubble($$self, event);
    	}

    	function input_handler_6(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_7(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_7(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_7(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_7(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_7(event) {
    		bubble($$self, event);
    	}

    	function change_handler_7(event) {
    		bubble($$self, event);
    	}

    	function input_handler_7(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_8(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_8(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_8(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_8(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_8(event) {
    		bubble($$self, event);
    	}

    	function change_handler_8(event) {
    		bubble($$self, event);
    	}

    	function input_handler_8(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_9(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_9(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_9(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_9(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_9(event) {
    		bubble($$self, event);
    	}

    	function change_handler_9(event) {
    		bubble($$self, event);
    	}

    	function input_handler_9(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_10(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_10(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_10(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_10(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_10(event) {
    		bubble($$self, event);
    	}

    	function change_handler_10(event) {
    		bubble($$self, event);
    	}

    	function input_handler_10(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_11(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_11(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_11(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_11(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_11(event) {
    		bubble($$self, event);
    	}

    	function change_handler_11(event) {
    		bubble($$self, event);
    	}

    	function input_handler_11(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_12(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_12(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_12(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_12(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_12(event) {
    		bubble($$self, event);
    	}

    	function change_handler_12(event) {
    		bubble($$self, event);
    	}

    	function input_handler_12(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_13(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_13(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_13(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_13(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_13(event) {
    		bubble($$self, event);
    	}

    	function change_handler_13(event) {
    		bubble($$self, event);
    	}

    	function input_handler_13(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_14(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_14(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_14(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_14(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_14(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_15(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_15(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler_15(event) {
    		bubble($$self, event);
    	}

    	function keypress_handler_15(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler_15(event) {
    		bubble($$self, event);
    	}

    	function change_handler_14(event) {
    		bubble($$self, event);
    	}

    	function input_handler_14(event) {
    		bubble($$self, event);
    	}

    	function blur_handler_16(event) {
    		bubble($$self, event);
    	}

    	function focus_handler_16(event) {
    		bubble($$self, event);
    	}

    	function change_handler_15(event) {
    		bubble($$self, event);
    	}

    	function input_handler_15(event) {
    		bubble($$self, event);
    	}

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_input_handler_1() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_input_handler_2() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_change_handler() {
    		files = this.files;
    		$$invalidate(2, files);
    	}

    	function input_change_handler_1() {
    		checked = this.checked;
    		value = this.value;
    		$$invalidate(0, checked);
    		$$invalidate(1, value);
    	}

    	function input_change_handler_2() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_input_handler_3() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_input_handler_4() {
    		value = to_number(this.value);
    		$$invalidate(1, value);
    	}

    	function input_input_handler_5() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_input_handler_6() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_input_handler_7() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_input_handler_8() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function input_change_input_handler() {
    		value = to_number(this.value);
    		$$invalidate(1, value);
    	}

    	function input_input_handler_9() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function textarea_input_handler() {
    		value = this.value;
    		$$invalidate(1, value);
    	}

    	function select_change_handler() {
    		value = select_value(this);
    		$$invalidate(1, value);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(15, className = $$new_props.class);
    		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
    		if ("size" in $$new_props) $$invalidate(13, size = $$new_props.size);
    		if ("bsSize" in $$new_props) $$invalidate(14, bsSize = $$new_props.bsSize);
    		if ("color" in $$new_props) $$invalidate(16, color = $$new_props.color);
    		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    		if ("valid" in $$new_props) $$invalidate(17, valid = $$new_props.valid);
    		if ("invalid" in $$new_props) $$invalidate(18, invalid = $$new_props.invalid);
    		if ("plaintext" in $$new_props) $$invalidate(19, plaintext = $$new_props.plaintext);
    		if ("addon" in $$new_props) $$invalidate(20, addon = $$new_props.addon);
    		if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
    		if ("files" in $$new_props) $$invalidate(2, files = $$new_props.files);
    		if ("readonly" in $$new_props) $$invalidate(4, readonly = $$new_props.readonly);
    		if ("multiple" in $$new_props) $$invalidate(5, multiple = $$new_props.multiple);
    		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
    		if ("placeholder" in $$new_props) $$invalidate(7, placeholder = $$new_props.placeholder);
    		if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ("$$scope" in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		type,
    		size,
    		bsSize,
    		color,
    		checked,
    		valid,
    		invalid,
    		plaintext,
    		addon,
    		value,
    		files,
    		readonly,
    		multiple,
    		name,
    		placeholder,
    		disabled,
    		classes,
    		tag,
    		handleInput
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(15, className = $$new_props.className);
    		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
    		if ("size" in $$props) $$invalidate(13, size = $$new_props.size);
    		if ("bsSize" in $$props) $$invalidate(14, bsSize = $$new_props.bsSize);
    		if ("color" in $$props) $$invalidate(16, color = $$new_props.color);
    		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
    		if ("valid" in $$props) $$invalidate(17, valid = $$new_props.valid);
    		if ("invalid" in $$props) $$invalidate(18, invalid = $$new_props.invalid);
    		if ("plaintext" in $$props) $$invalidate(19, plaintext = $$new_props.plaintext);
    		if ("addon" in $$props) $$invalidate(20, addon = $$new_props.addon);
    		if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
    		if ("files" in $$props) $$invalidate(2, files = $$new_props.files);
    		if ("readonly" in $$props) $$invalidate(4, readonly = $$new_props.readonly);
    		if ("multiple" in $$props) $$invalidate(5, multiple = $$new_props.multiple);
    		if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
    		if ("placeholder" in $$props) $$invalidate(7, placeholder = $$new_props.placeholder);
    		if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ("classes" in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ("tag" in $$props) $$invalidate(10, tag = $$new_props.tag);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*type, plaintext, addon, color, size, className, invalid, valid, bsSize*/ 2088968) {
    			 {
    				const checkInput = ["radio", "checkbox"].indexOf(type) > -1;
    				const isNotaNumber = new RegExp("\\D", "g");
    				const fileInput = type === "file";
    				const textareaInput = type === "textarea";
    				const rangeInput = type === "range";
    				const selectInput = type === "select";
    				const buttonInput = type === "button" || type === "reset" || type === "submit";
    				const unsupportedInput = type === "hidden" || type === "image";
    				$$invalidate(10, tag = selectInput || textareaInput ? type : "input");
    				let formControlClass = "form-control";

    				if (plaintext) {
    					formControlClass = `${formControlClass}-plaintext`;
    					$$invalidate(10, tag = "input");
    				} else if (fileInput) {
    					formControlClass = `${formControlClass}-file`;
    				} else if (checkInput) {
    					if (addon) {
    						formControlClass = null;
    					} else {
    						formControlClass = "form-check-input";
    					}
    				} else if (buttonInput) {
    					formControlClass = `btn btn-${color || "secondary"}`;
    				} else if (rangeInput) {
    					formControlClass = "form-control-range";
    				} else if (unsupportedInput) {
    					formControlClass = "";
    				}

    				if (size && isNotaNumber.test(size)) {
    					console.warn("Please use the prop \"bsSize\" instead of the \"size\" to bootstrap's input sizing.");
    					$$invalidate(14, bsSize = size);
    					$$invalidate(13, size = undefined);
    				}

    				$$invalidate(9, classes = classnames(className, invalid && "is-invalid", valid && "is-valid", bsSize ? `form-control-${bsSize}` : false, formControlClass));
    			}
    		}
    	};

    	return [
    		checked,
    		value,
    		files,
    		type,
    		readonly,
    		multiple,
    		name,
    		placeholder,
    		disabled,
    		classes,
    		tag,
    		handleInput,
    		$$restProps,
    		size,
    		bsSize,
    		className,
    		color,
    		valid,
    		invalid,
    		plaintext,
    		addon,
    		$$scope,
    		slots,
    		blur_handler,
    		focus_handler,
    		keydown_handler,
    		keypress_handler,
    		keyup_handler,
    		change_handler,
    		input_handler,
    		blur_handler_1,
    		focus_handler_1,
    		keydown_handler_1,
    		keypress_handler_1,
    		keyup_handler_1,
    		change_handler_1,
    		input_handler_1,
    		blur_handler_2,
    		focus_handler_2,
    		keydown_handler_2,
    		keypress_handler_2,
    		keyup_handler_2,
    		change_handler_2,
    		input_handler_2,
    		blur_handler_3,
    		focus_handler_3,
    		keydown_handler_3,
    		keypress_handler_3,
    		keyup_handler_3,
    		change_handler_3,
    		input_handler_3,
    		blur_handler_4,
    		focus_handler_4,
    		keydown_handler_4,
    		keypress_handler_4,
    		keyup_handler_4,
    		change_handler_4,
    		input_handler_4,
    		blur_handler_5,
    		focus_handler_5,
    		keydown_handler_5,
    		keypress_handler_5,
    		keyup_handler_5,
    		change_handler_5,
    		input_handler_5,
    		blur_handler_6,
    		focus_handler_6,
    		keydown_handler_6,
    		keypress_handler_6,
    		keyup_handler_6,
    		change_handler_6,
    		input_handler_6,
    		blur_handler_7,
    		focus_handler_7,
    		keydown_handler_7,
    		keypress_handler_7,
    		keyup_handler_7,
    		change_handler_7,
    		input_handler_7,
    		blur_handler_8,
    		focus_handler_8,
    		keydown_handler_8,
    		keypress_handler_8,
    		keyup_handler_8,
    		change_handler_8,
    		input_handler_8,
    		blur_handler_9,
    		focus_handler_9,
    		keydown_handler_9,
    		keypress_handler_9,
    		keyup_handler_9,
    		change_handler_9,
    		input_handler_9,
    		blur_handler_10,
    		focus_handler_10,
    		keydown_handler_10,
    		keypress_handler_10,
    		keyup_handler_10,
    		change_handler_10,
    		input_handler_10,
    		blur_handler_11,
    		focus_handler_11,
    		keydown_handler_11,
    		keypress_handler_11,
    		keyup_handler_11,
    		change_handler_11,
    		input_handler_11,
    		blur_handler_12,
    		focus_handler_12,
    		keydown_handler_12,
    		keypress_handler_12,
    		keyup_handler_12,
    		change_handler_12,
    		input_handler_12,
    		blur_handler_13,
    		focus_handler_13,
    		keydown_handler_13,
    		keypress_handler_13,
    		keyup_handler_13,
    		change_handler_13,
    		input_handler_13,
    		blur_handler_14,
    		focus_handler_14,
    		keydown_handler_14,
    		keypress_handler_14,
    		keyup_handler_14,
    		blur_handler_15,
    		focus_handler_15,
    		keydown_handler_15,
    		keypress_handler_15,
    		keyup_handler_15,
    		change_handler_14,
    		input_handler_14,
    		blur_handler_16,
    		focus_handler_16,
    		change_handler_15,
    		input_handler_15,
    		input_input_handler,
    		input_input_handler_1,
    		input_input_handler_2,
    		input_change_handler,
    		input_change_handler_1,
    		input_change_handler_2,
    		input_input_handler_3,
    		input_input_handler_4,
    		input_input_handler_5,
    		input_input_handler_6,
    		input_input_handler_7,
    		input_input_handler_8,
    		input_change_input_handler,
    		input_input_handler_9,
    		textarea_input_handler,
    		select_change_handler
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$i,
    			create_fragment$i,
    			safe_not_equal,
    			{
    				class: 15,
    				type: 3,
    				size: 13,
    				bsSize: 14,
    				color: 16,
    				checked: 0,
    				valid: 17,
    				invalid: 18,
    				plaintext: 19,
    				addon: 20,
    				value: 1,
    				files: 2,
    				readonly: 4,
    				multiple: 5,
    				name: 6,
    				placeholder: 7,
    				disabled: 8
    			},
    			[-1, -1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get class() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bsSize() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bsSize(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plaintext() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plaintext(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addon() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addon(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get files() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set files(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readonly() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readonly(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Nav.svelte generated by Svelte v3.32.1 */
    const file$i = "node_modules\\sveltestrap\\src\\Nav.svelte";

    function create_fragment$j(ctx) {
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let ul_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let ul_data = {};

    	for (let i = 0; i < ul_levels.length; i += 1) {
    		ul_data = assign(ul_data, ul_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			set_attributes(ul, ul_data);
    			add_location(ul, file$i, 39, 0, 941);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			}

    			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getVerticalClass(vertical) {
    	if (vertical === false) {
    		return false;
    	} else if (vertical === true || vertical === "xs") {
    		return "flex-column";
    	}

    	return `flex-${vertical}-column`;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","tabs","pills","vertical","horizontal","justified","fill","navbar","card"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Nav", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { tabs = false } = $$props;
    	let { pills = false } = $$props;
    	let { vertical = false } = $$props;
    	let { horizontal = "" } = $$props;
    	let { justified = false } = $$props;
    	let { fill = false } = $$props;
    	let { navbar = false } = $$props;
    	let { card = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("tabs" in $$new_props) $$invalidate(3, tabs = $$new_props.tabs);
    		if ("pills" in $$new_props) $$invalidate(4, pills = $$new_props.pills);
    		if ("vertical" in $$new_props) $$invalidate(5, vertical = $$new_props.vertical);
    		if ("horizontal" in $$new_props) $$invalidate(6, horizontal = $$new_props.horizontal);
    		if ("justified" in $$new_props) $$invalidate(7, justified = $$new_props.justified);
    		if ("fill" in $$new_props) $$invalidate(8, fill = $$new_props.fill);
    		if ("navbar" in $$new_props) $$invalidate(9, navbar = $$new_props.navbar);
    		if ("card" in $$new_props) $$invalidate(10, card = $$new_props.card);
    		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		tabs,
    		pills,
    		vertical,
    		horizontal,
    		justified,
    		fill,
    		navbar,
    		card,
    		getVerticalClass,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("tabs" in $$props) $$invalidate(3, tabs = $$new_props.tabs);
    		if ("pills" in $$props) $$invalidate(4, pills = $$new_props.pills);
    		if ("vertical" in $$props) $$invalidate(5, vertical = $$new_props.vertical);
    		if ("horizontal" in $$props) $$invalidate(6, horizontal = $$new_props.horizontal);
    		if ("justified" in $$props) $$invalidate(7, justified = $$new_props.justified);
    		if ("fill" in $$props) $$invalidate(8, fill = $$new_props.fill);
    		if ("navbar" in $$props) $$invalidate(9, navbar = $$new_props.navbar);
    		if ("card" in $$props) $$invalidate(10, card = $$new_props.card);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, navbar, horizontal, vertical, tabs, card, pills, justified, fill*/ 2044) {
    			 $$invalidate(0, classes = classnames(className, navbar ? "navbar-nav" : "nav", horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
    				"nav-tabs": tabs,
    				"card-header-tabs": card && tabs,
    				"nav-pills": pills,
    				"card-header-pills": card && pills,
    				"nav-justified": justified,
    				"nav-fill": fill
    			}));
    		}
    	};

    	return [
    		classes,
    		$$restProps,
    		className,
    		tabs,
    		pills,
    		vertical,
    		horizontal,
    		justified,
    		fill,
    		navbar,
    		card,
    		$$scope,
    		slots
    	];
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			class: 2,
    			tabs: 3,
    			pills: 4,
    			vertical: 5,
    			horizontal: 6,
    			justified: 7,
    			fill: 8,
    			navbar: 9,
    			card: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pills() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pills(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get horizontal() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horizontal(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get justified() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set justified(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navbar() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navbar(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Navbar.svelte generated by Svelte v3.32.1 */
    const file$j = "node_modules\\sveltestrap\\src\\Navbar.svelte";

    function create_fragment$k(ctx) {
    	let nav;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	let nav_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let nav_data = {};

    	for (let i = 0; i < nav_levels.length; i += 1) {
    		nav_data = assign(nav_data, nav_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			if (default_slot) default_slot.c();
    			set_attributes(nav, nav_data);
    			add_location(nav, file$j, 31, 0, 719);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);

    			if (default_slot) {
    				default_slot.m(nav, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 512) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
    				}
    			}

    			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getExpandClass(expand) {
    	if (expand === false) {
    		return false;
    	} else if (expand === true || expand === "xs") {
    		return "navbar-expand";
    	}

    	return `navbar-expand-${expand}`;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","light","dark","fixed","sticky","color","expand"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Navbar", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { light = false } = $$props;
    	let { dark = false } = $$props;
    	let { fixed = "" } = $$props;
    	let { sticky = "" } = $$props;
    	let { color = "" } = $$props;
    	let { expand =  "" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("light" in $$new_props) $$invalidate(3, light = $$new_props.light);
    		if ("dark" in $$new_props) $$invalidate(4, dark = $$new_props.dark);
    		if ("fixed" in $$new_props) $$invalidate(5, fixed = $$new_props.fixed);
    		if ("sticky" in $$new_props) $$invalidate(6, sticky = $$new_props.sticky);
    		if ("color" in $$new_props) $$invalidate(7, color = $$new_props.color);
    		if ("expand" in $$new_props) $$invalidate(8, expand = $$new_props.expand);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		light,
    		dark,
    		fixed,
    		sticky,
    		color,
    		expand,
    		getExpandClass,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("light" in $$props) $$invalidate(3, light = $$new_props.light);
    		if ("dark" in $$props) $$invalidate(4, dark = $$new_props.dark);
    		if ("fixed" in $$props) $$invalidate(5, fixed = $$new_props.fixed);
    		if ("sticky" in $$props) $$invalidate(6, sticky = $$new_props.sticky);
    		if ("color" in $$props) $$invalidate(7, color = $$new_props.color);
    		if ("expand" in $$props) $$invalidate(8, expand = $$new_props.expand);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, expand, light, dark, color, fixed, sticky*/ 508) {
    			 $$invalidate(0, classes = classnames(className, "navbar", getExpandClass(expand), {
    				"navbar-light": light,
    				"navbar-dark": dark,
    				[`bg-${color}`]: color,
    				[`fixed-${fixed}`]: fixed,
    				[`sticky-${sticky}`]: sticky
    			}));
    		}
    	};

    	return [
    		classes,
    		$$restProps,
    		className,
    		light,
    		dark,
    		fixed,
    		sticky,
    		color,
    		expand,
    		$$scope,
    		slots
    	];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			class: 2,
    			light: 3,
    			dark: 4,
    			fixed: 5,
    			sticky: 6,
    			color: 7,
    			expand: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get class() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixed() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixed(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sticky() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sticky(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\NavItem.svelte generated by Svelte v3.32.1 */
    const file$k = "node_modules\\sveltestrap\\src\\NavItem.svelte";

    function create_fragment$l(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$k, 10, 0, 219);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","active"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavItem", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { active = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("active" in $$new_props) $$invalidate(3, active = $$new_props.active);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, active, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("active" in $$props) $$invalidate(3, active = $$new_props.active);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, active*/ 12) {
    			 $$invalidate(0, classes = classnames(className, "nav-item", active ? "active" : false));
    		}
    	};

    	return [classes, $$restProps, className, active, $$scope, slots];
    }

    class NavItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { class: 2, active: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavItem",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get class() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\NavbarBrand.svelte generated by Svelte v3.32.1 */
    const file$l = "node_modules\\sveltestrap\\src\\NavbarBrand.svelte";

    function create_fragment$m(ctx) {
    	let a;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[2],
    		{ class: /*classes*/ ctx[1] },
    		{ href: /*href*/ ctx[0] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$l, 10, 0, 192);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavbarBrand", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { href = "/" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, href, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
    		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 8) {
    			 $$invalidate(1, classes = classnames(className, "navbar-brand"));
    		}
    	};

    	return [href, classes, $$restProps, className, $$scope, slots];
    }

    class NavbarBrand extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { class: 3, href: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarBrand",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get class() {
    		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\NavbarToggler.svelte generated by Svelte v3.32.1 */
    const file$m = "node_modules\\sveltestrap\\src\\NavbarToggler.svelte";

    // (13:8)      
    function fallback_block$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "navbar-toggler-icon");
    			add_location(span, file$m, 13, 4, 274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(13:8)      ",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Button {...$$restProps} on:click class={classes}>
    function create_default_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(12:0) <Button {...$$restProps} on:click class={classes}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let button;
    	let current;
    	const button_spread_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];

    	let button_props = {
    		$$slots: { default: [create_default_slot$1] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < button_spread_levels.length; i += 1) {
    		button_props = assign(button_props, button_spread_levels[i]);
    	}

    	button = new Button({ props: button_props, $$inline: true });
    	button.$on("click", /*click_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = (dirty & /*$$restProps, classes*/ 3)
    			? get_spread_update(button_spread_levels, [
    					dirty & /*$$restProps*/ 2 && get_spread_object(/*$$restProps*/ ctx[1]),
    					dirty & /*classes*/ 1 && { class: /*classes*/ ctx[0] }
    				])
    			: {};

    			if (dirty & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavbarToggler", slots, ['default']);
    	let { class: className = "" } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, Button, className, classes });

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 4) {
    			 $$invalidate(0, classes = classnames(className, "navbar-toggler"));
    		}
    	};

    	return [classes, $$restProps, className, slots, click_handler, $$scope];
    }

    class NavbarToggler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarToggler",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get class() {
    		throw new Error("<NavbarToggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavbarToggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Pagination.svelte generated by Svelte v3.32.1 */
    const file$n = "node_modules\\sveltestrap\\src\\Pagination.svelte";

    function create_fragment$o(ctx) {
    	let nav;
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	let nav_levels = [
    		/*$$restProps*/ ctx[3],
    		{ class: /*classes*/ ctx[1] },
    		{ "aria-label": /*ariaLabel*/ ctx[0] }
    	];

    	let nav_data = {};

    	for (let i = 0; i < nav_levels.length; i += 1) {
    		nav_data = assign(nav_data, nav_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "class", /*listClasses*/ ctx[2]);
    			add_location(ul, file$n, 17, 2, 414);
    			set_attributes(nav, nav_data);
    			add_location(nav, file$n, 16, 0, 350);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*listClasses*/ 4) {
    				attr_dev(ul, "class", /*listClasses*/ ctx[2]);
    			}

    			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*ariaLabel*/ 1) && { "aria-label": /*ariaLabel*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let classes;
    	let listClasses;
    	const omit_props_names = ["class","listClassName","size","ariaLabel"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Pagination", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { listClassName = "" } = $$props;
    	let { size = "" } = $$props;
    	let { ariaLabel = "pagination" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ("listClassName" in $$new_props) $$invalidate(5, listClassName = $$new_props.listClassName);
    		if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
    		if ("ariaLabel" in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		listClassName,
    		size,
    		ariaLabel,
    		classes,
    		listClasses
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
    		if ("listClassName" in $$props) $$invalidate(5, listClassName = $$new_props.listClassName);
    		if ("size" in $$props) $$invalidate(6, size = $$new_props.size);
    		if ("ariaLabel" in $$props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ("listClasses" in $$props) $$invalidate(2, listClasses = $$new_props.listClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 16) {
    			 $$invalidate(1, classes = classnames(className));
    		}

    		if ($$self.$$.dirty & /*listClassName, size*/ 96) {
    			 $$invalidate(2, listClasses = classnames(listClassName, "pagination", { [`pagination-${size}`]: !!size }));
    		}
    	};

    	return [
    		ariaLabel,
    		classes,
    		listClasses,
    		$$restProps,
    		className,
    		listClassName,
    		size,
    		$$scope,
    		slots
    	];
    }

    class Pagination extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			class: 4,
    			listClassName: 5,
    			size: 6,
    			ariaLabel: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pagination",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get class() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listClassName() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listClassName(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaLabel() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\PaginationItem.svelte generated by Svelte v3.32.1 */
    const file$o = "node_modules\\sveltestrap\\src\\PaginationItem.svelte";

    function create_fragment$p(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$o, 14, 0, 256);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","active","disabled"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PaginationItem", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { active = false } = $$props;
    	let { disabled = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("active" in $$new_props) $$invalidate(3, active = $$new_props.active);
    		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
    		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		active,
    		disabled,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("active" in $$props) $$invalidate(3, active = $$new_props.active);
    		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, active, disabled*/ 28) {
    			 $$invalidate(0, classes = classnames(className, "page-item", { active, disabled }));
    		}
    	};

    	return [classes, $$restProps, className, active, disabled, $$scope, slots];
    }

    class PaginationItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { class: 2, active: 3, disabled: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaginationItem",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get class() {
    		throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\PaginationLink.svelte generated by Svelte v3.32.1 */
    const file$p = "node_modules\\sveltestrap\\src\\PaginationLink.svelte";

    // (47:2) {:else}
    function create_else_block$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(47:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:2) {#if previous || next || first || last}
    function create_if_block$9(ctx) {
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
    	const default_slot_or_fallback = default_slot || fallback_block$3(ctx);

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t0 = space();
    			span1 = element("span");
    			t1 = text(/*realLabel*/ ctx[7]);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$p, 42, 4, 948);
    			attr_dev(span1, "class", "sr-only");
    			add_location(span1, file$p, 45, 4, 1024);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span0, null);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*defaultCaret*/ 32) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*realLabel*/ 128) set_data_dev(t1, /*realLabel*/ ctx[7]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(42:2) {#if previous || next || first || last}",
    		ctx
    	});

    	return block;
    }

    // (44:12) {defaultCaret}
    function fallback_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*defaultCaret*/ ctx[5]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*defaultCaret*/ 32) set_data_dev(t, /*defaultCaret*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$3.name,
    		type: "fallback",
    		source: "(44:12) {defaultCaret}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$9, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*previous*/ ctx[1] || /*next*/ ctx[0] || /*first*/ ctx[2] || /*last*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[8],
    		{ class: /*classes*/ ctx[6] },
    		{ href: /*href*/ ctx[4] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$p, 40, 0, 849);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[14], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
    				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
    				(!current || dirty & /*href*/ 16) && { href: /*href*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let classes;
    	let realLabel;
    	const omit_props_names = ["class","next","previous","first","last","ariaLabel","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PaginationLink", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { next = false } = $$props;
    	let { previous = false } = $$props;
    	let { first = false } = $$props;
    	let { last = false } = $$props;
    	let { ariaLabel = "" } = $$props;
    	let { href = "" } = $$props;
    	let defaultAriaLabel;
    	let defaultCaret;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
    		if ("next" in $$new_props) $$invalidate(0, next = $$new_props.next);
    		if ("previous" in $$new_props) $$invalidate(1, previous = $$new_props.previous);
    		if ("first" in $$new_props) $$invalidate(2, first = $$new_props.first);
    		if ("last" in $$new_props) $$invalidate(3, last = $$new_props.last);
    		if ("ariaLabel" in $$new_props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    		if ("href" in $$new_props) $$invalidate(4, href = $$new_props.href);
    		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		next,
    		previous,
    		first,
    		last,
    		ariaLabel,
    		href,
    		defaultAriaLabel,
    		defaultCaret,
    		classes,
    		realLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
    		if ("next" in $$props) $$invalidate(0, next = $$new_props.next);
    		if ("previous" in $$props) $$invalidate(1, previous = $$new_props.previous);
    		if ("first" in $$props) $$invalidate(2, first = $$new_props.first);
    		if ("last" in $$props) $$invalidate(3, last = $$new_props.last);
    		if ("ariaLabel" in $$props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    		if ("href" in $$props) $$invalidate(4, href = $$new_props.href);
    		if ("defaultAriaLabel" in $$props) $$invalidate(11, defaultAriaLabel = $$new_props.defaultAriaLabel);
    		if ("defaultCaret" in $$props) $$invalidate(5, defaultCaret = $$new_props.defaultCaret);
    		if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
    		if ("realLabel" in $$props) $$invalidate(7, realLabel = $$new_props.realLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 512) {
    			 $$invalidate(6, classes = classnames(className, "page-link"));
    		}

    		if ($$self.$$.dirty & /*previous, next, first, last*/ 15) {
    			 if (previous) {
    				$$invalidate(11, defaultAriaLabel = "Previous");
    			} else if (next) {
    				$$invalidate(11, defaultAriaLabel = "Next");
    			} else if (first) {
    				$$invalidate(11, defaultAriaLabel = "First");
    			} else if (last) {
    				$$invalidate(11, defaultAriaLabel = "Last");
    			}
    		}

    		if ($$self.$$.dirty & /*ariaLabel, defaultAriaLabel*/ 3072) {
    			 $$invalidate(7, realLabel = ariaLabel || defaultAriaLabel);
    		}

    		if ($$self.$$.dirty & /*previous, next, first, last*/ 15) {
    			 if (previous) {
    				$$invalidate(5, defaultCaret = "‹");
    			} else if (next) {
    				$$invalidate(5, defaultCaret = "›");
    			} else if (first) {
    				$$invalidate(5, defaultCaret = "«");
    			} else if (last) {
    				$$invalidate(5, defaultCaret = "»");
    			}
    		}
    	};

    	return [
    		next,
    		previous,
    		first,
    		last,
    		href,
    		defaultCaret,
    		classes,
    		realLabel,
    		$$restProps,
    		className,
    		ariaLabel,
    		defaultAriaLabel,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class PaginationLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			class: 9,
    			next: 0,
    			previous: 1,
    			first: 2,
    			last: 3,
    			ariaLabel: 10,
    			href: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaginationLink",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get class() {
    		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get next() {
    		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set next(value) {
    		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get previous() {
    		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set previous(value) {
    		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get first() {
    		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set first(value) {
    		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get last() {
    		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set last(value) {
    		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaLabel() {
    		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$1() {}

    var on = noop$1;
    var addListener = noop$1;
    var once = noop$1;
    var off = noop$1;
    var removeListener = noop$1;
    var removeAllListeners = noop$1;
    var emit = noop$1;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    /* node_modules\sveltestrap\src\Row.svelte generated by Svelte v3.32.1 */
    const file$q = "node_modules\\sveltestrap\\src\\Row.svelte";

    function create_fragment$r(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$q, 38, 0, 957);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getCols(cols) {
    	const colsValue = parseInt(cols);

    	if (!isNaN(colsValue)) {
    		if (colsValue > 0) {
    			return [`row-cols-${colsValue}`];
    		}
    	} else if (typeof cols === "object") {
    		return ["xs", "sm", "md", "lg", "xl"].map(colWidth => {
    			const isXs = colWidth === "xs";
    			const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
    			const value = cols[colWidth];

    			if (typeof value === "number" && value > 0) {
    				return `row-cols${colSizeInterfix}${value}`;
    			}

    			return null;
    		}).filter(value => !!value);
    	}

    	return [];
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","noGutters","form","cols"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Row", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { noGutters = false } = $$props;
    	let { form = false } = $$props;
    	let { cols = 0 } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("noGutters" in $$new_props) $$invalidate(3, noGutters = $$new_props.noGutters);
    		if ("form" in $$new_props) $$invalidate(4, form = $$new_props.form);
    		if ("cols" in $$new_props) $$invalidate(5, cols = $$new_props.cols);
    		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		noGutters,
    		form,
    		cols,
    		getCols,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("noGutters" in $$props) $$invalidate(3, noGutters = $$new_props.noGutters);
    		if ("form" in $$props) $$invalidate(4, form = $$new_props.form);
    		if ("cols" in $$props) $$invalidate(5, cols = $$new_props.cols);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, noGutters, form, cols*/ 60) {
    			 $$invalidate(0, classes = classnames(className, noGutters ? "no-gutters" : null, form ? "form-row" : "row", ...getCols(cols)));
    		}
    	};

    	return [classes, $$restProps, className, noGutters, form, cols, $$scope, slots];
    }

    class Row extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { class: 2, noGutters: 3, form: 4, cols: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Row",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get class() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noGutters() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noGutters(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get form() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cols() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cols(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Spinner.svelte generated by Svelte v3.32.1 */
    const file$r = "node_modules\\sveltestrap\\src\\Spinner.svelte";

    // (20:10) Loading...
    function fallback_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$4.name,
    		type: "fallback",
    		source: "(20:10) Loading...",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div;
    	let span;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	const default_slot_or_fallback = default_slot || fallback_block$4(ctx);
    	let div_levels = [/*$$restProps*/ ctx[1], { role: "status" }, { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$r, 18, 2, 399);
    			set_attributes(div, div_data);
    			add_location(div, file$r, 17, 0, 344);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				{ role: "status" },
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","type","size","color"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spinner", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { type = "border" } = $$props;
    	let { size = "" } = $$props;
    	let { color = "" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
    		if ("size" in $$new_props) $$invalidate(4, size = $$new_props.size);
    		if ("color" in $$new_props) $$invalidate(5, color = $$new_props.color);
    		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		type,
    		size,
    		color,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
    		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
    		if ("size" in $$props) $$invalidate(4, size = $$new_props.size);
    		if ("color" in $$props) $$invalidate(5, color = $$new_props.color);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, size, type, color*/ 60) {
    			 $$invalidate(0, classes = classnames(className, size ? `spinner-${type}-${size}` : false, `spinner-${type}`, color ? `text-${color}` : false));
    		}
    	};

    	return [classes, $$restProps, className, type, size, color, $$scope, slots];
    }

    class Spinner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { class: 2, type: 3, size: 4, color: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get class() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Table.svelte generated by Svelte v3.32.1 */
    const file$s = "node_modules\\sveltestrap\\src\\Table.svelte";

    // (35:0) {:else}
    function create_else_block$9(ctx) {
    	let table;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let table_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[1] }];
    	let table_data = {};

    	for (let i = 0; i < table_levels.length; i += 1) {
    		table_data = assign(table_data, table_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			if (default_slot) default_slot.c();
    			set_attributes(table, table_data);
    			add_location(table, file$s, 35, 2, 861);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);

    			if (default_slot) {
    				default_slot.m(table, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			}

    			set_attributes(table, table_data = get_spread_update(table_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(35:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (29:0) {#if responsive}
    function create_if_block$a(ctx) {
    	let div;
    	let table;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let table_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[1] }];
    	let table_data = {};

    	for (let i = 0; i < table_levels.length; i += 1) {
    		table_data = assign(table_data, table_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			table = element("table");
    			if (default_slot) default_slot.c();
    			set_attributes(table, table_data);
    			add_location(table, file$s, 30, 4, 773);
    			attr_dev(div, "class", /*responsiveClassName*/ ctx[2]);
    			add_location(div, file$s, 29, 2, 735);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, table);

    			if (default_slot) {
    				default_slot.m(table, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			}

    			set_attributes(table, table_data = get_spread_update(table_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));

    			if (!current || dirty & /*responsiveClassName*/ 4) {
    				attr_dev(div, "class", /*responsiveClassName*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(29:0) {#if responsive}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*responsive*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let classes;
    	let responsiveClassName;
    	const omit_props_names = ["class","size","bordered","borderless","striped","dark","hover","responsive"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Table", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { size = "" } = $$props;
    	let { bordered = false } = $$props;
    	let { borderless = false } = $$props;
    	let { striped = false } = $$props;
    	let { dark = false } = $$props;
    	let { hover = false } = $$props;
    	let { responsive = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ("size" in $$new_props) $$invalidate(5, size = $$new_props.size);
    		if ("bordered" in $$new_props) $$invalidate(6, bordered = $$new_props.bordered);
    		if ("borderless" in $$new_props) $$invalidate(7, borderless = $$new_props.borderless);
    		if ("striped" in $$new_props) $$invalidate(8, striped = $$new_props.striped);
    		if ("dark" in $$new_props) $$invalidate(9, dark = $$new_props.dark);
    		if ("hover" in $$new_props) $$invalidate(10, hover = $$new_props.hover);
    		if ("responsive" in $$new_props) $$invalidate(0, responsive = $$new_props.responsive);
    		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		size,
    		bordered,
    		borderless,
    		striped,
    		dark,
    		hover,
    		responsive,
    		classes,
    		responsiveClassName
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
    		if ("size" in $$props) $$invalidate(5, size = $$new_props.size);
    		if ("bordered" in $$props) $$invalidate(6, bordered = $$new_props.bordered);
    		if ("borderless" in $$props) $$invalidate(7, borderless = $$new_props.borderless);
    		if ("striped" in $$props) $$invalidate(8, striped = $$new_props.striped);
    		if ("dark" in $$props) $$invalidate(9, dark = $$new_props.dark);
    		if ("hover" in $$props) $$invalidate(10, hover = $$new_props.hover);
    		if ("responsive" in $$props) $$invalidate(0, responsive = $$new_props.responsive);
    		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ("responsiveClassName" in $$props) $$invalidate(2, responsiveClassName = $$new_props.responsiveClassName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, size, bordered, borderless, striped, dark, hover*/ 2032) {
    			 $$invalidate(1, classes = classnames(className, "table", size ? "table-" + size : false, bordered ? "table-bordered" : false, borderless ? "table-borderless" : false, striped ? "table-striped" : false, dark ? "table-dark" : false, hover ? "table-hover" : false));
    		}

    		if ($$self.$$.dirty & /*responsive*/ 1) {
    			 $$invalidate(2, responsiveClassName = responsive === true
    			? "table-responsive"
    			: `table-responsive-${responsive}`);
    		}
    	};

    	return [
    		responsive,
    		classes,
    		responsiveClassName,
    		$$restProps,
    		className,
    		size,
    		bordered,
    		borderless,
    		striped,
    		dark,
    		hover,
    		$$scope,
    		slots
    	];
    }

    class Table extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			class: 4,
    			size: 5,
    			bordered: 6,
    			borderless: 7,
    			striped: 8,
    			dark: 9,
    			hover: 10,
    			responsive: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get class() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bordered() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bordered(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get borderless() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set borderless(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get striped() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set striped(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hover() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hover(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get responsive() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set responsive(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\UncontrolledDropdown.svelte generated by Svelte v3.32.1 */

    // (21:0) <Dropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {disabled}   {direction}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>
    function create_default_slot$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(21:0) <Dropdown   {...$$restProps}   {isOpen}   toggle={() => (isOpen = !isOpen)}   class={className}   {disabled}   {direction}   {group}   {nav}   {active}   {addonType}   {size}   {inNavbar}   {setActiveFromChild}   {dropup}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let dropdown;
    	let current;

    	const dropdown_spread_levels = [
    		/*$$restProps*/ ctx[12],
    		{ isOpen: /*isOpen*/ ctx[11] },
    		{ toggle: /*func*/ ctx[15] },
    		{ class: /*className*/ ctx[0] },
    		{ disabled: /*disabled*/ ctx[1] },
    		{ direction: /*direction*/ ctx[2] },
    		{ group: /*group*/ ctx[3] },
    		{ nav: /*nav*/ ctx[4] },
    		{ active: /*active*/ ctx[5] },
    		{ addonType: /*addonType*/ ctx[6] },
    		{ size: /*size*/ ctx[7] },
    		{ inNavbar: /*inNavbar*/ ctx[8] },
    		{
    			setActiveFromChild: /*setActiveFromChild*/ ctx[9]
    		},
    		{ dropup: /*dropup*/ ctx[10] }
    	];

    	let dropdown_props = {
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
    		dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
    	}

    	dropdown = new Dropdown({ props: dropdown_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dropdown.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dropdown_changes = (dirty & /*$$restProps, isOpen, className, disabled, direction, group, nav, active, addonType, size, inNavbar, setActiveFromChild, dropup*/ 8191)
    			? get_spread_update(dropdown_spread_levels, [
    					dirty & /*$$restProps*/ 4096 && get_spread_object(/*$$restProps*/ ctx[12]),
    					dirty & /*isOpen*/ 2048 && { isOpen: /*isOpen*/ ctx[11] },
    					dirty & /*isOpen*/ 2048 && { toggle: /*func*/ ctx[15] },
    					dirty & /*className*/ 1 && { class: /*className*/ ctx[0] },
    					dirty & /*disabled*/ 2 && { disabled: /*disabled*/ ctx[1] },
    					dirty & /*direction*/ 4 && { direction: /*direction*/ ctx[2] },
    					dirty & /*group*/ 8 && { group: /*group*/ ctx[3] },
    					dirty & /*nav*/ 16 && { nav: /*nav*/ ctx[4] },
    					dirty & /*active*/ 32 && { active: /*active*/ ctx[5] },
    					dirty & /*addonType*/ 64 && { addonType: /*addonType*/ ctx[6] },
    					dirty & /*size*/ 128 && { size: /*size*/ ctx[7] },
    					dirty & /*inNavbar*/ 256 && { inNavbar: /*inNavbar*/ ctx[8] },
    					dirty & /*setActiveFromChild*/ 512 && {
    						setActiveFromChild: /*setActiveFromChild*/ ctx[9]
    					},
    					dirty & /*dropup*/ 1024 && { dropup: /*dropup*/ ctx[10] }
    				])
    			: {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"class","disabled","direction","group","nav","active","addonType","size","inNavbar","setActiveFromChild","dropup","defaultOpen"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UncontrolledDropdown", slots, ['default']);
    	let { class: className = "" } = $$props;
    	let { disabled = false } = $$props;
    	let { direction = "down" } = $$props;
    	let { group = false } = $$props;
    	let { nav = false } = $$props;
    	let { active = false } = $$props;
    	let { addonType = false } = $$props;
    	let { size = "" } = $$props;
    	let { inNavbar = false } = $$props;
    	let { setActiveFromChild = false } = $$props;
    	let { dropup = false } = $$props;
    	let { defaultOpen = false } = $$props;
    	let isOpen = defaultOpen;
    	const func = () => $$invalidate(11, isOpen = !isOpen);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
    		if ("direction" in $$new_props) $$invalidate(2, direction = $$new_props.direction);
    		if ("group" in $$new_props) $$invalidate(3, group = $$new_props.group);
    		if ("nav" in $$new_props) $$invalidate(4, nav = $$new_props.nav);
    		if ("active" in $$new_props) $$invalidate(5, active = $$new_props.active);
    		if ("addonType" in $$new_props) $$invalidate(6, addonType = $$new_props.addonType);
    		if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
    		if ("inNavbar" in $$new_props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
    		if ("setActiveFromChild" in $$new_props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ("dropup" in $$new_props) $$invalidate(10, dropup = $$new_props.dropup);
    		if ("defaultOpen" in $$new_props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
    		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Dropdown,
    		className,
    		disabled,
    		direction,
    		group,
    		nav,
    		active,
    		addonType,
    		size,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		defaultOpen,
    		isOpen
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("disabled" in $$props) $$invalidate(1, disabled = $$new_props.disabled);
    		if ("direction" in $$props) $$invalidate(2, direction = $$new_props.direction);
    		if ("group" in $$props) $$invalidate(3, group = $$new_props.group);
    		if ("nav" in $$props) $$invalidate(4, nav = $$new_props.nav);
    		if ("active" in $$props) $$invalidate(5, active = $$new_props.active);
    		if ("addonType" in $$props) $$invalidate(6, addonType = $$new_props.addonType);
    		if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
    		if ("inNavbar" in $$props) $$invalidate(8, inNavbar = $$new_props.inNavbar);
    		if ("setActiveFromChild" in $$props) $$invalidate(9, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ("dropup" in $$props) $$invalidate(10, dropup = $$new_props.dropup);
    		if ("defaultOpen" in $$props) $$invalidate(13, defaultOpen = $$new_props.defaultOpen);
    		if ("isOpen" in $$props) $$invalidate(11, isOpen = $$new_props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		className,
    		disabled,
    		direction,
    		group,
    		nav,
    		active,
    		addonType,
    		size,
    		inNavbar,
    		setActiveFromChild,
    		dropup,
    		isOpen,
    		$$restProps,
    		defaultOpen,
    		slots,
    		func,
    		$$scope
    	];
    }

    class UncontrolledDropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
    			class: 0,
    			disabled: 1,
    			direction: 2,
    			group: 3,
    			nav: 4,
    			active: 5,
    			addonType: 6,
    			size: 7,
    			inNavbar: 8,
    			setActiveFromChild: 9,
    			dropup: 10,
    			defaultOpen: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UncontrolledDropdown",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get class() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addonType() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addonType(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inNavbar() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inNavbar(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setActiveFromChild() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setActiveFromChild(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropup() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropup(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultOpen() {
    		throw new Error("<UncontrolledDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultOpen(value) {
    		throw new Error("<UncontrolledDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var browser$1 = true;

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    		path: basedir,
    		exports: {},
    		require: function (path, base) {
    			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    		}
    	}, fn(module, module.exports), module.exports;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var test = function () {
      return typeof commonjsGlobal.queueMicrotask === 'function';
    };

    var install = function (func) {
      return function () {
        commonjsGlobal.queueMicrotask(func);
      };
    };

    var queueMicrotask = {
    	test: test,
    	install: install
    };

    //based off rsvp https://github.com/tildeio/rsvp.js
    //license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
    //https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

    var Mutation = commonjsGlobal.MutationObserver || commonjsGlobal.WebKitMutationObserver;

    var test$1 = function () {
      return Mutation;
    };

    var install$1 = function (handle) {
      var called = 0;
      var observer = new Mutation(handle);
      var element = commonjsGlobal.document.createTextNode('');
      observer.observe(element, {
        characterData: true
      });
      return function () {
        element.data = (called = ++called % 2);
      };
    };

    var mutation = {
    	test: test$1,
    	install: install$1
    };

    var test$2 = function () {
      if (commonjsGlobal.setImmediate) {
        // we can only get here in IE10
        // which doesn't handel postMessage well
        return false;
      }
      return typeof commonjsGlobal.MessageChannel !== 'undefined';
    };

    var install$2 = function (func) {
      var channel = new commonjsGlobal.MessageChannel();
      channel.port1.onmessage = func;
      return function () {
        channel.port2.postMessage(0);
      };
    };

    var messageChannel = {
    	test: test$2,
    	install: install$2
    };

    var test$3 = function () {
      return 'document' in commonjsGlobal && 'onreadystatechange' in commonjsGlobal.document.createElement('script');
    };

    var install$3 = function (handle) {
      return function () {

        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
        var scriptEl = commonjsGlobal.document.createElement('script');
        scriptEl.onreadystatechange = function () {
          handle();

          scriptEl.onreadystatechange = null;
          scriptEl.parentNode.removeChild(scriptEl);
          scriptEl = null;
        };
        commonjsGlobal.document.documentElement.appendChild(scriptEl);

        return handle;
      };
    };

    var stateChange = {
    	test: test$3,
    	install: install$3
    };

    var test$4 = function () {
      return true;
    };

    var install$4 = function (t) {
      return function () {
        setTimeout(t, 0);
      };
    };

    var timeout = {
    	test: test$4,
    	install: install$4
    };

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    var types = [
      require$$0,
      queueMicrotask,
      mutation,
      messageChannel,
      stateChange,
      timeout
    ];
    var draining$1;
    var currentQueue$1;
    var queueIndex$1 = -1;
    var queue$1 = [];
    var scheduled = false;
    function cleanUpNextTick$1() {
      if (!draining$1 || !currentQueue$1) {
        return;
      }
      draining$1 = false;
      if (currentQueue$1.length) {
        queue$1 = currentQueue$1.concat(queue$1);
      } else {
        queueIndex$1 = -1;
      }
      if (queue$1.length) {
        nextTick$1();
      }
    }

    //named nextTick for less confusing stack traces
    function nextTick$1() {
      if (draining$1) {
        return;
      }
      scheduled = false;
      draining$1 = true;
      var len = queue$1.length;
      var timeout = setTimeout(cleanUpNextTick$1);
      while (len) {
        currentQueue$1 = queue$1;
        queue$1 = [];
        while (currentQueue$1 && ++queueIndex$1 < len) {
          currentQueue$1[queueIndex$1].run();
        }
        queueIndex$1 = -1;
        len = queue$1.length;
      }
      currentQueue$1 = null;
      queueIndex$1 = -1;
      draining$1 = false;
      clearTimeout(timeout);
    }
    var scheduleDrain;
    var i = -1;
    var len = types.length;
    while (++i < len) {
      if (types[i] && types[i].test && types[i].test()) {
        scheduleDrain = types[i].install(nextTick$1);
        break;
      }
    }
    // v8 likes predictible objects
    function Item$1(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item$1.prototype.run = function () {
      var fun = this.fun;
      var array = this.array;
      switch (array.length) {
      case 0:
        return fun();
      case 1:
        return fun(array[0]);
      case 2:
        return fun(array[0], array[1]);
      case 3:
        return fun(array[0], array[1], array[2]);
      default:
        return fun.apply(null, array);
      }

    };
    var lib = immediate;
    function immediate(task) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue$1.push(new Item$1(task, args));
      if (!scheduled && !draining$1) {
        scheduled = true;
        scheduleDrain();
      }
    }

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    var getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }

      return getRandomValues(rnds8);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    var byteToHex = [];

    for (var i$1 = 0; i$1 < 256; ++i$1) {
      byteToHex.push((i$1 + 0x100).toString(16).substr(1));
    }

    function bytesToUuid(buf, offset) {
      var i = offset || 0;
      var bth = byteToHex; // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

      return (bth[buf[i + 0]] + bth[buf[i + 1]] + bth[buf[i + 2]] + bth[buf[i + 3]] + '-' + bth[buf[i + 4]] + bth[buf[i + 5]] + '-' + bth[buf[i + 6]] + bth[buf[i + 7]] + '-' + bth[buf[i + 8]] + bth[buf[i + 9]] + '-' + bth[buf[i + 10]] + bth[buf[i + 11]] + bth[buf[i + 12]] + bth[buf[i + 13]] + bth[buf[i + 14]] + bth[buf[i + 15]]).toLowerCase();
    }

    function v4(options, buf, offset) {
      if (typeof options === 'string') {
        buf = options === 'binary' ? new Uint8Array(16) : null;
        options = null;
      }

      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        var start = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[start + i] = rnds[i];
        }

        return buf;
      }

      return bytesToUuid(rnds);
    }

    var sparkMd5 = createCommonjsModule(function (module, exports) {
    (function (factory) {
        {
            // Node/CommonJS
            module.exports = factory();
        }
    }(function (undefined$1) {

        /*
         * Fastest md5 implementation around (JKM md5).
         * Credits: Joseph Myers
         *
         * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
         * @see http://jsperf.com/md5-shootout/7
         */

        /* this function is much faster,
          so if possible we use it. Some IEs
          are the only ones I know of that
          need the idiotic second function,
          generated by an if clause.  */
        var hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

        function md5cycle(x, k) {
            var a = x[0],
                b = x[1],
                c = x[2],
                d = x[3];

            a += (b & c | ~b & d) + k[0] - 680876936 | 0;
            a  = (a << 7 | a >>> 25) + b | 0;
            d += (a & b | ~a & c) + k[1] - 389564586 | 0;
            d  = (d << 12 | d >>> 20) + a | 0;
            c += (d & a | ~d & b) + k[2] + 606105819 | 0;
            c  = (c << 17 | c >>> 15) + d | 0;
            b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
            b  = (b << 22 | b >>> 10) + c | 0;
            a += (b & c | ~b & d) + k[4] - 176418897 | 0;
            a  = (a << 7 | a >>> 25) + b | 0;
            d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
            d  = (d << 12 | d >>> 20) + a | 0;
            c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
            c  = (c << 17 | c >>> 15) + d | 0;
            b += (c & d | ~c & a) + k[7] - 45705983 | 0;
            b  = (b << 22 | b >>> 10) + c | 0;
            a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
            a  = (a << 7 | a >>> 25) + b | 0;
            d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
            d  = (d << 12 | d >>> 20) + a | 0;
            c += (d & a | ~d & b) + k[10] - 42063 | 0;
            c  = (c << 17 | c >>> 15) + d | 0;
            b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
            b  = (b << 22 | b >>> 10) + c | 0;
            a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
            a  = (a << 7 | a >>> 25) + b | 0;
            d += (a & b | ~a & c) + k[13] - 40341101 | 0;
            d  = (d << 12 | d >>> 20) + a | 0;
            c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
            c  = (c << 17 | c >>> 15) + d | 0;
            b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
            b  = (b << 22 | b >>> 10) + c | 0;

            a += (b & d | c & ~d) + k[1] - 165796510 | 0;
            a  = (a << 5 | a >>> 27) + b | 0;
            d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
            d  = (d << 9 | d >>> 23) + a | 0;
            c += (d & b | a & ~b) + k[11] + 643717713 | 0;
            c  = (c << 14 | c >>> 18) + d | 0;
            b += (c & a | d & ~a) + k[0] - 373897302 | 0;
            b  = (b << 20 | b >>> 12) + c | 0;
            a += (b & d | c & ~d) + k[5] - 701558691 | 0;
            a  = (a << 5 | a >>> 27) + b | 0;
            d += (a & c | b & ~c) + k[10] + 38016083 | 0;
            d  = (d << 9 | d >>> 23) + a | 0;
            c += (d & b | a & ~b) + k[15] - 660478335 | 0;
            c  = (c << 14 | c >>> 18) + d | 0;
            b += (c & a | d & ~a) + k[4] - 405537848 | 0;
            b  = (b << 20 | b >>> 12) + c | 0;
            a += (b & d | c & ~d) + k[9] + 568446438 | 0;
            a  = (a << 5 | a >>> 27) + b | 0;
            d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
            d  = (d << 9 | d >>> 23) + a | 0;
            c += (d & b | a & ~b) + k[3] - 187363961 | 0;
            c  = (c << 14 | c >>> 18) + d | 0;
            b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
            b  = (b << 20 | b >>> 12) + c | 0;
            a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
            a  = (a << 5 | a >>> 27) + b | 0;
            d += (a & c | b & ~c) + k[2] - 51403784 | 0;
            d  = (d << 9 | d >>> 23) + a | 0;
            c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
            c  = (c << 14 | c >>> 18) + d | 0;
            b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
            b  = (b << 20 | b >>> 12) + c | 0;

            a += (b ^ c ^ d) + k[5] - 378558 | 0;
            a  = (a << 4 | a >>> 28) + b | 0;
            d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
            d  = (d << 11 | d >>> 21) + a | 0;
            c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
            c  = (c << 16 | c >>> 16) + d | 0;
            b += (c ^ d ^ a) + k[14] - 35309556 | 0;
            b  = (b << 23 | b >>> 9) + c | 0;
            a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
            a  = (a << 4 | a >>> 28) + b | 0;
            d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
            d  = (d << 11 | d >>> 21) + a | 0;
            c += (d ^ a ^ b) + k[7] - 155497632 | 0;
            c  = (c << 16 | c >>> 16) + d | 0;
            b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
            b  = (b << 23 | b >>> 9) + c | 0;
            a += (b ^ c ^ d) + k[13] + 681279174 | 0;
            a  = (a << 4 | a >>> 28) + b | 0;
            d += (a ^ b ^ c) + k[0] - 358537222 | 0;
            d  = (d << 11 | d >>> 21) + a | 0;
            c += (d ^ a ^ b) + k[3] - 722521979 | 0;
            c  = (c << 16 | c >>> 16) + d | 0;
            b += (c ^ d ^ a) + k[6] + 76029189 | 0;
            b  = (b << 23 | b >>> 9) + c | 0;
            a += (b ^ c ^ d) + k[9] - 640364487 | 0;
            a  = (a << 4 | a >>> 28) + b | 0;
            d += (a ^ b ^ c) + k[12] - 421815835 | 0;
            d  = (d << 11 | d >>> 21) + a | 0;
            c += (d ^ a ^ b) + k[15] + 530742520 | 0;
            c  = (c << 16 | c >>> 16) + d | 0;
            b += (c ^ d ^ a) + k[2] - 995338651 | 0;
            b  = (b << 23 | b >>> 9) + c | 0;

            a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
            a  = (a << 6 | a >>> 26) + b | 0;
            d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
            d  = (d << 10 | d >>> 22) + a | 0;
            c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
            c  = (c << 15 | c >>> 17) + d | 0;
            b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
            b  = (b << 21 |b >>> 11) + c | 0;
            a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
            a  = (a << 6 | a >>> 26) + b | 0;
            d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
            d  = (d << 10 | d >>> 22) + a | 0;
            c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
            c  = (c << 15 | c >>> 17) + d | 0;
            b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
            b  = (b << 21 |b >>> 11) + c | 0;
            a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
            a  = (a << 6 | a >>> 26) + b | 0;
            d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
            d  = (d << 10 | d >>> 22) + a | 0;
            c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
            c  = (c << 15 | c >>> 17) + d | 0;
            b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
            b  = (b << 21 |b >>> 11) + c | 0;
            a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
            a  = (a << 6 | a >>> 26) + b | 0;
            d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
            d  = (d << 10 | d >>> 22) + a | 0;
            c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
            c  = (c << 15 | c >>> 17) + d | 0;
            b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
            b  = (b << 21 | b >>> 11) + c | 0;

            x[0] = a + x[0] | 0;
            x[1] = b + x[1] | 0;
            x[2] = c + x[2] | 0;
            x[3] = d + x[3] | 0;
        }

        function md5blk(s) {
            var md5blks = [],
                i; /* Andy King said do it this way. */

            for (i = 0; i < 64; i += 4) {
                md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
            }
            return md5blks;
        }

        function md5blk_array(a) {
            var md5blks = [],
                i; /* Andy King said do it this way. */

            for (i = 0; i < 64; i += 4) {
                md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
            }
            return md5blks;
        }

        function md51(s) {
            var n = s.length,
                state = [1732584193, -271733879, -1732584194, 271733878],
                i,
                length,
                tail,
                tmp,
                lo,
                hi;

            for (i = 64; i <= n; i += 64) {
                md5cycle(state, md5blk(s.substring(i - 64, i)));
            }
            s = s.substring(i - 64);
            length = s.length;
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
            }
            tail[i >> 2] |= 0x80 << ((i % 4) << 3);
            if (i > 55) {
                md5cycle(state, tail);
                for (i = 0; i < 16; i += 1) {
                    tail[i] = 0;
                }
            }

            // Beware that the final length might not fit in 32 bits so we take care of that
            tmp = n * 8;
            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
            lo = parseInt(tmp[2], 16);
            hi = parseInt(tmp[1], 16) || 0;

            tail[14] = lo;
            tail[15] = hi;

            md5cycle(state, tail);
            return state;
        }

        function md51_array(a) {
            var n = a.length,
                state = [1732584193, -271733879, -1732584194, 271733878],
                i,
                length,
                tail,
                tmp,
                lo,
                hi;

            for (i = 64; i <= n; i += 64) {
                md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
            }

            // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
            // containing the last element of the parent array if the sub array specified starts
            // beyond the length of the parent array - weird.
            // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
            a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

            length = a.length;
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= a[i] << ((i % 4) << 3);
            }

            tail[i >> 2] |= 0x80 << ((i % 4) << 3);
            if (i > 55) {
                md5cycle(state, tail);
                for (i = 0; i < 16; i += 1) {
                    tail[i] = 0;
                }
            }

            // Beware that the final length might not fit in 32 bits so we take care of that
            tmp = n * 8;
            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
            lo = parseInt(tmp[2], 16);
            hi = parseInt(tmp[1], 16) || 0;

            tail[14] = lo;
            tail[15] = hi;

            md5cycle(state, tail);

            return state;
        }

        function rhex(n) {
            var s = '',
                j;
            for (j = 0; j < 4; j += 1) {
                s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
            }
            return s;
        }

        function hex(x) {
            var i;
            for (i = 0; i < x.length; i += 1) {
                x[i] = rhex(x[i]);
            }
            return x.join('');
        }

        // In some cases the fast add32 function cannot be used..
        if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') ;

        // ---------------------------------------------------

        /**
         * ArrayBuffer slice polyfill.
         *
         * @see https://github.com/ttaubert/node-arraybuffer-slice
         */

        if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
            (function () {
                function clamp(val, length) {
                    val = (val | 0) || 0;

                    if (val < 0) {
                        return Math.max(val + length, 0);
                    }

                    return Math.min(val, length);
                }

                ArrayBuffer.prototype.slice = function (from, to) {
                    var length = this.byteLength,
                        begin = clamp(from, length),
                        end = length,
                        num,
                        target,
                        targetArray,
                        sourceArray;

                    if (to !== undefined$1) {
                        end = clamp(to, length);
                    }

                    if (begin > end) {
                        return new ArrayBuffer(0);
                    }

                    num = end - begin;
                    target = new ArrayBuffer(num);
                    targetArray = new Uint8Array(target);

                    sourceArray = new Uint8Array(this, begin, num);
                    targetArray.set(sourceArray);

                    return target;
                };
            })();
        }

        // ---------------------------------------------------

        /**
         * Helpers.
         */

        function toUtf8(str) {
            if (/[\u0080-\uFFFF]/.test(str)) {
                str = unescape(encodeURIComponent(str));
            }

            return str;
        }

        function utf8Str2ArrayBuffer(str, returnUInt8Array) {
            var length = str.length,
               buff = new ArrayBuffer(length),
               arr = new Uint8Array(buff),
               i;

            for (i = 0; i < length; i += 1) {
                arr[i] = str.charCodeAt(i);
            }

            return returnUInt8Array ? arr : buff;
        }

        function arrayBuffer2Utf8Str(buff) {
            return String.fromCharCode.apply(null, new Uint8Array(buff));
        }

        function concatenateArrayBuffers(first, second, returnUInt8Array) {
            var result = new Uint8Array(first.byteLength + second.byteLength);

            result.set(new Uint8Array(first));
            result.set(new Uint8Array(second), first.byteLength);

            return returnUInt8Array ? result : result.buffer;
        }

        function hexToBinaryString(hex) {
            var bytes = [],
                length = hex.length,
                x;

            for (x = 0; x < length - 1; x += 2) {
                bytes.push(parseInt(hex.substr(x, 2), 16));
            }

            return String.fromCharCode.apply(String, bytes);
        }

        // ---------------------------------------------------

        /**
         * SparkMD5 OOP implementation.
         *
         * Use this class to perform an incremental md5, otherwise use the
         * static methods instead.
         */

        function SparkMD5() {
            // call reset to init the instance
            this.reset();
        }

        /**
         * Appends a string.
         * A conversion will be applied if an utf8 string is detected.
         *
         * @param {String} str The string to be appended
         *
         * @return {SparkMD5} The instance itself
         */
        SparkMD5.prototype.append = function (str) {
            // Converts the string to utf8 bytes if necessary
            // Then append as binary
            this.appendBinary(toUtf8(str));

            return this;
        };

        /**
         * Appends a binary string.
         *
         * @param {String} contents The binary string to be appended
         *
         * @return {SparkMD5} The instance itself
         */
        SparkMD5.prototype.appendBinary = function (contents) {
            this._buff += contents;
            this._length += contents.length;

            var length = this._buff.length,
                i;

            for (i = 64; i <= length; i += 64) {
                md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
            }

            this._buff = this._buff.substring(i - 64);

            return this;
        };

        /**
         * Finishes the incremental computation, reseting the internal state and
         * returning the result.
         *
         * @param {Boolean} raw True to get the raw string, false to get the hex string
         *
         * @return {String} The result
         */
        SparkMD5.prototype.end = function (raw) {
            var buff = this._buff,
                length = buff.length,
                i,
                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ret;

            for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
            }

            this._finish(tail, length);
            ret = hex(this._hash);

            if (raw) {
                ret = hexToBinaryString(ret);
            }

            this.reset();

            return ret;
        };

        /**
         * Resets the internal state of the computation.
         *
         * @return {SparkMD5} The instance itself
         */
        SparkMD5.prototype.reset = function () {
            this._buff = '';
            this._length = 0;
            this._hash = [1732584193, -271733879, -1732584194, 271733878];

            return this;
        };

        /**
         * Gets the internal state of the computation.
         *
         * @return {Object} The state
         */
        SparkMD5.prototype.getState = function () {
            return {
                buff: this._buff,
                length: this._length,
                hash: this._hash.slice()
            };
        };

        /**
         * Gets the internal state of the computation.
         *
         * @param {Object} state The state
         *
         * @return {SparkMD5} The instance itself
         */
        SparkMD5.prototype.setState = function (state) {
            this._buff = state.buff;
            this._length = state.length;
            this._hash = state.hash;

            return this;
        };

        /**
         * Releases memory used by the incremental buffer and other additional
         * resources. If you plan to use the instance again, use reset instead.
         */
        SparkMD5.prototype.destroy = function () {
            delete this._hash;
            delete this._buff;
            delete this._length;
        };

        /**
         * Finish the final calculation based on the tail.
         *
         * @param {Array}  tail   The tail (will be modified)
         * @param {Number} length The length of the remaining buffer
         */
        SparkMD5.prototype._finish = function (tail, length) {
            var i = length,
                tmp,
                lo,
                hi;

            tail[i >> 2] |= 0x80 << ((i % 4) << 3);
            if (i > 55) {
                md5cycle(this._hash, tail);
                for (i = 0; i < 16; i += 1) {
                    tail[i] = 0;
                }
            }

            // Do the final computation based on the tail and length
            // Beware that the final length may not fit in 32 bits so we take care of that
            tmp = this._length * 8;
            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
            lo = parseInt(tmp[2], 16);
            hi = parseInt(tmp[1], 16) || 0;

            tail[14] = lo;
            tail[15] = hi;
            md5cycle(this._hash, tail);
        };

        /**
         * Performs the md5 hash on a string.
         * A conversion will be applied if utf8 string is detected.
         *
         * @param {String}  str The string
         * @param {Boolean} [raw] True to get the raw string, false to get the hex string
         *
         * @return {String} The result
         */
        SparkMD5.hash = function (str, raw) {
            // Converts the string to utf8 bytes if necessary
            // Then compute it using the binary function
            return SparkMD5.hashBinary(toUtf8(str), raw);
        };

        /**
         * Performs the md5 hash on a binary string.
         *
         * @param {String}  content The binary string
         * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
         *
         * @return {String} The result
         */
        SparkMD5.hashBinary = function (content, raw) {
            var hash = md51(content),
                ret = hex(hash);

            return raw ? hexToBinaryString(ret) : ret;
        };

        // ---------------------------------------------------

        /**
         * SparkMD5 OOP implementation for array buffers.
         *
         * Use this class to perform an incremental md5 ONLY for array buffers.
         */
        SparkMD5.ArrayBuffer = function () {
            // call reset to init the instance
            this.reset();
        };

        /**
         * Appends an array buffer.
         *
         * @param {ArrayBuffer} arr The array to be appended
         *
         * @return {SparkMD5.ArrayBuffer} The instance itself
         */
        SparkMD5.ArrayBuffer.prototype.append = function (arr) {
            var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
                length = buff.length,
                i;

            this._length += arr.byteLength;

            for (i = 64; i <= length; i += 64) {
                md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
            }

            this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

            return this;
        };

        /**
         * Finishes the incremental computation, reseting the internal state and
         * returning the result.
         *
         * @param {Boolean} raw True to get the raw string, false to get the hex string
         *
         * @return {String} The result
         */
        SparkMD5.ArrayBuffer.prototype.end = function (raw) {
            var buff = this._buff,
                length = buff.length,
                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                i,
                ret;

            for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= buff[i] << ((i % 4) << 3);
            }

            this._finish(tail, length);
            ret = hex(this._hash);

            if (raw) {
                ret = hexToBinaryString(ret);
            }

            this.reset();

            return ret;
        };

        /**
         * Resets the internal state of the computation.
         *
         * @return {SparkMD5.ArrayBuffer} The instance itself
         */
        SparkMD5.ArrayBuffer.prototype.reset = function () {
            this._buff = new Uint8Array(0);
            this._length = 0;
            this._hash = [1732584193, -271733879, -1732584194, 271733878];

            return this;
        };

        /**
         * Gets the internal state of the computation.
         *
         * @return {Object} The state
         */
        SparkMD5.ArrayBuffer.prototype.getState = function () {
            var state = SparkMD5.prototype.getState.call(this);

            // Convert buffer to a string
            state.buff = arrayBuffer2Utf8Str(state.buff);

            return state;
        };

        /**
         * Gets the internal state of the computation.
         *
         * @param {Object} state The state
         *
         * @return {SparkMD5.ArrayBuffer} The instance itself
         */
        SparkMD5.ArrayBuffer.prototype.setState = function (state) {
            // Convert string to buffer
            state.buff = utf8Str2ArrayBuffer(state.buff, true);

            return SparkMD5.prototype.setState.call(this, state);
        };

        SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

        SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

        /**
         * Performs the md5 hash on an array buffer.
         *
         * @param {ArrayBuffer} arr The array buffer
         * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
         *
         * @return {String} The result
         */
        SparkMD5.ArrayBuffer.hash = function (arr, raw) {
            var hash = md51_array(new Uint8Array(arr)),
                ret = hex(hash);

            return raw ? hexToBinaryString(ret) : ret;
        };

        return SparkMD5;
    }));
    });

    /**
     * Stringify/parse functions that don't operate
     * recursively, so they avoid call stack exceeded
     * errors.
     */
    var stringify = function stringify(input) {
      var queue = [];
      queue.push({obj: input});

      var res = '';
      var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
      while ((next = queue.pop())) {
        obj = next.obj;
        prefix = next.prefix || '';
        val = next.val || '';
        res += prefix;
        if (val) {
          res += val;
        } else if (typeof obj !== 'object') {
          res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
        } else if (obj === null) {
          res += 'null';
        } else if (Array.isArray(obj)) {
          queue.push({val: ']'});
          for (i = obj.length - 1; i >= 0; i--) {
            arrayPrefix = i === 0 ? '' : ',';
            queue.push({obj: obj[i], prefix: arrayPrefix});
          }
          queue.push({val: '['});
        } else { // object
          keys = [];
          for (k in obj) {
            if (obj.hasOwnProperty(k)) {
              keys.push(k);
            }
          }
          queue.push({val: '}'});
          for (i = keys.length - 1; i >= 0; i--) {
            key = keys[i];
            value = obj[key];
            objPrefix = (i > 0 ? ',' : '');
            objPrefix += JSON.stringify(key) + ':';
            queue.push({obj: value, prefix: objPrefix});
          }
          queue.push({val: '{'});
        }
      }
      return res;
    };

    // Convenience function for the parse function.
    // This pop function is basically copied from
    // pouchCollate.parseIndexableString
    function pop$1(obj, stack, metaStack) {
      var lastMetaElement = metaStack[metaStack.length - 1];
      if (obj === lastMetaElement.element) {
        // popping a meta-element, e.g. an object whose value is another object
        metaStack.pop();
        lastMetaElement = metaStack[metaStack.length - 1];
      }
      var element = lastMetaElement.element;
      var lastElementIndex = lastMetaElement.index;
      if (Array.isArray(element)) {
        element.push(obj);
      } else if (lastElementIndex === stack.length - 2) { // obj with key+value
        var key = stack.pop();
        element[key] = obj;
      } else {
        stack.push(obj); // obj with key only
      }
    }

    var parse = function (str) {
      var stack = [];
      var metaStack = []; // stack for arrays and objects
      var i = 0;
      var collationIndex,parsedNum,numChar;
      var parsedString,lastCh,numConsecutiveSlashes,ch;
      var arrayElement, objElement;
      while (true) {
        collationIndex = str[i++];
        if (collationIndex === '}' ||
            collationIndex === ']' ||
            typeof collationIndex === 'undefined') {
          if (stack.length === 1) {
            return stack.pop();
          } else {
            pop$1(stack.pop(), stack, metaStack);
            continue;
          }
        }
        switch (collationIndex) {
          case ' ':
          case '\t':
          case '\n':
          case ':':
          case ',':
            break;
          case 'n':
            i += 3; // 'ull'
            pop$1(null, stack, metaStack);
            break;
          case 't':
            i += 3; // 'rue'
            pop$1(true, stack, metaStack);
            break;
          case 'f':
            i += 4; // 'alse'
            pop$1(false, stack, metaStack);
            break;
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case '-':
            parsedNum = '';
            i--;
            while (true) {
              numChar = str[i++];
              if (/[\d\.\-e\+]/.test(numChar)) {
                parsedNum += numChar;
              } else {
                i--;
                break;
              }
            }
            pop$1(parseFloat(parsedNum), stack, metaStack);
            break;
          case '"':
            parsedString = '';
            lastCh = void 0;
            numConsecutiveSlashes = 0;
            while (true) {
              ch = str[i++];
              if (ch !== '"' || (lastCh === '\\' &&
                  numConsecutiveSlashes % 2 === 1)) {
                parsedString += ch;
                lastCh = ch;
                if (lastCh === '\\') {
                  numConsecutiveSlashes++;
                } else {
                  numConsecutiveSlashes = 0;
                }
              } else {
                break;
              }
            }
            pop$1(JSON.parse('"' + parsedString + '"'), stack, metaStack);
            break;
          case '[':
            arrayElement = { element: [], index: stack.length };
            stack.push(arrayElement.element);
            metaStack.push(arrayElement);
            break;
          case '{':
            objElement = { element: {}, index: stack.length };
            stack.push(objElement.element);
            metaStack.push(objElement);
            break;
          default:
            throw new Error(
              'unexpectedly reached end of input: ' + collationIndex);
        }
      }
    };

    var vuvuzela = {
    	stringify: stringify,
    	parse: parse
    };

    var argsarray = argsArray;

    function argsArray(fun) {
      return function () {
        var len = arguments.length;
        if (len) {
          var args = [];
          var i = -1;
          while (++i < len) {
            args[i] = arguments[i];
          }
          return fun.call(this, args);
        } else {
          return fun.call(this, []);
        }
      };
    }

    var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    });

    var domain;

    // This constructor is used to store event handlers. Instantiating this is
    // faster than explicitly calling `Object.create(null)` to get a "clean" empty
    // object (tested with v8 v4.9).
    function EventHandlers() {}
    EventHandlers.prototype = Object.create(null);

    function EventEmitter() {
      EventEmitter.init.call(this);
    }

    // nodejs oddity
    // require('events') === require('events').EventEmitter
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.usingDomains = false;

    EventEmitter.prototype.domain = undefined;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        // if there is an active domain, then attach to it.
        if (domain.active ) ;
      }

      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };

    // These standalone emit* functions are used to optimize calling of event
    // handlers for fast cases because emit() itself often has a variable number of
    // arguments and can be deoptimized because of that. These functions always have
    // the same number of arguments and thus do not get deoptimized, so the code
    // inside them can execute faster.
    function emitNone(handler, isFn, self) {
      if (isFn)
        handler.call(self);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self);
      }
    }
    function emitOne(handler, isFn, self, arg1) {
      if (isFn)
        handler.call(self, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1);
      }
    }
    function emitTwo(handler, isFn, self, arg1, arg2) {
      if (isFn)
        handler.call(self, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2, arg3);
      }
    }

    function emitMany(handler, isFn, self, args) {
      if (isFn)
        handler.apply(self, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self, args);
      }
    }

    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain;
      var doError = (type === 'error');

      events = this._events;
      if (events)
        doError = (doError && events.error == null);
      else if (!doError)
        return false;

      domain = this.domain;

      // If there is no 'error' event listener then throw.
      if (doError) {
        er = arguments[1];
        if (domain) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain;
          er.domainThrown = false;
          domain.emit('error', er);
        } else if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }
        return false;
      }

      handler = events[type];

      if (!handler)
        return false;

      var isFn = typeof handler === 'function';
      len = arguments.length;
      switch (len) {
        // fast cases
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        // slower
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (!existing) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] :
                                              [existing, listener];
        } else {
          // If we've already got an array, just append.
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }

        // Check for listener leak
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                                existing.length + ' ' + type + ' listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }

      return target;
    }
    function emitWarning(e) {
      typeof console.warn === 'function' ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events)
            return this;

          list = events[type];
          if (!list)
            return this;

          if (list === listener || (list.listener && list.listener === listener)) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length; i-- > 0;) {
              if (list[i] === listener ||
                  (list[i].listener && list[i].listener === listener)) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (list.length === 1) {
              list[0] = undefined;
              if (--this._eventsCount === 0) {
                this._events = new EventHandlers();
                return this;
              } else {
                delete events[type];
              }
            } else {
              spliceOne(list, position);
            }

            if (events.removeListener)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events;

          events = this._events;
          if (!events)
            return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = new EventHandlers();
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = new EventHandlers();
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            for (var i = 0, key; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = new EventHandlers();
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            do {
              this.removeListener(type, listeners[listeners.length - 1]);
            } while (listeners[0]);
          }

          return this;
        };

    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;

      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === 'function')
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }

      return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;

      if (events) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };

    // About 1.5x faster than the two-arg version of Array#splice().
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }

    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    function mangle(key) {
      return '$' + key;
    }
    function unmangle(key) {
      return key.substring(1);
    }
    function Map$1() {
      this._store = {};
    }
    Map$1.prototype.get = function (key) {
      var mangled = mangle(key);
      return this._store[mangled];
    };
    Map$1.prototype.set = function (key, value) {
      var mangled = mangle(key);
      this._store[mangled] = value;
      return true;
    };
    Map$1.prototype.has = function (key) {
      var mangled = mangle(key);
      return mangled in this._store;
    };
    Map$1.prototype.delete = function (key) {
      var mangled = mangle(key);
      var res = mangled in this._store;
      delete this._store[mangled];
      return res;
    };
    Map$1.prototype.forEach = function (cb) {
      var keys = Object.keys(this._store);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        var value = this._store[key];
        key = unmangle(key);
        cb(value, key);
      }
    };
    Object.defineProperty(Map$1.prototype, 'size', {
      get: function () {
        return Object.keys(this._store).length;
      }
    });

    function Set$1(array) {
      this._store = new Map$1();

      // init with an array
      if (array && Array.isArray(array)) {
        for (var i = 0, len = array.length; i < len; i++) {
          this.add(array[i]);
        }
      }
    }
    Set$1.prototype.add = function (key) {
      return this._store.set(key, true);
    };
    Set$1.prototype.has = function (key) {
      return this._store.has(key);
    };
    Set$1.prototype.forEach = function (cb) {
      this._store.forEach(function (value, key) {
        cb(key);
      });
    };
    Object.defineProperty(Set$1.prototype, 'size', {
      get: function () {
        return this._store.size;
      }
    });

    /* global Map,Set,Symbol */
    // Based on https://kangax.github.io/compat-table/es6/ we can sniff out
    // incomplete Map/Set implementations which would otherwise cause our tests to fail.
    // Notably they fail in IE11 and iOS 8.4, which this prevents.
    function supportsMapAndSet() {
      if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {
        return false;
      }
      var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);
      return prop && 'get' in prop && Map[Symbol.species] === Map;
    }

    // based on https://github.com/montagejs/collections

    var ExportedSet;
    var ExportedMap;

    {
      if (supportsMapAndSet()) { // prefer built-in Map/Set
        ExportedSet = Set;
        ExportedMap = Map;
      } else { // fall back to our polyfill
        ExportedSet = Set$1;
        ExportedMap = Map$1;
      }
    }

    function isBinaryObject(object) {
      return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||
        (typeof Blob !== 'undefined' && object instanceof Blob);
    }

    function cloneArrayBuffer(buff) {
      if (typeof buff.slice === 'function') {
        return buff.slice(0);
      }
      // IE10-11 slice() polyfill
      var target = new ArrayBuffer(buff.byteLength);
      var targetArray = new Uint8Array(target);
      var sourceArray = new Uint8Array(buff);
      targetArray.set(sourceArray);
      return target;
    }

    function cloneBinaryObject(object) {
      if (object instanceof ArrayBuffer) {
        return cloneArrayBuffer(object);
      }
      var size = object.size;
      var type = object.type;
      // Blob
      if (typeof object.slice === 'function') {
        return object.slice(0, size, type);
      }
      // PhantomJS slice() replacement
      return object.webkitSlice(0, size, type);
    }

    // most of this is borrowed from lodash.isPlainObject:
    // https://github.com/fis-components/lodash.isplainobject/
    // blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js

    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);

    function isPlainObject(value) {
      var proto = Object.getPrototypeOf(value);
      /* istanbul ignore if */
      if (proto === null) { // not sure when this happens, but I guess it can
        return true;
      }
      var Ctor = proto.constructor;
      return (typeof Ctor == 'function' &&
        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
    }

    function clone(object) {
      var newObject;
      var i;
      var len;

      if (!object || typeof object !== 'object') {
        return object;
      }

      if (Array.isArray(object)) {
        newObject = [];
        for (i = 0, len = object.length; i < len; i++) {
          newObject[i] = clone(object[i]);
        }
        return newObject;
      }

      // special case: to avoid inconsistencies between IndexedDB
      // and other backends, we automatically stringify Dates
      if (object instanceof Date) {
        return object.toISOString();
      }

      if (isBinaryObject(object)) {
        return cloneBinaryObject(object);
      }

      if (!isPlainObject(object)) {
        return object; // don't clone objects like Workers
      }

      newObject = {};
      for (i in object) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(object, i)) {
          var value = clone(object[i]);
          if (typeof value !== 'undefined') {
            newObject[i] = value;
          }
        }
      }
      return newObject;
    }

    function once$1(fun) {
      var called = false;
      return argsarray(function (args) {
        /* istanbul ignore if */
        if (called) {
          // this is a smoke test and should never actually happen
          throw new Error('once called more than once');
        } else {
          called = true;
          fun.apply(this, args);
        }
      });
    }

    function toPromise(func) {
      //create the function we will be returning
      return argsarray(function (args) {
        // Clone arguments
        args = clone(args);
        var self = this;
        // if the last argument is a function, assume its a callback
        var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
        var promise = new Promise(function (fulfill, reject) {
          var resp;
          try {
            var callback = once$1(function (err, mesg) {
              if (err) {
                reject(err);
              } else {
                fulfill(mesg);
              }
            });
            // create a callback for this invocation
            // apply the function in the orig context
            args.push(callback);
            resp = func.apply(self, args);
            if (resp && typeof resp.then === 'function') {
              fulfill(resp);
            }
          } catch (e) {
            reject(e);
          }
        });
        // if there is a callback, call it back
        if (usedCB) {
          promise.then(function (result) {
            usedCB(null, result);
          }, usedCB);
        }
        return promise;
      });
    }

    function logApiCall(self, name, args) {
      /* istanbul ignore if */
      if (self.constructor.listeners('debug').length) {
        var logArgs = ['api', self.name, name];
        for (var i = 0; i < args.length - 1; i++) {
          logArgs.push(args[i]);
        }
        self.constructor.emit('debug', logArgs);

        // override the callback itself to log the response
        var origCallback = args[args.length - 1];
        args[args.length - 1] = function (err, res) {
          var responseArgs = ['api', self.name, name];
          responseArgs = responseArgs.concat(
            err ? ['error', err] : ['success', res]
          );
          self.constructor.emit('debug', responseArgs);
          origCallback(err, res);
        };
      }
    }

    function adapterFun(name, callback) {
      return toPromise(argsarray(function (args) {
        if (this._closed) {
          return Promise.reject(new Error('database is closed'));
        }
        if (this._destroyed) {
          return Promise.reject(new Error('database is destroyed'));
        }
        var self = this;
        logApiCall(self, name, args);
        if (!this.taskqueue.isReady) {
          return new Promise(function (fulfill, reject) {
            self.taskqueue.addTask(function (failed) {
              if (failed) {
                reject(failed);
              } else {
                fulfill(self[name].apply(self, args));
              }
            });
          });
        }
        return callback.apply(this, args);
      }));
    }

    // like underscore/lodash _.pick()
    function pick(obj, arr) {
      var res = {};
      for (var i = 0, len = arr.length; i < len; i++) {
        var prop = arr[i];
        if (prop in obj) {
          res[prop] = obj[prop];
        }
      }
      return res;
    }

    // Most browsers throttle concurrent requests at 6, so it's silly
    // to shim _bulk_get by trying to launch potentially hundreds of requests
    // and then letting the majority time out. We can handle this ourselves.
    var MAX_NUM_CONCURRENT_REQUESTS = 6;

    function identityFunction(x) {
      return x;
    }

    function formatResultForOpenRevsGet(result) {
      return [{
        ok: result
      }];
    }

    // shim for P/CouchDB adapters that don't directly implement _bulk_get
    function bulkGet(db, opts, callback) {
      var requests = opts.docs;

      // consolidate into one request per doc if possible
      var requestsById = new ExportedMap();
      requests.forEach(function (request) {
        if (requestsById.has(request.id)) {
          requestsById.get(request.id).push(request);
        } else {
          requestsById.set(request.id, [request]);
        }
      });

      var numDocs = requestsById.size;
      var numDone = 0;
      var perDocResults = new Array(numDocs);

      function collapseResultsAndFinish() {
        var results = [];
        perDocResults.forEach(function (res) {
          res.docs.forEach(function (info) {
            results.push({
              id: res.id,
              docs: [info]
            });
          });
        });
        callback(null, {results: results});
      }

      function checkDone() {
        if (++numDone === numDocs) {
          collapseResultsAndFinish();
        }
      }

      function gotResult(docIndex, id, docs) {
        perDocResults[docIndex] = {id: id, docs: docs};
        checkDone();
      }

      var allRequests = [];
      requestsById.forEach(function (value, key) {
        allRequests.push(key);
      });

      var i = 0;

      function nextBatch() {

        if (i >= allRequests.length) {
          return;
        }

        var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);
        var batch = allRequests.slice(i, upTo);
        processBatch(batch, i);
        i += batch.length;
      }

      function processBatch(batch, offset) {
        batch.forEach(function (docId, j) {
          var docIdx = offset + j;
          var docRequests = requestsById.get(docId);

          // just use the first request as the "template"
          // TODO: The _bulk_get API allows for more subtle use cases than this,
          // but for now it is unlikely that there will be a mix of different
          // "atts_since" or "attachments" in the same request, since it's just
          // replicate.js that is using this for the moment.
          // Also, atts_since is aspirational, since we don't support it yet.
          var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
          docOpts.open_revs = docRequests.map(function (request) {
            // rev is optional, open_revs disallowed
            return request.rev;
          });

          // remove falsey / undefined revisions
          docOpts.open_revs = docOpts.open_revs.filter(identityFunction);

          var formatResult = identityFunction;

          if (docOpts.open_revs.length === 0) {
            delete docOpts.open_revs;

            // when fetching only the "winning" leaf,
            // transform the result so it looks like an open_revs
            // request
            formatResult = formatResultForOpenRevsGet;
          }

          // globally-supplied options
          ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {
            if (param in opts) {
              docOpts[param] = opts[param];
            }
          });
          db.get(docId, docOpts, function (err, res) {
            var result;
            /* istanbul ignore if */
            if (err) {
              result = [{error: err}];
            } else {
              result = formatResult(res);
            }
            gotResult(docIdx, docId, result);
            nextBatch();
          });
        });
      }

      nextBatch();

    }

    var hasLocal;

    try {
      localStorage.setItem('_pouch_check_localstorage', 1);
      hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
    } catch (e) {
      hasLocal = false;
    }

    function hasLocalStorage() {
      return hasLocal;
    }

    // Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We

    inherits_browser(Changes, EventEmitter);

    /* istanbul ignore next */
    function attachBrowserEvents(self) {
      if (hasLocalStorage()) {
        addEventListener("storage", function (e) {
          self.emit(e.key);
        });
      }
    }

    function Changes() {
      EventEmitter.call(this);
      this._listeners = {};

      attachBrowserEvents(this);
    }
    Changes.prototype.addListener = function (dbName, id, db, opts) {
      /* istanbul ignore if */
      if (this._listeners[id]) {
        return;
      }
      var self = this;
      var inprogress = false;
      function eventFunction() {
        /* istanbul ignore if */
        if (!self._listeners[id]) {
          return;
        }
        if (inprogress) {
          inprogress = 'waiting';
          return;
        }
        inprogress = true;
        var changesOpts = pick(opts, [
          'style', 'include_docs', 'attachments', 'conflicts', 'filter',
          'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'
        ]);

        /* istanbul ignore next */
        function onError() {
          inprogress = false;
        }

        db.changes(changesOpts).on('change', function (c) {
          if (c.seq > opts.since && !opts.cancelled) {
            opts.since = c.seq;
            opts.onChange(c);
          }
        }).on('complete', function () {
          if (inprogress === 'waiting') {
            lib(eventFunction);
          }
          inprogress = false;
        }).on('error', onError);
      }
      this._listeners[id] = eventFunction;
      this.on(dbName, eventFunction);
    };

    Changes.prototype.removeListener = function (dbName, id) {
      /* istanbul ignore if */
      if (!(id in this._listeners)) {
        return;
      }
      EventEmitter.prototype.removeListener.call(this, dbName,
        this._listeners[id]);
      delete this._listeners[id];
    };


    /* istanbul ignore next */
    Changes.prototype.notifyLocalWindows = function (dbName) {
      //do a useless change on a storage thing
      //in order to get other windows's listeners to activate
      if (hasLocalStorage()) {
        localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
      }
    };

    Changes.prototype.notify = function (dbName) {
      this.emit(dbName);
      this.notifyLocalWindows(dbName);
    };

    function guardedConsole(method) {
      /* istanbul ignore else */
      if (typeof console !== 'undefined' && typeof console[method] === 'function') {
        var args = Array.prototype.slice.call(arguments, 1);
        console[method].apply(console, args);
      }
    }

    function randomNumber(min, max) {
      var maxTimeout = 600000; // Hard-coded default of 10 minutes
      min = parseInt(min, 10) || 0;
      max = parseInt(max, 10);
      if (max !== max || max <= min) {
        max = (min || 1) << 1; //doubling
      } else {
        max = max + 1;
      }
      // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout
      if (max > maxTimeout) {
        min = maxTimeout >> 1; // divide by two
        max = maxTimeout;
      }
      var ratio = Math.random();
      var range = max - min;

      return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
    }

    function defaultBackOff(min) {
      var max = 0;
      if (!min) {
        max = 2000;
      }
      return randomNumber(min, max);
    }

    // designed to give info to browser users, who are disturbed
    // when they see http errors in the console
    function explainError(status, str) {
      guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);
    }

    var assign$1;
    {
      if (typeof Object.assign === 'function') {
        assign$1 = Object.assign;
      } else {
        // lite Object.assign polyfill based on
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
        assign$1 = function (target) {
          var to = Object(target);

          for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource != null) { // Skip over if undefined or null
              for (var nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                  to[nextKey] = nextSource[nextKey];
                }
              }
            }
          }
          return to;
        };
      }
    }

    var $inject_Object_assign = assign$1;

    inherits_browser(PouchError, Error);

    function PouchError(status, error, reason) {
      Error.call(this, reason);
      this.status = status;
      this.name = error;
      this.message = reason;
      this.error = true;
    }

    PouchError.prototype.toString = function () {
      return JSON.stringify({
        status: this.status,
        name: this.name,
        message: this.message,
        reason: this.reason
      });
    };

    new PouchError(401, 'unauthorized', "Name or password is incorrect.");
    var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
    var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
    var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
    var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
    var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
    var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
    new PouchError(412, 'precondition_failed', 'Database not open');
    var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
    var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
    new PouchError(400, 'invalid_request', 'Request was invalid');
    var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
    var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
    var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
    var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
    new PouchError(404, 'not_found', 'Database not found');
    var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
    new PouchError(500, 'web_sql_went_bad', 'unknown');
    new PouchError(500, 'levelDB_went_went_bad', 'unknown');
    new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
    var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
    new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
    var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\'t found');
    new PouchError(413, 'invalid_url', 'Provided URL is invalid');

    function createError(error, reason) {
      function CustomPouchError(reason) {
        // inherit error properties from our parent error manually
        // so as to allow proper JSON parsing.
        /* jshint ignore:start */
        var names = Object.getOwnPropertyNames(error);
        for (var i = 0, len = names.length; i < len; i++) {
          if (typeof error[names[i]] !== 'function') {
            this[names[i]] = error[names[i]];
          }
        }
        /* jshint ignore:end */
        if (reason !== undefined) {
          this.reason = reason;
        }
      }
      CustomPouchError.prototype = PouchError.prototype;
      return new CustomPouchError(reason);
    }

    function generateErrorFromResponse(err) {

      if (typeof err !== 'object') {
        var data = err;
        err = UNKNOWN_ERROR;
        err.data = data;
      }

      if ('error' in err && err.error === 'conflict') {
        err.name = 'conflict';
        err.status = 409;
      }

      if (!('name' in err)) {
        err.name = err.error || 'unknown';
      }

      if (!('status' in err)) {
        err.status = 500;
      }

      if (!('message' in err)) {
        err.message = err.message || err.reason;
      }

      return err;
    }

    function tryFilter(filter, doc, req) {
      try {
        return !filter(doc, req);
      } catch (err) {
        var msg = 'Filter function threw: ' + err.toString();
        return createError(BAD_REQUEST, msg);
      }
    }

    function filterChange(opts) {
      var req = {};
      var hasFilter = opts.filter && typeof opts.filter === 'function';
      req.query = opts.query_params;

      return function filter(change) {
        if (!change.doc) {
          // CSG sends events on the changes feed that don't have documents,
          // this hack makes a whole lot of existing code robust.
          change.doc = {};
        }

        var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);

        if (typeof filterReturn === 'object') {
          return filterReturn;
        }

        if (filterReturn) {
          return false;
        }

        if (!opts.include_docs) {
          delete change.doc;
        } else if (!opts.attachments) {
          for (var att in change.doc._attachments) {
            /* istanbul ignore else */
            if (change.doc._attachments.hasOwnProperty(att)) {
              change.doc._attachments[att].stub = true;
            }
          }
        }
        return true;
      };
    }

    function flatten(arrs) {
      var res = [];
      for (var i = 0, len = arrs.length; i < len; i++) {
        res = res.concat(arrs[i]);
      }
      return res;
    }

    // shim for Function.prototype.name,

    // Determine id an ID is valid
    //   - invalid IDs begin with an underescore that does not begin '_design' or
    //     '_local'
    //   - any other string value is a valid id
    // Returns the specific error object for each case
    function invalidIdError(id) {
      var err;
      if (!id) {
        err = createError(MISSING_ID);
      } else if (typeof id !== 'string') {
        err = createError(INVALID_ID);
      } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
        err = createError(RESERVED_ID);
      }
      if (err) {
        throw err;
      }
    }

    // Checks if a PouchDB object is "remote" or not. This is

    function isRemote(db) {
      if (typeof db._remote === 'boolean') {
        return db._remote;
      }
      /* istanbul ignore next */
      if (typeof db.type === 'function') {
        guardedConsole('warn',
          'db.type() is deprecated and will be removed in ' +
          'a future version of PouchDB');
        return db.type() === 'http';
      }
      /* istanbul ignore next */
      return false;
    }

    function listenerCount$1(ee, type) {
      return 'listenerCount' in ee ? ee.listenerCount(type) :
                                     EventEmitter.listenerCount(ee, type);
    }

    function parseDesignDocFunctionName(s) {
      if (!s) {
        return null;
      }
      var parts = s.split('/');
      if (parts.length === 2) {
        return parts;
      }
      if (parts.length === 1) {
        return [s, s];
      }
      return null;
    }

    function normalizeDesignDocFunctionName(s) {
      var normalized = parseDesignDocFunctionName(s);
      return normalized ? normalized.join('/') : null;
    }

    // originally parseUri 1.2.2, now patched by us
    // (c) Steven Levithan <stevenlevithan.com>
    // MIT License
    var keys = ["source", "protocol", "authority", "userInfo", "user", "password",
        "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
    var qName ="queryKey";
    var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;

    // use the "loose" parser
    /* eslint maxlen: 0, no-useless-escape: 0 */
    var parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

    function parseUri(str) {
      var m = parser.exec(str);
      var uri = {};
      var i = 14;

      while (i--) {
        var key = keys[i];
        var value = m[i] || "";
        var encoded = ['user', 'password'].indexOf(key) !== -1;
        uri[key] = encoded ? decodeURIComponent(value) : value;
      }

      uri[qName] = {};
      uri[keys[12]].replace(qParser, function ($0, $1, $2) {
        if ($1) {
          uri[qName][$1] = $2;
        }
      });

      return uri;
    }

    // Based on https://github.com/alexdavid/scope-eval v0.0.3
    // (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)
    // This is basically just a wrapper around new Function()

    function scopeEval(source, scope) {
      var keys = [];
      var values = [];
      for (var key in scope) {
        if (scope.hasOwnProperty(key)) {
          keys.push(key);
          values.push(scope[key]);
        }
      }
      keys.push(source);
      return Function.apply(null, keys).apply(null, values);
    }

    // this is essentially the "update sugar" function from daleharvey/pouchdb#1388
    // the diffFun tells us what delta to apply to the doc.  it either returns
    // the doc, or false if it doesn't need to do an update after all
    function upsert(db, docId, diffFun) {
      return new Promise(function (fulfill, reject) {
        db.get(docId, function (err, doc) {
          if (err) {
            /* istanbul ignore next */
            if (err.status !== 404) {
              return reject(err);
            }
            doc = {};
          }

          // the user might change the _rev, so save it for posterity
          var docRev = doc._rev;
          var newDoc = diffFun(doc);

          if (!newDoc) {
            // if the diffFun returns falsy, we short-circuit as
            // an optimization
            return fulfill({updated: false, rev: docRev});
          }

          // users aren't allowed to modify these values,
          // so reset them here
          newDoc._id = docId;
          newDoc._rev = docRev;
          fulfill(tryAndPut(db, newDoc, diffFun));
        });
      });
    }

    function tryAndPut(db, doc, diffFun) {
      return db.put(doc).then(function (res) {
        return {
          updated: true,
          rev: res.rev
        };
      }, function (err) {
        /* istanbul ignore next */
        if (err.status !== 409) {
          throw err;
        }
        return upsert(db, doc._id, diffFun);
      });
    }

    var thisAtob = function (str) {
      return atob(str);
    };

    var thisBtoa = function (str) {
      return btoa(str);
    };

    // Abstracts constructing a Blob object, so it also works in older
    // browsers that don't support the native Blob constructor (e.g.
    // old QtWebKit versions, Android < 4.4).
    function createBlob(parts, properties) {
      /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
      parts = parts || [];
      properties = properties || {};
      try {
        return new Blob(parts, properties);
      } catch (e) {
        if (e.name !== "TypeError") {
          throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
                      typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
                      typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :
                      WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
          builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
      }
    }

    // From http://stackoverflow.com/questions/14967647/ (continues on next line)
    // encode-decode-image-with-base64-breaks-image (2013-04-21)
    function binaryStringToArrayBuffer(bin) {
      var length = bin.length;
      var buf = new ArrayBuffer(length);
      var arr = new Uint8Array(buf);
      for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
      }
      return buf;
    }

    function binStringToBluffer(binString, type) {
      return createBlob([binaryStringToArrayBuffer(binString)], {type: type});
    }

    function b64ToBluffer(b64, type) {
      return binStringToBluffer(thisAtob(b64), type);
    }

    //Can't find original post, but this is close
    //http://stackoverflow.com/questions/6965107/ (continues on next line)
    //converting-between-strings-and-arraybuffers
    function arrayBufferToBinaryString(buffer) {
      var binary = '';
      var bytes = new Uint8Array(buffer);
      var length = bytes.byteLength;
      for (var i = 0; i < length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return binary;
    }

    // shim for browsers that don't support it
    function readAsBinaryString(blob, callback) {
      var reader = new FileReader();
      var hasBinaryString = typeof reader.readAsBinaryString === 'function';
      reader.onloadend = function (e) {
        var result = e.target.result || '';
        if (hasBinaryString) {
          return callback(result);
        }
        callback(arrayBufferToBinaryString(result));
      };
      if (hasBinaryString) {
        reader.readAsBinaryString(blob);
      } else {
        reader.readAsArrayBuffer(blob);
      }
    }

    function blobToBinaryString(blobOrBuffer, callback) {
      readAsBinaryString(blobOrBuffer, function (bin) {
        callback(bin);
      });
    }

    function blobToBase64(blobOrBuffer, callback) {
      blobToBinaryString(blobOrBuffer, function (base64) {
        callback(thisBtoa(base64));
      });
    }

    // simplified API. universal browser support is assumed
    function readAsArrayBuffer(blob, callback) {
      var reader = new FileReader();
      reader.onloadend = function (e) {
        var result = e.target.result || new ArrayBuffer(0);
        callback(result);
      };
      reader.readAsArrayBuffer(blob);
    }

    // this is not used in the browser

    var setImmediateShim = self.setImmediate || self.setTimeout;
    var MD5_CHUNK_SIZE = 32768;

    function rawToBase64(raw) {
      return thisBtoa(raw);
    }

    function sliceBlob(blob, start, end) {
      if (blob.webkitSlice) {
        return blob.webkitSlice(start, end);
      }
      return blob.slice(start, end);
    }

    function appendBlob(buffer, blob, start, end, callback) {
      if (start > 0 || end < blob.size) {
        // only slice blob if we really need to
        blob = sliceBlob(blob, start, end);
      }
      readAsArrayBuffer(blob, function (arrayBuffer) {
        buffer.append(arrayBuffer);
        callback();
      });
    }

    function appendString(buffer, string, start, end, callback) {
      if (start > 0 || end < string.length) {
        // only create a substring if we really need to
        string = string.substring(start, end);
      }
      buffer.appendBinary(string);
      callback();
    }

    function binaryMd5(data, callback) {
      var inputIsString = typeof data === 'string';
      var len = inputIsString ? data.length : data.size;
      var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
      var chunks = Math.ceil(len / chunkSize);
      var currentChunk = 0;
      var buffer = inputIsString ? new sparkMd5() : new sparkMd5.ArrayBuffer();

      var append = inputIsString ? appendString : appendBlob;

      function next() {
        setImmediateShim(loadNextChunk);
      }

      function done() {
        var raw = buffer.end(true);
        var base64 = rawToBase64(raw);
        callback(base64);
        buffer.destroy();
      }

      function loadNextChunk() {
        var start = currentChunk * chunkSize;
        var end = start + chunkSize;
        currentChunk++;
        if (currentChunk < chunks) {
          append(buffer, data, start, end, next);
        } else {
          append(buffer, data, start, end, done);
        }
      }
      loadNextChunk();
    }

    function stringMd5(string) {
      return sparkMd5.hash(string);
    }

    function rev(doc, deterministic_revs) {
      var clonedDoc = clone(doc);
      if (!deterministic_revs) {
        return v4().replace(/-/g, '').toLowerCase();
      }

      delete clonedDoc._rev_tree;
      return stringMd5(JSON.stringify(clonedDoc));
    }

    var uuid = v4; // mimic old import, only v4 is ever used elsewhere

    // We fetch all leafs of the revision tree, and sort them based on tree length
    // and whether they were deleted, undeleted documents with the longest revision
    // tree (most edits) win
    // The final sort algorithm is slightly documented in a sidebar here:
    // http://guide.couchdb.org/draft/conflicts.html
    function winningRev(metadata) {
      var winningId;
      var winningPos;
      var winningDeleted;
      var toVisit = metadata.rev_tree.slice();
      var node;
      while ((node = toVisit.pop())) {
        var tree = node.ids;
        var branches = tree[2];
        var pos = node.pos;
        if (branches.length) { // non-leaf
          for (var i = 0, len = branches.length; i < len; i++) {
            toVisit.push({pos: pos + 1, ids: branches[i]});
          }
          continue;
        }
        var deleted = !!tree[1].deleted;
        var id = tree[0];
        // sort by deleted, then pos, then id
        if (!winningId || (winningDeleted !== deleted ? winningDeleted :
            winningPos !== pos ? winningPos < pos : winningId < id)) {
          winningId = id;
          winningPos = pos;
          winningDeleted = deleted;
        }
      }

      return winningPos + '-' + winningId;
    }

    // Pretty much all below can be combined into a higher order function to
    // traverse revisions
    // The return value from the callback will be passed as context to all
    // children of that node
    function traverseRevTree(revs, callback) {
      var toVisit = revs.slice();

      var node;
      while ((node = toVisit.pop())) {
        var pos = node.pos;
        var tree = node.ids;
        var branches = tree[2];
        var newCtx =
          callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
        for (var i = 0, len = branches.length; i < len; i++) {
          toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});
        }
      }
    }

    function sortByPos(a, b) {
      return a.pos - b.pos;
    }

    function collectLeaves(revs) {
      var leaves = [];
      traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
        if (isLeaf) {
          leaves.push({rev: pos + "-" + id, pos: pos, opts: opts});
        }
      });
      leaves.sort(sortByPos).reverse();
      for (var i = 0, len = leaves.length; i < len; i++) {
        delete leaves[i].pos;
      }
      return leaves;
    }

    // returns revs of all conflicts that is leaves such that
    // 1. are not deleted and
    // 2. are different than winning revision
    function collectConflicts(metadata) {
      var win = winningRev(metadata);
      var leaves = collectLeaves(metadata.rev_tree);
      var conflicts = [];
      for (var i = 0, len = leaves.length; i < len; i++) {
        var leaf = leaves[i];
        if (leaf.rev !== win && !leaf.opts.deleted) {
          conflicts.push(leaf.rev);
        }
      }
      return conflicts;
    }

    // compact a tree by marking its non-leafs as missing,
    // and return a list of revs to delete
    function compactTree(metadata) {
      var revs = [];
      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                   revHash, ctx, opts) {
        if (opts.status === 'available' && !isLeaf) {
          revs.push(pos + '-' + revHash);
          opts.status = 'missing';
        }
      });
      return revs;
    }

    // build up a list of all the paths to the leafs in this revision tree
    function rootToLeaf(revs) {
      var paths = [];
      var toVisit = revs.slice();
      var node;
      while ((node = toVisit.pop())) {
        var pos = node.pos;
        var tree = node.ids;
        var id = tree[0];
        var opts = tree[1];
        var branches = tree[2];
        var isLeaf = branches.length === 0;

        var history = node.history ? node.history.slice() : [];
        history.push({id: id, opts: opts});
        if (isLeaf) {
          paths.push({pos: (pos + 1 - history.length), ids: history});
        }
        for (var i = 0, len = branches.length; i < len; i++) {
          toVisit.push({pos: pos + 1, ids: branches[i], history: history});
        }
      }
      return paths.reverse();
    }

    // for a better overview of what this is doing, read:

    function sortByPos$1(a, b) {
      return a.pos - b.pos;
    }

    // classic binary search
    function binarySearch(arr, item, comparator) {
      var low = 0;
      var high = arr.length;
      var mid;
      while (low < high) {
        mid = (low + high) >>> 1;
        if (comparator(arr[mid], item) < 0) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    }

    // assuming the arr is sorted, insert the item in the proper place
    function insertSorted(arr, item, comparator) {
      var idx = binarySearch(arr, item, comparator);
      arr.splice(idx, 0, item);
    }

    // Turn a path as a flat array into a tree with a single branch.
    // If any should be stemmed from the beginning of the array, that's passed
    // in as the second argument
    function pathToTree(path, numStemmed) {
      var root;
      var leaf;
      for (var i = numStemmed, len = path.length; i < len; i++) {
        var node = path[i];
        var currentLeaf = [node.id, node.opts, []];
        if (leaf) {
          leaf[2].push(currentLeaf);
          leaf = currentLeaf;
        } else {
          root = leaf = currentLeaf;
        }
      }
      return root;
    }

    // compare the IDs of two trees
    function compareTree(a, b) {
      return a[0] < b[0] ? -1 : 1;
    }

    // Merge two trees together
    // The roots of tree1 and tree2 must be the same revision
    function mergeTree(in_tree1, in_tree2) {
      var queue = [{tree1: in_tree1, tree2: in_tree2}];
      var conflicts = false;
      while (queue.length > 0) {
        var item = queue.pop();
        var tree1 = item.tree1;
        var tree2 = item.tree2;

        if (tree1[1].status || tree2[1].status) {
          tree1[1].status =
            (tree1[1].status ===  'available' ||
            tree2[1].status === 'available') ? 'available' : 'missing';
        }

        for (var i = 0; i < tree2[2].length; i++) {
          if (!tree1[2][0]) {
            conflicts = 'new_leaf';
            tree1[2][0] = tree2[2][i];
            continue;
          }

          var merged = false;
          for (var j = 0; j < tree1[2].length; j++) {
            if (tree1[2][j][0] === tree2[2][i][0]) {
              queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});
              merged = true;
            }
          }
          if (!merged) {
            conflicts = 'new_branch';
            insertSorted(tree1[2], tree2[2][i], compareTree);
          }
        }
      }
      return {conflicts: conflicts, tree: in_tree1};
    }

    function doMerge(tree, path, dontExpand) {
      var restree = [];
      var conflicts = false;
      var merged = false;
      var res;

      if (!tree.length) {
        return {tree: [path], conflicts: 'new_leaf'};
      }

      for (var i = 0, len = tree.length; i < len; i++) {
        var branch = tree[i];
        if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
          // Paths start at the same position and have the same root, so they need
          // merged
          res = mergeTree(branch.ids, path.ids);
          restree.push({pos: branch.pos, ids: res.tree});
          conflicts = conflicts || res.conflicts;
          merged = true;
        } else if (dontExpand !== true) {
          // The paths start at a different position, take the earliest path and
          // traverse up until it as at the same point from root as the path we
          // want to merge.  If the keys match we return the longer path with the
          // other merged After stemming we dont want to expand the trees

          var t1 = branch.pos < path.pos ? branch : path;
          var t2 = branch.pos < path.pos ? path : branch;
          var diff = t2.pos - t1.pos;

          var candidateParents = [];

          var trees = [];
          trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});
          while (trees.length > 0) {
            var item = trees.pop();
            if (item.diff === 0) {
              if (item.ids[0] === t2.ids[0]) {
                candidateParents.push(item);
              }
              continue;
            }
            var elements = item.ids[2];
            for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
              trees.push({
                ids: elements[j],
                diff: item.diff - 1,
                parent: item.ids,
                parentIdx: j
              });
            }
          }

          var el = candidateParents[0];

          if (!el) {
            restree.push(branch);
          } else {
            res = mergeTree(el.ids, t2.ids);
            el.parent[2][el.parentIdx] = res.tree;
            restree.push({pos: t1.pos, ids: t1.ids});
            conflicts = conflicts || res.conflicts;
            merged = true;
          }
        } else {
          restree.push(branch);
        }
      }

      // We didnt find
      if (!merged) {
        restree.push(path);
      }

      restree.sort(sortByPos$1);

      return {
        tree: restree,
        conflicts: conflicts || 'internal_node'
      };
    }

    // To ensure we dont grow the revision tree infinitely, we stem old revisions
    function stem(tree, depth) {
      // First we break out the tree into a complete list of root to leaf paths
      var paths = rootToLeaf(tree);
      var stemmedRevs;

      var result;
      for (var i = 0, len = paths.length; i < len; i++) {
        // Then for each path, we cut off the start of the path based on the
        // `depth` to stem to, and generate a new set of flat trees
        var path = paths[i];
        var stemmed = path.ids;
        var node;
        if (stemmed.length > depth) {
          // only do the stemming work if we actually need to stem
          if (!stemmedRevs) {
            stemmedRevs = {}; // avoid allocating this object unnecessarily
          }
          var numStemmed = stemmed.length - depth;
          node = {
            pos: path.pos + numStemmed,
            ids: pathToTree(stemmed, numStemmed)
          };

          for (var s = 0; s < numStemmed; s++) {
            var rev = (path.pos + s) + '-' + stemmed[s].id;
            stemmedRevs[rev] = true;
          }
        } else { // no need to actually stem
          node = {
            pos: path.pos,
            ids: pathToTree(stemmed, 0)
          };
        }

        // Then we remerge all those flat trees together, ensuring that we dont
        // connect trees that would go beyond the depth limit
        if (result) {
          result = doMerge(result, node, true).tree;
        } else {
          result = [node];
        }
      }

      // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed
      if (stemmedRevs) {
        traverseRevTree(result, function (isLeaf, pos, revHash) {
          // some revisions may have been removed in a branch but not in another
          delete stemmedRevs[pos + '-' + revHash];
        });
      }

      return {
        tree: result,
        revs: stemmedRevs ? Object.keys(stemmedRevs) : []
      };
    }

    function merge(tree, path, depth) {
      var newTree = doMerge(tree, path);
      var stemmed = stem(newTree.tree, depth);
      return {
        tree: stemmed.tree,
        stemmedRevs: stemmed.revs,
        conflicts: newTree.conflicts
      };
    }

    // return true if a rev exists in the rev tree, false otherwise
    function revExists(revs, rev) {
      var toVisit = revs.slice();
      var splitRev = rev.split('-');
      var targetPos = parseInt(splitRev[0], 10);
      var targetId = splitRev[1];

      var node;
      while ((node = toVisit.pop())) {
        if (node.pos === targetPos && node.ids[0] === targetId) {
          return true;
        }
        var branches = node.ids[2];
        for (var i = 0, len = branches.length; i < len; i++) {
          toVisit.push({pos: node.pos + 1, ids: branches[i]});
        }
      }
      return false;
    }

    function getTrees(node) {
      return node.ids;
    }

    // check if a specific revision of a doc has been deleted
    //  - metadata: the metadata object from the doc store
    //  - rev: (optional) the revision to check. defaults to winning revision
    function isDeleted(metadata, rev) {
      if (!rev) {
        rev = winningRev(metadata);
      }
      var id = rev.substring(rev.indexOf('-') + 1);
      var toVisit = metadata.rev_tree.map(getTrees);

      var tree;
      while ((tree = toVisit.pop())) {
        if (tree[0] === id) {
          return !!tree[1].deleted;
        }
        toVisit = toVisit.concat(tree[2]);
      }
    }

    function isLocalId(id) {
      return (/^_local/).test(id);
    }

    // returns the current leaf node for a given revision
    function latest(rev, metadata) {
      var toVisit = metadata.rev_tree.slice();
      var node;
      while ((node = toVisit.pop())) {
        var pos = node.pos;
        var tree = node.ids;
        var id = tree[0];
        var opts = tree[1];
        var branches = tree[2];
        var isLeaf = branches.length === 0;

        var history = node.history ? node.history.slice() : [];
        history.push({id: id, pos: pos, opts: opts});

        if (isLeaf) {
          for (var i = 0, len = history.length; i < len; i++) {
            var historyNode = history[i];
            var historyRev = historyNode.pos + '-' + historyNode.id;

            if (historyRev === rev) {
              // return the rev of this leaf
              return pos + '-' + id;
            }
          }
        }

        for (var j = 0, l = branches.length; j < l; j++) {
          toVisit.push({pos: pos + 1, ids: branches[j], history: history});
        }
      }

      /* istanbul ignore next */
      throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);
    }

    inherits_browser(Changes$1, EventEmitter);

    function tryCatchInChangeListener(self, change, pending, lastSeq) {
      // isolate try/catches to avoid V8 deoptimizations
      try {
        self.emit('change', change, pending, lastSeq);
      } catch (e) {
        guardedConsole('error', 'Error in .on("change", function):', e);
      }
    }

    function Changes$1(db, opts, callback) {
      EventEmitter.call(this);
      var self = this;
      this.db = db;
      opts = opts ? clone(opts) : {};
      var complete = opts.complete = once$1(function (err, resp) {
        if (err) {
          if (listenerCount$1(self, 'error') > 0) {
            self.emit('error', err);
          }
        } else {
          self.emit('complete', resp);
        }
        self.removeAllListeners();
        db.removeListener('destroyed', onDestroy);
      });
      if (callback) {
        self.on('complete', function (resp) {
          callback(null, resp);
        });
        self.on('error', callback);
      }
      function onDestroy() {
        self.cancel();
      }
      db.once('destroyed', onDestroy);

      opts.onChange = function (change, pending, lastSeq) {
        /* istanbul ignore if */
        if (self.isCancelled) {
          return;
        }
        tryCatchInChangeListener(self, change, pending, lastSeq);
      };

      var promise = new Promise(function (fulfill, reject) {
        opts.complete = function (err, res) {
          if (err) {
            reject(err);
          } else {
            fulfill(res);
          }
        };
      });
      self.once('cancel', function () {
        db.removeListener('destroyed', onDestroy);
        opts.complete(null, {status: 'cancelled'});
      });
      this.then = promise.then.bind(promise);
      this['catch'] = promise['catch'].bind(promise);
      this.then(function (result) {
        complete(null, result);
      }, complete);



      if (!db.taskqueue.isReady) {
        db.taskqueue.addTask(function (failed) {
          if (failed) {
            opts.complete(failed);
          } else if (self.isCancelled) {
            self.emit('cancel');
          } else {
            self.validateChanges(opts);
          }
        });
      } else {
        self.validateChanges(opts);
      }
    }
    Changes$1.prototype.cancel = function () {
      this.isCancelled = true;
      if (this.db.taskqueue.isReady) {
        this.emit('cancel');
      }
    };
    function processChange(doc, metadata, opts) {
      var changeList = [{rev: doc._rev}];
      if (opts.style === 'all_docs') {
        changeList = collectLeaves(metadata.rev_tree)
        .map(function (x) { return {rev: x.rev}; });
      }
      var change = {
        id: metadata.id,
        changes: changeList,
        doc: doc
      };

      if (isDeleted(metadata, doc._rev)) {
        change.deleted = true;
      }
      if (opts.conflicts) {
        change.doc._conflicts = collectConflicts(metadata);
        if (!change.doc._conflicts.length) {
          delete change.doc._conflicts;
        }
      }
      return change;
    }

    Changes$1.prototype.validateChanges = function (opts) {
      var callback = opts.complete;
      var self = this;

      /* istanbul ignore else */
      if (PouchDB._changesFilterPlugin) {
        PouchDB._changesFilterPlugin.validate(opts, function (err) {
          if (err) {
            return callback(err);
          }
          self.doChanges(opts);
        });
      } else {
        self.doChanges(opts);
      }
    };

    Changes$1.prototype.doChanges = function (opts) {
      var self = this;
      var callback = opts.complete;

      opts = clone(opts);
      if ('live' in opts && !('continuous' in opts)) {
        opts.continuous = opts.live;
      }
      opts.processChange = processChange;

      if (opts.since === 'latest') {
        opts.since = 'now';
      }
      if (!opts.since) {
        opts.since = 0;
      }
      if (opts.since === 'now') {
        this.db.info().then(function (info) {
          /* istanbul ignore if */
          if (self.isCancelled) {
            callback(null, {status: 'cancelled'});
            return;
          }
          opts.since = info.update_seq;
          self.doChanges(opts);
        }, callback);
        return;
      }

      /* istanbul ignore else */
      if (PouchDB._changesFilterPlugin) {
        PouchDB._changesFilterPlugin.normalize(opts);
        if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {
          return PouchDB._changesFilterPlugin.filter(this, opts);
        }
      } else {
        ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {
          if (key in opts) {
            guardedConsole('warn',
              'The "' + key + '" option was passed in to changes/replicate, ' +
              'but pouchdb-changes-filter plugin is not installed, so it ' +
              'was ignored. Please install the plugin to enable filtering.'
            );
          }
        });
      }

      if (!('descending' in opts)) {
        opts.descending = false;
      }

      // 0 and 1 should return 1 document
      opts.limit = opts.limit === 0 ? 1 : opts.limit;
      opts.complete = callback;
      var newPromise = this.db._changes(opts);
      /* istanbul ignore else */
      if (newPromise && typeof newPromise.cancel === 'function') {
        var cancel = self.cancel;
        self.cancel = argsarray(function (args) {
          newPromise.cancel();
          cancel.apply(this, args);
        });
      }
    };

    /*
     * A generic pouch adapter
     */

    function compare(left, right) {
      return left < right ? -1 : left > right ? 1 : 0;
    }

    // Wrapper for functions that call the bulkdocs api with a single doc,
    // if the first result is an error, return an error
    function yankError(callback, docId) {
      return function (err, results) {
        if (err || (results[0] && results[0].error)) {
          err = err || results[0];
          err.docId = docId;
          callback(err);
        } else {
          callback(null, results.length ? results[0]  : results);
        }
      };
    }

    // clean docs given to us by the user
    function cleanDocs(docs) {
      for (var i = 0; i < docs.length; i++) {
        var doc = docs[i];
        if (doc._deleted) {
          delete doc._attachments; // ignore atts for deleted docs
        } else if (doc._attachments) {
          // filter out extraneous keys from _attachments
          var atts = Object.keys(doc._attachments);
          for (var j = 0; j < atts.length; j++) {
            var att = atts[j];
            doc._attachments[att] = pick(doc._attachments[att],
              ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);
          }
        }
      }
    }

    // compare two docs, first by _id then by _rev
    function compareByIdThenRev(a, b) {
      var idCompare = compare(a._id, b._id);
      if (idCompare !== 0) {
        return idCompare;
      }
      var aStart = a._revisions ? a._revisions.start : 0;
      var bStart = b._revisions ? b._revisions.start : 0;
      return compare(aStart, bStart);
    }

    // for every node in a revision tree computes its distance from the closest
    // leaf
    function computeHeight(revs) {
      var height = {};
      var edges = [];
      traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
        var rev$$1 = pos + "-" + id;
        if (isLeaf) {
          height[rev$$1] = 0;
        }
        if (prnt !== undefined) {
          edges.push({from: prnt, to: rev$$1});
        }
        return rev$$1;
      });

      edges.reverse();
      edges.forEach(function (edge) {
        if (height[edge.from] === undefined) {
          height[edge.from] = 1 + height[edge.to];
        } else {
          height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
        }
      });
      return height;
    }

    function allDocsKeysParse(opts) {
      var keys =  ('limit' in opts) ?
        opts.keys.slice(opts.skip, opts.limit + opts.skip) :
        (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;
      opts.keys = keys;
      opts.skip = 0;
      delete opts.limit;
      if (opts.descending) {
        keys.reverse();
        opts.descending = false;
      }
    }

    // all compaction is done in a queue, to avoid attaching
    // too many listeners at once
    function doNextCompaction(self) {
      var task = self._compactionQueue[0];
      var opts = task.opts;
      var callback = task.callback;
      self.get('_local/compaction').catch(function () {
        return false;
      }).then(function (doc) {
        if (doc && doc.last_seq) {
          opts.last_seq = doc.last_seq;
        }
        self._compact(opts, function (err, res) {
          /* istanbul ignore if */
          if (err) {
            callback(err);
          } else {
            callback(null, res);
          }
          lib(function () {
            self._compactionQueue.shift();
            if (self._compactionQueue.length) {
              doNextCompaction(self);
            }
          });
        });
      });
    }

    function attachmentNameError(name) {
      if (name.charAt(0) === '_') {
        return name + ' is not a valid attachment name, attachment ' +
          'names cannot start with \'_\'';
      }
      return false;
    }

    inherits_browser(AbstractPouchDB, EventEmitter);

    function AbstractPouchDB() {
      EventEmitter.call(this);

      // re-bind prototyped methods
      for (var p in AbstractPouchDB.prototype) {
        if (typeof this[p] === 'function') {
          this[p] = this[p].bind(this);
        }
      }
    }

    AbstractPouchDB.prototype.post =
      adapterFun('post', function (doc, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      if (typeof doc !== 'object' || Array.isArray(doc)) {
        return callback(createError(NOT_AN_OBJECT));
      }
      this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));
    });

    AbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      if (typeof doc !== 'object' || Array.isArray(doc)) {
        return cb(createError(NOT_AN_OBJECT));
      }
      invalidIdError(doc._id);
      if (isLocalId(doc._id) && typeof this._putLocal === 'function') {
        if (doc._deleted) {
          return this._removeLocal(doc, cb);
        } else {
          return this._putLocal(doc, cb);
        }
      }
      var self = this;
      if (opts.force && doc._rev) {
        transformForceOptionToNewEditsOption();
        putDoc(function (err) {
          var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};
          cb(err, result);
        });
      } else {
        putDoc(cb);
      }

      function transformForceOptionToNewEditsOption() {
        var parts = doc._rev.split('-');
        var oldRevId = parts[1];
        var oldRevNum = parseInt(parts[0], 10);

        var newRevNum = oldRevNum + 1;
        var newRevId = rev();

        doc._revisions = {
          start: newRevNum,
          ids: [newRevId, oldRevId]
        };
        doc._rev = newRevNum + '-' + newRevId;
        opts.new_edits = false;
      }
      function putDoc(next) {
        if (typeof self._put === 'function' && opts.new_edits !== false) {
          self._put(doc, opts, next);
        } else {
          self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));
        }
      }
    });

    AbstractPouchDB.prototype.putAttachment =
      adapterFun('putAttachment', function (docId, attachmentId, rev$$1,
                                                  blob, type) {
      var api = this;
      if (typeof type === 'function') {
        type = blob;
        blob = rev$$1;
        rev$$1 = null;
      }
      // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267
      /* istanbul ignore if */
      if (typeof type === 'undefined') {
        type = blob;
        blob = rev$$1;
        rev$$1 = null;
      }
      if (!type) {
        guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');
      }

      function createAttachment(doc) {
        var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;
        doc._attachments = doc._attachments || {};
        doc._attachments[attachmentId] = {
          content_type: type,
          data: blob,
          revpos: ++prevrevpos
        };
        return api.put(doc);
      }

      return api.get(docId).then(function (doc) {
        if (doc._rev !== rev$$1) {
          throw createError(REV_CONFLICT);
        }

        return createAttachment(doc);
      }, function (err) {
         // create new doc
        /* istanbul ignore else */
        if (err.reason === MISSING_DOC.message) {
          return createAttachment({_id: docId});
        } else {
          throw err;
        }
      });
    });

    AbstractPouchDB.prototype.removeAttachment =
      adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,
                                                     callback) {
      var self = this;
      self.get(docId, function (err, obj) {
        /* istanbul ignore if */
        if (err) {
          callback(err);
          return;
        }
        if (obj._rev !== rev$$1) {
          callback(createError(REV_CONFLICT));
          return;
        }
        /* istanbul ignore if */
        if (!obj._attachments) {
          return callback();
        }
        delete obj._attachments[attachmentId];
        if (Object.keys(obj._attachments).length === 0) {
          delete obj._attachments;
        }
        self.put(obj, callback);
      });
    });

    AbstractPouchDB.prototype.remove =
      adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
      var doc;
      if (typeof optsOrRev === 'string') {
        // id, rev, opts, callback style
        doc = {
          _id: docOrId,
          _rev: optsOrRev
        };
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
      } else {
        // doc, opts, callback style
        doc = docOrId;
        if (typeof optsOrRev === 'function') {
          callback = optsOrRev;
          opts = {};
        } else {
          callback = opts;
          opts = optsOrRev;
        }
      }
      opts = opts || {};
      opts.was_delete = true;
      var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};
      newDoc._deleted = true;
      if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
        return this._removeLocal(doc, callback);
      }
      this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));
    });

    AbstractPouchDB.prototype.revsDiff =
      adapterFun('revsDiff', function (req, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      var ids = Object.keys(req);

      if (!ids.length) {
        return callback(null, {});
      }

      var count = 0;
      var missing = new ExportedMap();

      function addToMissing(id, revId) {
        if (!missing.has(id)) {
          missing.set(id, {missing: []});
        }
        missing.get(id).missing.push(revId);
      }

      function processDoc(id, rev_tree) {
        // Is this fast enough? Maybe we should switch to a set simulated by a map
        var missingForId = req[id].slice(0);
        traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,
          opts) {
            var rev$$1 = pos + '-' + revHash;
            var idx = missingForId.indexOf(rev$$1);
            if (idx === -1) {
              return;
            }

            missingForId.splice(idx, 1);
            /* istanbul ignore if */
            if (opts.status !== 'available') {
              addToMissing(id, rev$$1);
            }
          });

        // Traversing the tree is synchronous, so now `missingForId` contains
        // revisions that were not found in the tree
        missingForId.forEach(function (rev$$1) {
          addToMissing(id, rev$$1);
        });
      }

      ids.map(function (id) {
        this._getRevisionTree(id, function (err, rev_tree) {
          if (err && err.status === 404 && err.message === 'missing') {
            missing.set(id, {missing: req[id]});
          } else if (err) {
            /* istanbul ignore next */
            return callback(err);
          } else {
            processDoc(id, rev_tree);
          }

          if (++count === ids.length) {
            // convert LazyMap to object
            var missingObj = {};
            missing.forEach(function (value, key) {
              missingObj[key] = value;
            });
            return callback(null, missingObj);
          }
        });
      }, this);
    });

    // _bulk_get API for faster replication, as described in
    // https://github.com/apache/couchdb-chttpd/pull/33
    // At the "abstract" level, it will just run multiple get()s in
    // parallel, because this isn't much of a performance cost
    // for local databases (except the cost of multiple transactions, which is
    // small). The http adapter overrides this in order
    // to do a more efficient single HTTP request.
    AbstractPouchDB.prototype.bulkGet =
      adapterFun('bulkGet', function (opts, callback) {
      bulkGet(this, opts, callback);
    });

    // compact one document and fire callback
    // by compacting we mean removing all revisions which
    // are further from the leaf in revision tree than max_height
    AbstractPouchDB.prototype.compactDocument =
      adapterFun('compactDocument', function (docId, maxHeight, callback) {
      var self = this;
      this._getRevisionTree(docId, function (err, revTree) {
        /* istanbul ignore if */
        if (err) {
          return callback(err);
        }
        var height = computeHeight(revTree);
        var candidates = [];
        var revs = [];
        Object.keys(height).forEach(function (rev$$1) {
          if (height[rev$$1] > maxHeight) {
            candidates.push(rev$$1);
          }
        });

        traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
          var rev$$1 = pos + '-' + revHash;
          if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {
            revs.push(rev$$1);
          }
        });
        self._doCompaction(docId, revs, callback);
      });
    });

    // compact the whole database using single document
    // compaction
    AbstractPouchDB.prototype.compact =
      adapterFun('compact', function (opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var self = this;
      opts = opts || {};

      self._compactionQueue = self._compactionQueue || [];
      self._compactionQueue.push({opts: opts, callback: callback});
      if (self._compactionQueue.length === 1) {
        doNextCompaction(self);
      }
    });
    AbstractPouchDB.prototype._compact = function (opts, callback) {
      var self = this;
      var changesOpts = {
        return_docs: false,
        last_seq: opts.last_seq || 0
      };
      var promises = [];

      function onChange(row) {
        promises.push(self.compactDocument(row.id, 0));
      }
      function onComplete(resp) {
        var lastSeq = resp.last_seq;
        Promise.all(promises).then(function () {
          return upsert(self, '_local/compaction', function deltaFunc(doc) {
            if (!doc.last_seq || doc.last_seq < lastSeq) {
              doc.last_seq = lastSeq;
              return doc;
            }
            return false; // somebody else got here first, don't update
          });
        }).then(function () {
          callback(null, {ok: true});
        }).catch(callback);
      }
      self.changes(changesOpts)
        .on('change', onChange)
        .on('complete', onComplete)
        .on('error', callback);
    };

    /* Begin api wrappers. Specific functionality to storage belongs in the
       _[method] */
    AbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      if (typeof id !== 'string') {
        return cb(createError(INVALID_ID));
      }
      if (isLocalId(id) && typeof this._getLocal === 'function') {
        return this._getLocal(id, cb);
      }
      var leaves = [], self = this;

      function finishOpenRevs() {
        var result = [];
        var count = leaves.length;
        /* istanbul ignore if */
        if (!count) {
          return cb(null, result);
        }

        // order with open_revs is unspecified
        leaves.forEach(function (leaf) {
          self.get(id, {
            rev: leaf,
            revs: opts.revs,
            latest: opts.latest,
            attachments: opts.attachments,
            binary: opts.binary
          }, function (err, doc) {
            if (!err) {
              // using latest=true can produce duplicates
              var existing;
              for (var i = 0, l = result.length; i < l; i++) {
                if (result[i].ok && result[i].ok._rev === doc._rev) {
                  existing = true;
                  break;
                }
              }
              if (!existing) {
                result.push({ok: doc});
              }
            } else {
              result.push({missing: leaf});
            }
            count--;
            if (!count) {
              cb(null, result);
            }
          });
        });
      }

      if (opts.open_revs) {
        if (opts.open_revs === "all") {
          this._getRevisionTree(id, function (err, rev_tree) {
            /* istanbul ignore if */
            if (err) {
              return cb(err);
            }
            leaves = collectLeaves(rev_tree).map(function (leaf) {
              return leaf.rev;
            });
            finishOpenRevs();
          });
        } else {
          if (Array.isArray(opts.open_revs)) {
            leaves = opts.open_revs;
            for (var i = 0; i < leaves.length; i++) {
              var l = leaves[i];
              // looks like it's the only thing couchdb checks
              if (!(typeof (l) === "string" && /^\d+-/.test(l))) {
                return cb(createError(INVALID_REV));
              }
            }
            finishOpenRevs();
          } else {
            return cb(createError(UNKNOWN_ERROR, 'function_clause'));
          }
        }
        return; // open_revs does not like other options
      }

      return this._get(id, opts, function (err, result) {
        if (err) {
          err.docId = id;
          return cb(err);
        }

        var doc = result.doc;
        var metadata = result.metadata;
        var ctx = result.ctx;

        if (opts.conflicts) {
          var conflicts = collectConflicts(metadata);
          if (conflicts.length) {
            doc._conflicts = conflicts;
          }
        }

        if (isDeleted(metadata, doc._rev)) {
          doc._deleted = true;
        }

        if (opts.revs || opts.revs_info) {
          var splittedRev = doc._rev.split('-');
          var revNo       = parseInt(splittedRev[0], 10);
          var revHash     = splittedRev[1];

          var paths = rootToLeaf(metadata.rev_tree);
          var path = null;

          for (var i = 0; i < paths.length; i++) {
            var currentPath = paths[i];
            var hashIndex = currentPath.ids.map(function (x) { return x.id; })
              .indexOf(revHash);
            var hashFoundAtRevPos = hashIndex === (revNo - 1);

            if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {
              path = currentPath;
            }
          }

          /* istanbul ignore if */
          if (!path) {
            err = new Error('invalid rev tree');
            err.docId = id;
            return cb(err);
          }

          var indexOfRev = path.ids.map(function (x) { return x.id; })
            .indexOf(doc._rev.split('-')[1]) + 1;
          var howMany = path.ids.length - indexOfRev;
          path.ids.splice(indexOfRev, howMany);
          path.ids.reverse();

          if (opts.revs) {
            doc._revisions = {
              start: (path.pos + path.ids.length) - 1,
              ids: path.ids.map(function (rev$$1) {
                return rev$$1.id;
              })
            };
          }
          if (opts.revs_info) {
            var pos =  path.pos + path.ids.length;
            doc._revs_info = path.ids.map(function (rev$$1) {
              pos--;
              return {
                rev: pos + '-' + rev$$1.id,
                status: rev$$1.opts.status
              };
            });
          }
        }

        if (opts.attachments && doc._attachments) {
          var attachments = doc._attachments;
          var count = Object.keys(attachments).length;
          if (count === 0) {
            return cb(null, doc);
          }
          Object.keys(attachments).forEach(function (key) {
            this._getAttachment(doc._id, key, attachments[key], {
              // Previously the revision handling was done in adapter.js
              // getAttachment, however since idb-next doesnt we need to
              // pass the rev through
              rev: doc._rev,
              binary: opts.binary,
              ctx: ctx
            }, function (err, data) {
              var att = doc._attachments[key];
              att.data = data;
              delete att.stub;
              delete att.length;
              if (!--count) {
                cb(null, doc);
              }
            });
          }, self);
        } else {
          if (doc._attachments) {
            for (var key in doc._attachments) {
              /* istanbul ignore else */
              if (doc._attachments.hasOwnProperty(key)) {
                doc._attachments[key].stub = true;
              }
            }
          }
          cb(null, doc);
        }
      });
    });

    // TODO: I dont like this, it forces an extra read for every
    // attachment read and enforces a confusing api between
    // adapter.js and the adapter implementation
    AbstractPouchDB.prototype.getAttachment =
      adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {
      var self = this;
      if (opts instanceof Function) {
        callback = opts;
        opts = {};
      }
      this._get(docId, opts, function (err, res) {
        if (err) {
          return callback(err);
        }
        if (res.doc._attachments && res.doc._attachments[attachmentId]) {
          opts.ctx = res.ctx;
          opts.binary = true;
          self._getAttachment(docId, attachmentId,
                              res.doc._attachments[attachmentId], opts, callback);
        } else {
          return callback(createError(MISSING_DOC));
        }
      });
    });

    AbstractPouchDB.prototype.allDocs =
      adapterFun('allDocs', function (opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
      if (opts.start_key) {
        opts.startkey = opts.start_key;
      }
      if (opts.end_key) {
        opts.endkey = opts.end_key;
      }
      if ('keys' in opts) {
        if (!Array.isArray(opts.keys)) {
          return callback(new TypeError('options.keys must be an array'));
        }
        var incompatibleOpt =
          ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
          return incompatibleOpt in opts;
        })[0];
        if (incompatibleOpt) {
          callback(createError(QUERY_PARSE_ERROR,
            'Query parameter `' + incompatibleOpt +
            '` is not compatible with multi-get'
          ));
          return;
        }
        if (!isRemote(this)) {
          allDocsKeysParse(opts);
          if (opts.keys.length === 0) {
            return this._allDocs({limit: 0}, callback);
          }
        }
      }

      return this._allDocs(opts, callback);
    });

    AbstractPouchDB.prototype.changes = function (opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      opts = opts || {};

      // By default set return_docs to false if the caller has opts.live = true,
      // this will prevent us from collecting the set of changes indefinitely
      // resulting in growing memory
      opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;

      return new Changes$1(this, opts, callback);
    };

    AbstractPouchDB.prototype.close = adapterFun('close', function (callback) {
      this._closed = true;
      this.emit('closed');
      return this._close(callback);
    });

    AbstractPouchDB.prototype.info = adapterFun('info', function (callback) {
      var self = this;
      this._info(function (err, info) {
        if (err) {
          return callback(err);
        }
        // assume we know better than the adapter, unless it informs us
        info.db_name = info.db_name || self.name;
        info.auto_compaction = !!(self.auto_compaction && !isRemote(self));
        info.adapter = self.adapter;
        callback(null, info);
      });
    });

    AbstractPouchDB.prototype.id = adapterFun('id', function (callback) {
      return this._id(callback);
    });

    /* istanbul ignore next */
    AbstractPouchDB.prototype.type = function () {
      return (typeof this._type === 'function') ? this._type() : this.adapter;
    };

    AbstractPouchDB.prototype.bulkDocs =
      adapterFun('bulkDocs', function (req, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      opts = opts || {};

      if (Array.isArray(req)) {
        req = {
          docs: req
        };
      }

      if (!req || !req.docs || !Array.isArray(req.docs)) {
        return callback(createError(MISSING_BULK_DOCS));
      }

      for (var i = 0; i < req.docs.length; ++i) {
        if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
          return callback(createError(NOT_AN_OBJECT));
        }
      }

      var attachmentError;
      req.docs.forEach(function (doc) {
        if (doc._attachments) {
          Object.keys(doc._attachments).forEach(function (name) {
            attachmentError = attachmentError || attachmentNameError(name);
            if (!doc._attachments[name].content_type) {
              guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');
            }
          });
        }
      });

      if (attachmentError) {
        return callback(createError(BAD_REQUEST, attachmentError));
      }

      if (!('new_edits' in opts)) {
        if ('new_edits' in req) {
          opts.new_edits = req.new_edits;
        } else {
          opts.new_edits = true;
        }
      }

      var adapter = this;
      if (!opts.new_edits && !isRemote(adapter)) {
        // ensure revisions of the same doc are sorted, so that
        // the local adapter processes them correctly (#2935)
        req.docs.sort(compareByIdThenRev);
      }

      cleanDocs(req.docs);

      // in the case of conflicts, we want to return the _ids to the user
      // however, the underlying adapter may destroy the docs array, so
      // create a copy here
      var ids = req.docs.map(function (doc) {
        return doc._id;
      });

      return this._bulkDocs(req, opts, function (err, res) {
        if (err) {
          return callback(err);
        }
        if (!opts.new_edits) {
          // this is what couch does when new_edits is false
          res = res.filter(function (x) {
            return x.error;
          });
        }
        // add ids for error/conflict responses (not required for CouchDB)
        if (!isRemote(adapter)) {
          for (var i = 0, l = res.length; i < l; i++) {
            res[i].id = res[i].id || ids[i];
          }
        }

        callback(null, res);
      });
    });

    AbstractPouchDB.prototype.registerDependentDatabase =
      adapterFun('registerDependentDatabase', function (dependentDb,
                                                              callback) {
      var depDB = new this.constructor(dependentDb, this.__opts);

      function diffFun(doc) {
        doc.dependentDbs = doc.dependentDbs || {};
        if (doc.dependentDbs[dependentDb]) {
          return false; // no update required
        }
        doc.dependentDbs[dependentDb] = true;
        return doc;
      }
      upsert(this, '_local/_pouch_dependentDbs', diffFun)
        .then(function () {
          callback(null, {db: depDB});
        }).catch(callback);
    });

    AbstractPouchDB.prototype.destroy =
      adapterFun('destroy', function (opts, callback) {

      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }

      var self = this;
      var usePrefix = 'use_prefix' in self ? self.use_prefix : true;

      function destroyDb() {
        // call destroy method of the particular adaptor
        self._destroy(opts, function (err, resp) {
          if (err) {
            return callback(err);
          }
          self._destroyed = true;
          self.emit('destroyed');
          callback(null, resp || { 'ok': true });
        });
      }

      if (isRemote(self)) {
        // no need to check for dependent DBs if it's a remote DB
        return destroyDb();
      }

      self.get('_local/_pouch_dependentDbs', function (err, localDoc) {
        if (err) {
          /* istanbul ignore if */
          if (err.status !== 404) {
            return callback(err);
          } else { // no dependencies
            return destroyDb();
          }
        }
        var dependentDbs = localDoc.dependentDbs;
        var PouchDB = self.constructor;
        var deletedMap = Object.keys(dependentDbs).map(function (name) {
          // use_prefix is only false in the browser
          /* istanbul ignore next */
          var trueName = usePrefix ?
            name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
          return new PouchDB(trueName, self.__opts).destroy();
        });
        Promise.all(deletedMap).then(destroyDb, callback);
      });
    });

    function TaskQueue() {
      this.isReady = false;
      this.failed = false;
      this.queue = [];
    }

    TaskQueue.prototype.execute = function () {
      var fun;
      if (this.failed) {
        while ((fun = this.queue.shift())) {
          fun(this.failed);
        }
      } else {
        while ((fun = this.queue.shift())) {
          fun();
        }
      }
    };

    TaskQueue.prototype.fail = function (err) {
      this.failed = err;
      this.execute();
    };

    TaskQueue.prototype.ready = function (db) {
      this.isReady = true;
      this.db = db;
      this.execute();
    };

    TaskQueue.prototype.addTask = function (fun) {
      this.queue.push(fun);
      if (this.failed) {
        this.execute();
      }
    };

    function parseAdapter(name, opts) {
      var match = name.match(/([a-z-]*):\/\/(.*)/);
      if (match) {
        // the http adapter expects the fully qualified name
        return {
          name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],
          adapter: match[1]
        };
      }

      var adapters = PouchDB.adapters;
      var preferredAdapters = PouchDB.preferredAdapters;
      var prefix = PouchDB.prefix;
      var adapterName = opts.adapter;

      if (!adapterName) { // automatically determine adapter
        for (var i = 0; i < preferredAdapters.length; ++i) {
          adapterName = preferredAdapters[i];
          // check for browsers that have been upgraded from websql-only to websql+idb
          /* istanbul ignore if */
          if (adapterName === 'idb' && 'websql' in adapters &&
              hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {
            // log it, because this can be confusing during development
            guardedConsole('log', 'PouchDB is downgrading "' + name + '" to WebSQL to' +
              ' avoid data loss, because it was already opened with WebSQL.');
            continue; // keep using websql to avoid user data loss
          }
          break;
        }
      }

      var adapter = adapters[adapterName];

      // if adapter is invalid, then an error will be thrown later
      var usePrefix = (adapter && 'use_prefix' in adapter) ?
        adapter.use_prefix : true;

      return {
        name: usePrefix ? (prefix + name) : name,
        adapter: adapterName
      };
    }

    // OK, so here's the deal. Consider this code:
    //     var db1 = new PouchDB('foo');
    //     var db2 = new PouchDB('foo');
    //     db1.destroy();
    // ^ these two both need to emit 'destroyed' events,
    // as well as the PouchDB constructor itself.
    // So we have one db object (whichever one got destroy() called on it)
    // responsible for emitting the initial event, which then gets emitted
    // by the constructor, which then broadcasts it to any other dbs
    // that may have been created with the same name.
    function prepareForDestruction(self) {

      function onDestroyed(from_constructor) {
        self.removeListener('closed', onClosed);
        if (!from_constructor) {
          self.constructor.emit('destroyed', self.name);
        }
      }

      function onClosed() {
        self.removeListener('destroyed', onDestroyed);
        self.constructor.emit('unref', self);
      }

      self.once('destroyed', onDestroyed);
      self.once('closed', onClosed);
      self.constructor.emit('ref', self);
    }

    inherits_browser(PouchDB, AbstractPouchDB);
    function PouchDB(name, opts) {
      // In Node our test suite only tests this for PouchAlt unfortunately
      /* istanbul ignore if */
      if (!(this instanceof PouchDB)) {
        return new PouchDB(name, opts);
      }

      var self = this;
      opts = opts || {};

      if (name && typeof name === 'object') {
        opts = name;
        name = opts.name;
        delete opts.name;
      }

      if (opts.deterministic_revs === undefined) {
        opts.deterministic_revs = true;
      }

      this.__opts = opts = clone(opts);

      self.auto_compaction = opts.auto_compaction;
      self.prefix = PouchDB.prefix;

      if (typeof name !== 'string') {
        throw new Error('Missing/invalid DB name');
      }

      var prefixedName = (opts.prefix || '') + name;
      var backend = parseAdapter(prefixedName, opts);

      opts.name = backend.name;
      opts.adapter = opts.adapter || backend.adapter;

      self.name = name;
      self._adapter = opts.adapter;
      PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);

      if (!PouchDB.adapters[opts.adapter] ||
          !PouchDB.adapters[opts.adapter].valid()) {
        throw new Error('Invalid Adapter: ' + opts.adapter);
      }

      AbstractPouchDB.call(self);
      self.taskqueue = new TaskQueue();

      self.adapter = opts.adapter;

      PouchDB.adapters[opts.adapter].call(self, opts, function (err) {
        if (err) {
          return self.taskqueue.fail(err);
        }
        prepareForDestruction(self);

        self.emit('created', self);
        PouchDB.emit('created', self.name);
        self.taskqueue.ready(self);
      });

    }

    // AbortController was introduced quite a while after fetch and
    // isnt required for PouchDB to function so polyfill if needed
    var a = (typeof AbortController !== 'undefined')
        ? AbortController
        : function () { return {abort: function () {}}; };

    var f$1 = fetch;
    var h = Headers;

    PouchDB.adapters = {};
    PouchDB.preferredAdapters = [];

    PouchDB.prefix = '_pouch_';

    var eventEmitter = new EventEmitter();

    function setUpEventEmitter(Pouch) {
      Object.keys(EventEmitter.prototype).forEach(function (key) {
        if (typeof EventEmitter.prototype[key] === 'function') {
          Pouch[key] = eventEmitter[key].bind(eventEmitter);
        }
      });

      // these are created in constructor.js, and allow us to notify each DB with
      // the same name that it was destroyed, via the constructor object
      var destructListeners = Pouch._destructionListeners = new ExportedMap();

      Pouch.on('ref', function onConstructorRef(db) {
        if (!destructListeners.has(db.name)) {
          destructListeners.set(db.name, []);
        }
        destructListeners.get(db.name).push(db);
      });

      Pouch.on('unref', function onConstructorUnref(db) {
        if (!destructListeners.has(db.name)) {
          return;
        }
        var dbList = destructListeners.get(db.name);
        var pos = dbList.indexOf(db);
        if (pos < 0) {
          /* istanbul ignore next */
          return;
        }
        dbList.splice(pos, 1);
        if (dbList.length > 1) {
          /* istanbul ignore next */
          destructListeners.set(db.name, dbList);
        } else {
          destructListeners.delete(db.name);
        }
      });

      Pouch.on('destroyed', function onConstructorDestroyed(name) {
        if (!destructListeners.has(name)) {
          return;
        }
        var dbList = destructListeners.get(name);
        destructListeners.delete(name);
        dbList.forEach(function (db) {
          db.emit('destroyed',true);
        });
      });
    }

    setUpEventEmitter(PouchDB);

    PouchDB.adapter = function (id, obj, addToPreferredAdapters) {
      /* istanbul ignore else */
      if (obj.valid()) {
        PouchDB.adapters[id] = obj;
        if (addToPreferredAdapters) {
          PouchDB.preferredAdapters.push(id);
        }
      }
    };

    PouchDB.plugin = function (obj) {
      if (typeof obj === 'function') { // function style for plugins
        obj(PouchDB);
      } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {
        throw new Error('Invalid plugin: got "' + obj + '", expected an object or a function');
      } else {
        Object.keys(obj).forEach(function (id) { // object style for plugins
          PouchDB.prototype[id] = obj[id];
        });
      }
      if (this.__defaults) {
        PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);
      }
      return PouchDB;
    };

    PouchDB.defaults = function (defaultOpts) {
      function PouchAlt(name, opts) {
        if (!(this instanceof PouchAlt)) {
          return new PouchAlt(name, opts);
        }

        opts = opts || {};

        if (name && typeof name === 'object') {
          opts = name;
          name = opts.name;
          delete opts.name;
        }

        opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);
        PouchDB.call(this, name, opts);
      }

      inherits_browser(PouchAlt, PouchDB);

      PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();
      Object.keys(PouchDB).forEach(function (key) {
        if (!(key in PouchAlt)) {
          PouchAlt[key] = PouchDB[key];
        }
      });

      // make default options transitive
      // https://github.com/pouchdb/pouchdb/issues/5922
      PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);

      return PouchAlt;
    };

    PouchDB.fetch = function (url, opts) {
      return f$1(url, opts);
    };

    // managed automatically by set-version.js
    var version$1 = "7.2.2";

    // this would just be "return doc[field]", but fields
    // can be "deep" due to dot notation
    function getFieldFromDoc(doc, parsedField) {
      var value = doc;
      for (var i = 0, len = parsedField.length; i < len; i++) {
        var key = parsedField[i];
        value = value[key];
        if (!value) {
          break;
        }
      }
      return value;
    }

    function compare$1(left, right) {
      return left < right ? -1 : left > right ? 1 : 0;
    }

    // Converts a string in dot notation to an array of its components, with backslash escaping
    function parseField(fieldName) {
      // fields may be deep (e.g. "foo.bar.baz"), so parse
      var fields = [];
      var current = '';
      for (var i = 0, len = fieldName.length; i < len; i++) {
        var ch = fieldName[i];
        if (ch === '.') {
          if (i > 0 && fieldName[i - 1] === '\\') { // escaped delimiter
            current = current.substring(0, current.length - 1) + '.';
          } else { // not escaped, so delimiter
            fields.push(current);
            current = '';
          }
        } else { // normal character
          current += ch;
        }
      }
      fields.push(current);
      return fields;
    }

    var combinationFields = ['$or', '$nor', '$not'];
    function isCombinationalField(field) {
      return combinationFields.indexOf(field) > -1;
    }

    function getKey(obj) {
      return Object.keys(obj)[0];
    }

    function getValue(obj) {
      return obj[getKey(obj)];
    }


    // flatten an array of selectors joined by an $and operator
    function mergeAndedSelectors(selectors) {

      // sort to ensure that e.g. if the user specified
      // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into
      // just {$gt: 'b'}
      var res = {};

      selectors.forEach(function (selector) {
        Object.keys(selector).forEach(function (field) {
          var matcher = selector[field];
          if (typeof matcher !== 'object') {
            matcher = {$eq: matcher};
          }

          if (isCombinationalField(field)) {
            if (matcher instanceof Array) {
              res[field] = matcher.map(function (m) {
                return mergeAndedSelectors([m]);
              });
            } else {
              res[field] = mergeAndedSelectors([matcher]);
            }
          } else {
            var fieldMatchers = res[field] = res[field] || {};
            Object.keys(matcher).forEach(function (operator) {
              var value = matcher[operator];

              if (operator === '$gt' || operator === '$gte') {
                return mergeGtGte(operator, value, fieldMatchers);
              } else if (operator === '$lt' || operator === '$lte') {
                return mergeLtLte(operator, value, fieldMatchers);
              } else if (operator === '$ne') {
                return mergeNe(value, fieldMatchers);
              } else if (operator === '$eq') {
                return mergeEq(value, fieldMatchers);
              }
              fieldMatchers[operator] = value;
            });
          }
        });
      });

      return res;
    }



    // collapse logically equivalent gt/gte values
    function mergeGtGte(operator, value, fieldMatchers) {
      if (typeof fieldMatchers.$eq !== 'undefined') {
        return; // do nothing
      }
      if (typeof fieldMatchers.$gte !== 'undefined') {
        if (operator === '$gte') {
          if (value > fieldMatchers.$gte) { // more specificity
            fieldMatchers.$gte = value;
          }
        } else { // operator === '$gt'
          if (value >= fieldMatchers.$gte) { // more specificity
            delete fieldMatchers.$gte;
            fieldMatchers.$gt = value;
          }
        }
      } else if (typeof fieldMatchers.$gt !== 'undefined') {
        if (operator === '$gte') {
          if (value > fieldMatchers.$gt) { // more specificity
            delete fieldMatchers.$gt;
            fieldMatchers.$gte = value;
          }
        } else { // operator === '$gt'
          if (value > fieldMatchers.$gt) { // more specificity
            fieldMatchers.$gt = value;
          }
        }
      } else {
        fieldMatchers[operator] = value;
      }
    }

    // collapse logically equivalent lt/lte values
    function mergeLtLte(operator, value, fieldMatchers) {
      if (typeof fieldMatchers.$eq !== 'undefined') {
        return; // do nothing
      }
      if (typeof fieldMatchers.$lte !== 'undefined') {
        if (operator === '$lte') {
          if (value < fieldMatchers.$lte) { // more specificity
            fieldMatchers.$lte = value;
          }
        } else { // operator === '$gt'
          if (value <= fieldMatchers.$lte) { // more specificity
            delete fieldMatchers.$lte;
            fieldMatchers.$lt = value;
          }
        }
      } else if (typeof fieldMatchers.$lt !== 'undefined') {
        if (operator === '$lte') {
          if (value < fieldMatchers.$lt) { // more specificity
            delete fieldMatchers.$lt;
            fieldMatchers.$lte = value;
          }
        } else { // operator === '$gt'
          if (value < fieldMatchers.$lt) { // more specificity
            fieldMatchers.$lt = value;
          }
        }
      } else {
        fieldMatchers[operator] = value;
      }
    }

    // combine $ne values into one array
    function mergeNe(value, fieldMatchers) {
      if ('$ne' in fieldMatchers) {
        // there are many things this could "not" be
        fieldMatchers.$ne.push(value);
      } else { // doesn't exist yet
        fieldMatchers.$ne = [value];
      }
    }

    // add $eq into the mix
    function mergeEq(value, fieldMatchers) {
      // these all have less specificity than the $eq
      // TODO: check for user errors here
      delete fieldMatchers.$gt;
      delete fieldMatchers.$gte;
      delete fieldMatchers.$lt;
      delete fieldMatchers.$lte;
      delete fieldMatchers.$ne;
      fieldMatchers.$eq = value;
    }

    //#7458: execute function mergeAndedSelectors on nested $and
    function mergeAndedSelectorsNested(obj) {
        for (var prop in obj) {
            if (Array.isArray(obj)) {
                for (var i in obj) {
                    if (obj[i]['$and']) {
                        obj[i] = mergeAndedSelectors(obj[i]['$and']);
                    }
                }
            }
            var value = obj[prop];
            if (typeof value === 'object') {
                mergeAndedSelectorsNested(value); // <- recursive call
            }
        }
        return obj;
    }

    //#7458: determine id $and is present in selector (at any level)
    function isAndInSelector(obj, isAnd) {
        for (var prop in obj) {
            if (prop === '$and') {
                isAnd = true;
            }
            var value = obj[prop];
            if (typeof value === 'object') {
                isAnd = isAndInSelector(value, isAnd); // <- recursive call
            }
        }
        return isAnd;
    }

    //
    // normalize the selector
    //
    function massageSelector(input) {
      var result = clone(input);
      var wasAnded = false;
        //#7458: if $and is present in selector (at any level) merge nested $and
        if (isAndInSelector(result, false)) {
            result = mergeAndedSelectorsNested(result);
            if ('$and' in result) {
                result = mergeAndedSelectors(result['$and']);
            }
            wasAnded = true;
        }

      ['$or', '$nor'].forEach(function (orOrNor) {
        if (orOrNor in result) {
          // message each individual selector
          // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}
          result[orOrNor].forEach(function (subSelector) {
            var fields = Object.keys(subSelector);
            for (var i = 0; i < fields.length; i++) {
              var field = fields[i];
              var matcher = subSelector[field];
              if (typeof matcher !== 'object' || matcher === null) {
                subSelector[field] = {$eq: matcher};
              }
            }
          });
        }
      });

      if ('$not' in result) {
        //This feels a little like forcing, but it will work for now,
        //I would like to come back to this and make the merging of selectors a little more generic
        result['$not'] = mergeAndedSelectors([result['$not']]);
      }

      var fields = Object.keys(result);

      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        var matcher = result[field];

        if (typeof matcher !== 'object' || matcher === null) {
          matcher = {$eq: matcher};
        } else if ('$ne' in matcher && !wasAnded) {
          // I put these in an array, since there may be more than one
          // but in the "mergeAnded" operation, I already take care of that
          matcher.$ne = [matcher.$ne];
        }
        result[field] = matcher;
      }

      return result;
    }

    function pad(str, padWith, upToLength) {
      var padding = '';
      var targetLength = upToLength - str.length;
      /* istanbul ignore next */
      while (padding.length < targetLength) {
        padding += padWith;
      }
      return padding;
    }

    function padLeft(str, padWith, upToLength) {
      var padding = pad(str, padWith, upToLength);
      return padding + str;
    }

    var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
    var MAGNITUDE_DIGITS = 3; // ditto
    var SEP = ''; // set to '_' for easier debugging 

    function collate(a, b) {

      if (a === b) {
        return 0;
      }

      a = normalizeKey(a);
      b = normalizeKey(b);

      var ai = collationIndex(a);
      var bi = collationIndex(b);
      if ((ai - bi) !== 0) {
        return ai - bi;
      }
      switch (typeof a) {
        case 'number':
          return a - b;
        case 'boolean':
          return a < b ? -1 : 1;
        case 'string':
          return stringCollate(a, b);
      }
      return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
    }

    // couch considers null/NaN/Infinity/-Infinity === undefined,
    // for the purposes of mapreduce indexes. also, dates get stringified.
    function normalizeKey(key) {
      switch (typeof key) {
        case 'undefined':
          return null;
        case 'number':
          if (key === Infinity || key === -Infinity || isNaN(key)) {
            return null;
          }
          return key;
        case 'object':
          var origKey = key;
          if (Array.isArray(key)) {
            var len = key.length;
            key = new Array(len);
            for (var i = 0; i < len; i++) {
              key[i] = normalizeKey(origKey[i]);
            }
          /* istanbul ignore next */
          } else if (key instanceof Date) {
            return key.toJSON();
          } else if (key !== null) { // generic object
            key = {};
            for (var k in origKey) {
              if (origKey.hasOwnProperty(k)) {
                var val = origKey[k];
                if (typeof val !== 'undefined') {
                  key[k] = normalizeKey(val);
                }
              }
            }
          }
      }
      return key;
    }

    function indexify(key) {
      if (key !== null) {
        switch (typeof key) {
          case 'boolean':
            return key ? 1 : 0;
          case 'number':
            return numToIndexableString(key);
          case 'string':
            // We've to be sure that key does not contain \u0000
            // Do order-preserving replacements:
            // 0 -> 1, 1
            // 1 -> 1, 2
            // 2 -> 2, 2
            /* eslint-disable no-control-regex */
            return key
              .replace(/\u0002/g, '\u0002\u0002')
              .replace(/\u0001/g, '\u0001\u0002')
              .replace(/\u0000/g, '\u0001\u0001');
            /* eslint-enable no-control-regex */
          case 'object':
            var isArray = Array.isArray(key);
            var arr = isArray ? key : Object.keys(key);
            var i = -1;
            var len = arr.length;
            var result = '';
            if (isArray) {
              while (++i < len) {
                result += toIndexableString(arr[i]);
              }
            } else {
              while (++i < len) {
                var objKey = arr[i];
                result += toIndexableString(objKey) +
                    toIndexableString(key[objKey]);
              }
            }
            return result;
        }
      }
      return '';
    }

    // convert the given key to a string that would be appropriate
    // for lexical sorting, e.g. within a database, where the
    // sorting is the same given by the collate() function.
    function toIndexableString(key) {
      var zero = '\u0000';
      key = normalizeKey(key);
      return collationIndex(key) + SEP + indexify(key) + zero;
    }

    function parseNumber(str, i) {
      var originalIdx = i;
      var num;
      var zero = str[i] === '1';
      if (zero) {
        num = 0;
        i++;
      } else {
        var neg = str[i] === '0';
        i++;
        var numAsString = '';
        var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
        var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
        /* istanbul ignore next */
        if (neg) {
          magnitude = -magnitude;
        }
        i += MAGNITUDE_DIGITS;
        while (true) {
          var ch = str[i];
          if (ch === '\u0000') {
            break;
          } else {
            numAsString += ch;
          }
          i++;
        }
        numAsString = numAsString.split('.');
        if (numAsString.length === 1) {
          num = parseInt(numAsString, 10);
        } else {
          /* istanbul ignore next */
          num = parseFloat(numAsString[0] + '.' + numAsString[1]);
        }
        /* istanbul ignore next */
        if (neg) {
          num = num - 10;
        }
        /* istanbul ignore next */
        if (magnitude !== 0) {
          // parseFloat is more reliable than pow due to rounding errors
          // e.g. Number.MAX_VALUE would return Infinity if we did
          // num * Math.pow(10, magnitude);
          num = parseFloat(num + 'e' + magnitude);
        }
      }
      return {num: num, length : i - originalIdx};
    }

    // move up the stack while parsing
    // this function moved outside of parseIndexableString for performance
    function pop$2(stack, metaStack) {
      var obj = stack.pop();

      if (metaStack.length) {
        var lastMetaElement = metaStack[metaStack.length - 1];
        if (obj === lastMetaElement.element) {
          // popping a meta-element, e.g. an object whose value is another object
          metaStack.pop();
          lastMetaElement = metaStack[metaStack.length - 1];
        }
        var element = lastMetaElement.element;
        var lastElementIndex = lastMetaElement.index;
        if (Array.isArray(element)) {
          element.push(obj);
        } else if (lastElementIndex === stack.length - 2) { // obj with key+value
          var key = stack.pop();
          element[key] = obj;
        } else {
          stack.push(obj); // obj with key only
        }
      }
    }

    function parseIndexableString(str) {
      var stack = [];
      var metaStack = []; // stack for arrays and objects
      var i = 0;

      /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
      while (true) {
        var collationIndex = str[i++];
        if (collationIndex === '\u0000') {
          if (stack.length === 1) {
            return stack.pop();
          } else {
            pop$2(stack, metaStack);
            continue;
          }
        }
        switch (collationIndex) {
          case '1':
            stack.push(null);
            break;
          case '2':
            stack.push(str[i] === '1');
            i++;
            break;
          case '3':
            var parsedNum = parseNumber(str, i);
            stack.push(parsedNum.num);
            i += parsedNum.length;
            break;
          case '4':
            var parsedStr = '';
            /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
            while (true) {
              var ch = str[i];
              if (ch === '\u0000') {
                break;
              }
              parsedStr += ch;
              i++;
            }
            // perform the reverse of the order-preserving replacement
            // algorithm (see above)
            /* eslint-disable no-control-regex */
            parsedStr = parsedStr.replace(/\u0001\u0001/g, '\u0000')
              .replace(/\u0001\u0002/g, '\u0001')
              .replace(/\u0002\u0002/g, '\u0002');
            /* eslint-enable no-control-regex */
            stack.push(parsedStr);
            break;
          case '5':
            var arrayElement = { element: [], index: stack.length };
            stack.push(arrayElement.element);
            metaStack.push(arrayElement);
            break;
          case '6':
            var objElement = { element: {}, index: stack.length };
            stack.push(objElement.element);
            metaStack.push(objElement);
            break;
          /* istanbul ignore next */
          default:
            throw new Error(
              'bad collationIndex or unexpectedly reached end of input: ' +
                collationIndex);
        }
      }
    }

    function arrayCollate(a, b) {
      var len = Math.min(a.length, b.length);
      for (var i = 0; i < len; i++) {
        var sort = collate(a[i], b[i]);
        if (sort !== 0) {
          return sort;
        }
      }
      return (a.length === b.length) ? 0 :
        (a.length > b.length) ? 1 : -1;
    }
    function stringCollate(a, b) {
      // See: https://github.com/daleharvey/pouchdb/issues/40
      // This is incompatible with the CouchDB implementation, but its the
      // best we can do for now
      return (a === b) ? 0 : ((a > b) ? 1 : -1);
    }
    function objectCollate(a, b) {
      var ak = Object.keys(a), bk = Object.keys(b);
      var len = Math.min(ak.length, bk.length);
      for (var i = 0; i < len; i++) {
        // First sort the keys
        var sort = collate(ak[i], bk[i]);
        if (sort !== 0) {
          return sort;
        }
        // if the keys are equal sort the values
        sort = collate(a[ak[i]], b[bk[i]]);
        if (sort !== 0) {
          return sort;
        }

      }
      return (ak.length === bk.length) ? 0 :
        (ak.length > bk.length) ? 1 : -1;
    }
    // The collation is defined by erlangs ordered terms
    // the atoms null, true, false come first, then numbers, strings,
    // arrays, then objects
    // null/undefined/NaN/Infinity/-Infinity are all considered null
    function collationIndex(x) {
      var id = ['boolean', 'number', 'string', 'object'];
      var idx = id.indexOf(typeof x);
      //false if -1 otherwise true, but fast!!!!1
      if (~idx) {
        if (x === null) {
          return 1;
        }
        if (Array.isArray(x)) {
          return 5;
        }
        return idx < 3 ? (idx + 2) : (idx + 3);
      }
      /* istanbul ignore next */
      if (Array.isArray(x)) {
        return 5;
      }
    }

    // conversion:
    // x yyy zz...zz
    // x = 0 for negative, 1 for 0, 2 for positive
    // y = exponent (for negative numbers negated) moved so that it's >= 0
    // z = mantisse
    function numToIndexableString(num) {

      if (num === 0) {
        return '1';
      }

      // convert number to exponential format for easier and
      // more succinct string sorting
      var expFormat = num.toExponential().split(/e\+?/);
      var magnitude = parseInt(expFormat[1], 10);

      var neg = num < 0;

      var result = neg ? '0' : '2';

      // first sort by magnitude
      // it's easier if all magnitudes are positive
      var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
      var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

      result += SEP + magString;

      // then sort by the factor
      var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
      /* istanbul ignore next */
      if (neg) { // for negative reverse ordering
        factor = 10 - factor;
      }

      var factorStr = factor.toFixed(20);

      // strip zeros from the end
      factorStr = factorStr.replace(/\.?0+$/, '');

      result += SEP + factorStr;

      return result;
    }

    // create a comparator based on the sort object
    function createFieldSorter(sort) {

      function getFieldValuesAsArray(doc) {
        return sort.map(function (sorting) {
          var fieldName = getKey(sorting);
          var parsedField = parseField(fieldName);
          var docFieldValue = getFieldFromDoc(doc, parsedField);
          return docFieldValue;
        });
      }

      return function (aRow, bRow) {
        var aFieldValues = getFieldValuesAsArray(aRow.doc);
        var bFieldValues = getFieldValuesAsArray(bRow.doc);
        var collation = collate(aFieldValues, bFieldValues);
        if (collation !== 0) {
          return collation;
        }
        // this is what mango seems to do
        return compare$1(aRow.doc._id, bRow.doc._id);
      };
    }

    function filterInMemoryFields(rows, requestDef, inMemoryFields) {
      rows = rows.filter(function (row) {
        return rowFilter(row.doc, requestDef.selector, inMemoryFields);
      });

      if (requestDef.sort) {
        // in-memory sort
        var fieldSorter = createFieldSorter(requestDef.sort);
        rows = rows.sort(fieldSorter);
        if (typeof requestDef.sort[0] !== 'string' &&
            getValue(requestDef.sort[0]) === 'desc') {
          rows = rows.reverse();
        }
      }

      if ('limit' in requestDef || 'skip' in requestDef) {
        // have to do the limit in-memory
        var skip = requestDef.skip || 0;
        var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;
        rows = rows.slice(skip, limit);
      }
      return rows;
    }

    function rowFilter(doc, selector, inMemoryFields) {
      return inMemoryFields.every(function (field) {
        var matcher = selector[field];
        var parsedField = parseField(field);
        var docFieldValue = getFieldFromDoc(doc, parsedField);
        if (isCombinationalField(field)) {
          return matchCominationalSelector(field, matcher, doc);
        }

        return matchSelector(matcher, doc, parsedField, docFieldValue);
      });
    }

    function matchSelector(matcher, doc, parsedField, docFieldValue) {
      if (!matcher) {
        // no filtering necessary; this field is just needed for sorting
        return true;
      }

      // is matcher an object, if so continue recursion
      if (typeof matcher === 'object') {
        return Object.keys(matcher).every(function (userOperator) {
          var userValue = matcher[userOperator];
          return match(userOperator, doc, userValue, parsedField, docFieldValue);
        });
      }

      // no more depth, No need to recurse further
      return matcher === docFieldValue;
    }

    function matchCominationalSelector(field, matcher, doc) {

      if (field === '$or') {
        return matcher.some(function (orMatchers) {
          return rowFilter(doc, orMatchers, Object.keys(orMatchers));
        });
      }

      if (field === '$not') {
        return !rowFilter(doc, matcher, Object.keys(matcher));
      }

      //`$nor`
      return !matcher.find(function (orMatchers) {
        return rowFilter(doc, orMatchers, Object.keys(orMatchers));
      });

    }

    function match(userOperator, doc, userValue, parsedField, docFieldValue) {
      if (!matchers[userOperator]) {
        throw new Error('unknown operator "' + userOperator +
          '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +
          '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
      }
      return matchers[userOperator](doc, userValue, parsedField, docFieldValue);
    }

    function fieldExists(docFieldValue) {
      return typeof docFieldValue !== 'undefined' && docFieldValue !== null;
    }

    function fieldIsNotUndefined(docFieldValue) {
      return typeof docFieldValue !== 'undefined';
    }

    function modField(docFieldValue, userValue) {
      var divisor = userValue[0];
      var mod = userValue[1];
      if (divisor === 0) {
        throw new Error('Bad divisor, cannot divide by zero');
      }

      if (parseInt(divisor, 10) !== divisor ) {
        throw new Error('Divisor is not an integer');
      }

      if (parseInt(mod, 10) !== mod ) {
        throw new Error('Modulus is not an integer');
      }

      if (parseInt(docFieldValue, 10) !== docFieldValue) {
        return false;
      }

      return docFieldValue % divisor === mod;
    }

    function arrayContainsValue(docFieldValue, userValue) {
      return userValue.some(function (val) {
        if (docFieldValue instanceof Array) {
          return docFieldValue.indexOf(val) > -1;
        }

        return docFieldValue === val;
      });
    }

    function arrayContainsAllValues(docFieldValue, userValue) {
      return userValue.every(function (val) {
        return docFieldValue.indexOf(val) > -1;
      });
    }

    function arraySize(docFieldValue, userValue) {
      return docFieldValue.length === userValue;
    }

    function regexMatch(docFieldValue, userValue) {
      var re = new RegExp(userValue);

      return re.test(docFieldValue);
    }

    function typeMatch(docFieldValue, userValue) {

      switch (userValue) {
        case 'null':
          return docFieldValue === null;
        case 'boolean':
          return typeof (docFieldValue) === 'boolean';
        case 'number':
          return typeof (docFieldValue) === 'number';
        case 'string':
          return typeof (docFieldValue) === 'string';
        case 'array':
          return docFieldValue instanceof Array;
        case 'object':
          return ({}).toString.call(docFieldValue) === '[object Object]';
      }

      throw new Error(userValue + ' not supported as a type.' +
                      'Please use one of object, string, array, number, boolean or null.');

    }

    var matchers = {

      '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {
        if (!Array.isArray(docFieldValue)) {
          return false;
        }

        if (docFieldValue.length === 0) {
          return false;
        }

        if (typeof docFieldValue[0] === 'object') {
          return docFieldValue.some(function (val) {
            return rowFilter(val, userValue, Object.keys(userValue));
          });
        }

        return docFieldValue.some(function (val) {
          return matchSelector(userValue, doc, parsedField, val);
        });
      },

      '$allMatch': function (doc, userValue, parsedField, docFieldValue) {
        if (!Array.isArray(docFieldValue)) {
          return false;
        }

        /* istanbul ignore next */
        if (docFieldValue.length === 0) {
          return false;
        }

        if (typeof docFieldValue[0] === 'object') {
          return docFieldValue.every(function (val) {
            return rowFilter(val, userValue, Object.keys(userValue));
          });
        }

        return docFieldValue.every(function (val) {
          return matchSelector(userValue, doc, parsedField, val);
        });
      },

      '$eq': function (doc, userValue, parsedField, docFieldValue) {
        return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;
      },

      '$gte': function (doc, userValue, parsedField, docFieldValue) {
        return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;
      },

      '$gt': function (doc, userValue, parsedField, docFieldValue) {
        return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;
      },

      '$lte': function (doc, userValue, parsedField, docFieldValue) {
        return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;
      },

      '$lt': function (doc, userValue, parsedField, docFieldValue) {
        return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;
      },

      '$exists': function (doc, userValue, parsedField, docFieldValue) {
        //a field that is null is still considered to exist
        if (userValue) {
          return fieldIsNotUndefined(docFieldValue);
        }

        return !fieldIsNotUndefined(docFieldValue);
      },

      '$mod': function (doc, userValue, parsedField, docFieldValue) {
        return fieldExists(docFieldValue) && modField(docFieldValue, userValue);
      },

      '$ne': function (doc, userValue, parsedField, docFieldValue) {
        return userValue.every(function (neValue) {
          return collate(docFieldValue, neValue) !== 0;
        });
      },
      '$in': function (doc, userValue, parsedField, docFieldValue) {
        return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);
      },

      '$nin': function (doc, userValue, parsedField, docFieldValue) {
        return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);
      },

      '$size': function (doc, userValue, parsedField, docFieldValue) {
        return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);
      },

      '$all': function (doc, userValue, parsedField, docFieldValue) {
        return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);
      },

      '$regex': function (doc, userValue, parsedField, docFieldValue) {
        return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);
      },

      '$type': function (doc, userValue, parsedField, docFieldValue) {
        return typeMatch(docFieldValue, userValue);
      }
    };

    // return true if the given doc matches the supplied selector
    function matchesSelector(doc, selector) {
      /* istanbul ignore if */
      if (typeof selector !== 'object') {
        // match the CouchDB error message
        throw new Error('Selector error: expected a JSON object');
      }

      selector = massageSelector(selector);
      var row = {
        'doc': doc
      };

      var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));
      return rowsMatched && rowsMatched.length === 1;
    }

    function evalFilter(input) {
      return scopeEval('"use strict";\nreturn ' + input + ';', {});
    }

    function evalView(input) {
      var code = [
        'return function(doc) {',
        '  "use strict";',
        '  var emitted = false;',
        '  var emit = function (a, b) {',
        '    emitted = true;',
        '  };',
        '  var view = ' + input + ';',
        '  view(doc);',
        '  if (emitted) {',
        '    return true;',
        '  }',
        '};'
      ].join('\n');

      return scopeEval(code, {});
    }

    function validate(opts, callback) {
      if (opts.selector) {
        if (opts.filter && opts.filter !== '_selector') {
          var filterName = typeof opts.filter === 'string' ?
            opts.filter : 'function';
          return callback(new Error('selector invalid for filter "' + filterName + '"'));
        }
      }
      callback();
    }

    function normalize(opts) {
      if (opts.view && !opts.filter) {
        opts.filter = '_view';
      }

      if (opts.selector && !opts.filter) {
        opts.filter = '_selector';
      }

      if (opts.filter && typeof opts.filter === 'string') {
        if (opts.filter === '_view') {
          opts.view = normalizeDesignDocFunctionName(opts.view);
        } else {
          opts.filter = normalizeDesignDocFunctionName(opts.filter);
        }
      }
    }

    function shouldFilter(changesHandler, opts) {
      return opts.filter && typeof opts.filter === 'string' &&
        !opts.doc_ids && !isRemote(changesHandler.db);
    }

    function filter(changesHandler, opts) {
      var callback = opts.complete;
      if (opts.filter === '_view') {
        if (!opts.view || typeof opts.view !== 'string') {
          var err = createError(BAD_REQUEST,
            '`view` filter parameter not found or invalid.');
          return callback(err);
        }
        // fetch a view from a design doc, make it behave like a filter
        var viewName = parseDesignDocFunctionName(opts.view);
        changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {
          /* istanbul ignore if */
          if (changesHandler.isCancelled) {
            return callback(null, {status: 'cancelled'});
          }
          /* istanbul ignore next */
          if (err) {
            return callback(generateErrorFromResponse(err));
          }
          var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&
            ddoc.views[viewName[1]].map;
          if (!mapFun) {
            return callback(createError(MISSING_DOC,
              (ddoc.views ? 'missing json key: ' + viewName[1] :
                'missing json key: views')));
          }
          opts.filter = evalView(mapFun);
          changesHandler.doChanges(opts);
        });
      } else if (opts.selector) {
        opts.filter = function (doc) {
          return matchesSelector(doc, opts.selector);
        };
        changesHandler.doChanges(opts);
      } else {
        // fetch a filter from a design doc
        var filterName = parseDesignDocFunctionName(opts.filter);
        changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {
          /* istanbul ignore if */
          if (changesHandler.isCancelled) {
            return callback(null, {status: 'cancelled'});
          }
          /* istanbul ignore next */
          if (err) {
            return callback(generateErrorFromResponse(err));
          }
          var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];
          if (!filterFun) {
            return callback(createError(MISSING_DOC,
              ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]
                : 'missing json key: filters')));
          }
          opts.filter = evalFilter(filterFun);
          changesHandler.doChanges(opts);
        });
      }
    }

    function applyChangesFilterPlugin(PouchDB) {
      PouchDB._changesFilterPlugin = {
        validate: validate,
        normalize: normalize,
        shouldFilter: shouldFilter,
        filter: filter
      };
    }

    // TODO: remove from pouchdb-core (breaking)
    PouchDB.plugin(applyChangesFilterPlugin);

    PouchDB.version = version$1;

    function toObject(array) {
      return array.reduce(function (obj, item) {
        obj[item] = true;
        return obj;
      }, {});
    }
    // List of top level reserved words for doc
    var reservedWords = toObject([
      '_id',
      '_rev',
      '_attachments',
      '_deleted',
      '_revisions',
      '_revs_info',
      '_conflicts',
      '_deleted_conflicts',
      '_local_seq',
      '_rev_tree',
      //replication documents
      '_replication_id',
      '_replication_state',
      '_replication_state_time',
      '_replication_state_reason',
      '_replication_stats',
      // Specific to Couchbase Sync Gateway
      '_removed'
    ]);

    // List of reserved words that should end up the document
    var dataWords = toObject([
      '_attachments',
      //replication documents
      '_replication_id',
      '_replication_state',
      '_replication_state_time',
      '_replication_state_reason',
      '_replication_stats'
    ]);

    function parseRevisionInfo(rev$$1) {
      if (!/^\d+-/.test(rev$$1)) {
        return createError(INVALID_REV);
      }
      var idx = rev$$1.indexOf('-');
      var left = rev$$1.substring(0, idx);
      var right = rev$$1.substring(idx + 1);
      return {
        prefix: parseInt(left, 10),
        id: right
      };
    }

    function makeRevTreeFromRevisions(revisions, opts) {
      var pos = revisions.start - revisions.ids.length + 1;

      var revisionIds = revisions.ids;
      var ids = [revisionIds[0], opts, []];

      for (var i = 1, len = revisionIds.length; i < len; i++) {
        ids = [revisionIds[i], {status: 'missing'}, [ids]];
      }

      return [{
        pos: pos,
        ids: ids
      }];
    }

    // Preprocess documents, parse their revisions, assign an id and a
    // revision for new writes that are missing them, etc
    function parseDoc(doc, newEdits, dbOpts) {
      if (!dbOpts) {
        dbOpts = {
          deterministic_revs: true
        };
      }

      var nRevNum;
      var newRevId;
      var revInfo;
      var opts = {status: 'available'};
      if (doc._deleted) {
        opts.deleted = true;
      }

      if (newEdits) {
        if (!doc._id) {
          doc._id = uuid();
        }
        newRevId = rev(doc, dbOpts.deterministic_revs);
        if (doc._rev) {
          revInfo = parseRevisionInfo(doc._rev);
          if (revInfo.error) {
            return revInfo;
          }
          doc._rev_tree = [{
            pos: revInfo.prefix,
            ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]
          }];
          nRevNum = revInfo.prefix + 1;
        } else {
          doc._rev_tree = [{
            pos: 1,
            ids : [newRevId, opts, []]
          }];
          nRevNum = 1;
        }
      } else {
        if (doc._revisions) {
          doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
          nRevNum = doc._revisions.start;
          newRevId = doc._revisions.ids[0];
        }
        if (!doc._rev_tree) {
          revInfo = parseRevisionInfo(doc._rev);
          if (revInfo.error) {
            return revInfo;
          }
          nRevNum = revInfo.prefix;
          newRevId = revInfo.id;
          doc._rev_tree = [{
            pos: nRevNum,
            ids: [newRevId, opts, []]
          }];
        }
      }

      invalidIdError(doc._id);

      doc._rev = nRevNum + '-' + newRevId;

      var result = {metadata : {}, data : {}};
      for (var key in doc) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(doc, key)) {
          var specialKey = key[0] === '_';
          if (specialKey && !reservedWords[key]) {
            var error = createError(DOC_VALIDATION, key);
            error.message = DOC_VALIDATION.message + ': ' + key;
            throw error;
          } else if (specialKey && !dataWords[key]) {
            result.metadata[key.slice(1)] = doc[key];
          } else {
            result.data[key] = doc[key];
          }
        }
      }
      return result;
    }

    function parseBase64(data) {
      try {
        return thisAtob(data);
      } catch (e) {
        var err = createError(BAD_ARG,
          'Attachment is not a valid base64 string');
        return {error: err};
      }
    }

    function preprocessString(att, blobType, callback) {
      var asBinary = parseBase64(att.data);
      if (asBinary.error) {
        return callback(asBinary.error);
      }

      att.length = asBinary.length;
      if (blobType === 'blob') {
        att.data = binStringToBluffer(asBinary, att.content_type);
      } else if (blobType === 'base64') {
        att.data = thisBtoa(asBinary);
      } else { // binary
        att.data = asBinary;
      }
      binaryMd5(asBinary, function (result) {
        att.digest = 'md5-' + result;
        callback();
      });
    }

    function preprocessBlob(att, blobType, callback) {
      binaryMd5(att.data, function (md5) {
        att.digest = 'md5-' + md5;
        // size is for blobs (browser), length is for buffers (node)
        att.length = att.data.size || att.data.length || 0;
        if (blobType === 'binary') {
          blobToBinaryString(att.data, function (binString) {
            att.data = binString;
            callback();
          });
        } else if (blobType === 'base64') {
          blobToBase64(att.data, function (b64) {
            att.data = b64;
            callback();
          });
        } else {
          callback();
        }
      });
    }

    function preprocessAttachment(att, blobType, callback) {
      if (att.stub) {
        return callback();
      }
      if (typeof att.data === 'string') { // input is a base64 string
        preprocessString(att, blobType, callback);
      } else { // input is a blob
        preprocessBlob(att, blobType, callback);
      }
    }

    function preprocessAttachments(docInfos, blobType, callback) {

      if (!docInfos.length) {
        return callback();
      }

      var docv = 0;
      var overallErr;

      docInfos.forEach(function (docInfo) {
        var attachments = docInfo.data && docInfo.data._attachments ?
          Object.keys(docInfo.data._attachments) : [];
        var recv = 0;

        if (!attachments.length) {
          return done();
        }

        function processedAttachment(err) {
          overallErr = err;
          recv++;
          if (recv === attachments.length) {
            done();
          }
        }

        for (var key in docInfo.data._attachments) {
          if (docInfo.data._attachments.hasOwnProperty(key)) {
            preprocessAttachment(docInfo.data._attachments[key],
              blobType, processedAttachment);
          }
        }
      });

      function done() {
        docv++;
        if (docInfos.length === docv) {
          if (overallErr) {
            callback(overallErr);
          } else {
            callback();
          }
        }
      }
    }

    function updateDoc(revLimit, prev, docInfo, results,
                       i, cb, writeDoc, newEdits) {

      if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {
        results[i] = docInfo;
        return cb();
      }

      // sometimes this is pre-calculated. historically not always
      var previousWinningRev = prev.winningRev || winningRev(prev);
      var previouslyDeleted = 'deleted' in prev ? prev.deleted :
        isDeleted(prev, previousWinningRev);
      var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :
        isDeleted(docInfo.metadata);
      var isRoot = /^1-/.test(docInfo.metadata.rev);

      if (previouslyDeleted && !deleted && newEdits && isRoot) {
        var newDoc = docInfo.data;
        newDoc._rev = previousWinningRev;
        newDoc._id = docInfo.metadata.id;
        docInfo = parseDoc(newDoc, newEdits);
      }

      var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);

      var inConflict = newEdits && ((
        (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||
        (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||
        (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));

      if (inConflict) {
        var err = createError(REV_CONFLICT);
        results[i] = err;
        return cb();
      }

      var newRev = docInfo.metadata.rev;
      docInfo.metadata.rev_tree = merged.tree;
      docInfo.stemmedRevs = merged.stemmedRevs || [];
      /* istanbul ignore else */
      if (prev.rev_map) {
        docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
      }

      // recalculate
      var winningRev$$1 = winningRev(docInfo.metadata);
      var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);

      // calculate the total number of documents that were added/removed,
      // from the perspective of total_rows/doc_count
      var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :
        previouslyDeleted < winningRevIsDeleted ? -1 : 1;

      var newRevIsDeleted;
      if (newRev === winningRev$$1) {
        // if the new rev is the same as the winning rev, we can reuse that value
        newRevIsDeleted = winningRevIsDeleted;
      } else {
        // if they're not the same, then we need to recalculate
        newRevIsDeleted = isDeleted(docInfo.metadata, newRev);
      }

      writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
        true, delta, i, cb);
    }

    function rootIsMissing(docInfo) {
      return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
    }

    function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,
                         writeDoc, opts, overallCallback) {

      // Default to 1000 locally
      revLimit = revLimit || 1000;

      function insertDoc(docInfo, resultsIdx, callback) {
        // Cant insert new deleted documents
        var winningRev$$1 = winningRev(docInfo.metadata);
        var deleted = isDeleted(docInfo.metadata, winningRev$$1);
        if ('was_delete' in opts && deleted) {
          results[resultsIdx] = createError(MISSING_DOC, 'deleted');
          return callback();
        }

        // 4712 - detect whether a new document was inserted with a _rev
        var inConflict = newEdits && rootIsMissing(docInfo);

        if (inConflict) {
          var err = createError(REV_CONFLICT);
          results[resultsIdx] = err;
          return callback();
        }

        var delta = deleted ? 0 : 1;

        writeDoc(docInfo, winningRev$$1, deleted, deleted, false,
          delta, resultsIdx, callback);
      }

      var newEdits = opts.new_edits;
      var idsToDocs = new ExportedMap();

      var docsDone = 0;
      var docsToDo = docInfos.length;

      function checkAllDocsDone() {
        if (++docsDone === docsToDo && overallCallback) {
          overallCallback();
        }
      }

      docInfos.forEach(function (currentDoc, resultsIdx) {

        if (currentDoc._id && isLocalId(currentDoc._id)) {
          var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
          api[fun](currentDoc, {ctx: tx}, function (err, res) {
            results[resultsIdx] = err || res;
            checkAllDocsDone();
          });
          return;
        }

        var id = currentDoc.metadata.id;
        if (idsToDocs.has(id)) {
          docsToDo--; // duplicate
          idsToDocs.get(id).push([currentDoc, resultsIdx]);
        } else {
          idsToDocs.set(id, [[currentDoc, resultsIdx]]);
        }
      });

      // in the case of new_edits, the user can provide multiple docs
      // with the same id. these need to be processed sequentially
      idsToDocs.forEach(function (docs, id) {
        var numDone = 0;

        function docWritten() {
          if (++numDone < docs.length) {
            nextDoc();
          } else {
            checkAllDocsDone();
          }
        }
        function nextDoc() {
          var value = docs[numDone];
          var currentDoc = value[0];
          var resultsIdx = value[1];

          if (fetchedDocs.has(id)) {
            updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,
              resultsIdx, docWritten, writeDoc, newEdits);
          } else {
            // Ensure stemming applies to new writes as well
            var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);
            currentDoc.metadata.rev_tree = merged.tree;
            currentDoc.stemmedRevs = merged.stemmedRevs || [];
            insertDoc(currentDoc, resultsIdx, docWritten);
          }
        }
        nextDoc();
      });
    }

    // IndexedDB requires a versioned database structure, so we use the
    // version here to manage migrations.
    var ADAPTER_VERSION = 5;

    // The object stores created for each database
    // DOC_STORE stores the document meta data, its revision history and state
    // Keyed by document id
    var DOC_STORE = 'document-store';
    // BY_SEQ_STORE stores a particular version of a document, keyed by its
    // sequence id
    var BY_SEQ_STORE = 'by-sequence';
    // Where we store attachments
    var ATTACH_STORE = 'attach-store';
    // Where we store many-to-many relations
    // between attachment digests and seqs
    var ATTACH_AND_SEQ_STORE = 'attach-seq-store';

    // Where we store database-wide meta data in a single record
    // keyed by id: META_STORE
    var META_STORE = 'meta-store';
    // Where we store local documents
    var LOCAL_STORE = 'local-store';
    // Where we detect blob support
    var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

    function safeJsonParse(str) {
      // This try/catch guards against stack overflow errors.
      // JSON.parse() is faster than vuvuzela.parse() but vuvuzela
      // cannot overflow.
      try {
        return JSON.parse(str);
      } catch (e) {
        /* istanbul ignore next */
        return vuvuzela.parse(str);
      }
    }

    function safeJsonStringify(json) {
      try {
        return JSON.stringify(json);
      } catch (e) {
        /* istanbul ignore next */
        return vuvuzela.stringify(json);
      }
    }

    function idbError(callback) {
      return function (evt) {
        var message = 'unknown_error';
        if (evt.target && evt.target.error) {
          message = evt.target.error.name || evt.target.error.message;
        }
        callback(createError(IDB_ERROR, message, evt.type));
      };
    }

    // Unfortunately, the metadata has to be stringified
    // when it is put into the database, because otherwise
    // IndexedDB can throw errors for deeply-nested objects.
    // Originally we just used JSON.parse/JSON.stringify; now
    // we use this custom vuvuzela library that avoids recursion.
    // If we could do it all over again, we'd probably use a
    // format for the revision trees other than JSON.
    function encodeMetadata(metadata, winningRev, deleted) {
      return {
        data: safeJsonStringify(metadata),
        winningRev: winningRev,
        deletedOrLocal: deleted ? '1' : '0',
        seq: metadata.seq, // highest seq for this doc
        id: metadata.id
      };
    }

    function decodeMetadata(storedObject) {
      if (!storedObject) {
        return null;
      }
      var metadata = safeJsonParse(storedObject.data);
      metadata.winningRev = storedObject.winningRev;
      metadata.deleted = storedObject.deletedOrLocal === '1';
      metadata.seq = storedObject.seq;
      return metadata;
    }

    // read the doc back out from the database. we don't store the
    // _id or _rev because we already have _doc_id_rev.
    function decodeDoc(doc) {
      if (!doc) {
        return doc;
      }
      var idx = doc._doc_id_rev.lastIndexOf(':');
      doc._id = doc._doc_id_rev.substring(0, idx - 1);
      doc._rev = doc._doc_id_rev.substring(idx + 1);
      delete doc._doc_id_rev;
      return doc;
    }

    // Read a blob from the database, encoding as necessary
    // and translating from base64 if the IDB doesn't support
    // native Blobs
    function readBlobData(body, type, asBlob, callback) {
      if (asBlob) {
        if (!body) {
          callback(createBlob([''], {type: type}));
        } else if (typeof body !== 'string') { // we have blob support
          callback(body);
        } else { // no blob support
          callback(b64ToBluffer(body, type));
        }
      } else { // as base64 string
        if (!body) {
          callback('');
        } else if (typeof body !== 'string') { // we have blob support
          readAsBinaryString(body, function (binary) {
            callback(thisBtoa(binary));
          });
        } else { // no blob support
          callback(body);
        }
      }
    }

    function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
      var attachments = Object.keys(doc._attachments || {});
      if (!attachments.length) {
        return cb && cb();
      }
      var numDone = 0;

      function checkDone() {
        if (++numDone === attachments.length && cb) {
          cb();
        }
      }

      function fetchAttachment(doc, att) {
        var attObj = doc._attachments[att];
        var digest = attObj.digest;
        var req = txn.objectStore(ATTACH_STORE).get(digest);
        req.onsuccess = function (e) {
          attObj.body = e.target.result.body;
          checkDone();
        };
      }

      attachments.forEach(function (att) {
        if (opts.attachments && opts.include_docs) {
          fetchAttachment(doc, att);
        } else {
          doc._attachments[att].stub = true;
          checkDone();
        }
      });
    }

    // IDB-specific postprocessing necessary because
    // we don't know whether we stored a true Blob or
    // a base64-encoded string, and if it's a Blob it
    // needs to be read outside of the transaction context
    function postProcessAttachments(results, asBlob) {
      return Promise.all(results.map(function (row) {
        if (row.doc && row.doc._attachments) {
          var attNames = Object.keys(row.doc._attachments);
          return Promise.all(attNames.map(function (att) {
            var attObj = row.doc._attachments[att];
            if (!('body' in attObj)) { // already processed
              return;
            }
            var body = attObj.body;
            var type = attObj.content_type;
            return new Promise(function (resolve) {
              readBlobData(body, type, asBlob, function (data) {
                row.doc._attachments[att] = $inject_Object_assign(
                  pick(attObj, ['digest', 'content_type']),
                  {data: data}
                );
                resolve();
              });
            });
          }));
        }
      }));
    }

    function compactRevs(revs, docId, txn) {

      var possiblyOrphanedDigests = [];
      var seqStore = txn.objectStore(BY_SEQ_STORE);
      var attStore = txn.objectStore(ATTACH_STORE);
      var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
      var count = revs.length;

      function checkDone() {
        count--;
        if (!count) { // done processing all revs
          deleteOrphanedAttachments();
        }
      }

      function deleteOrphanedAttachments() {
        if (!possiblyOrphanedDigests.length) {
          return;
        }
        possiblyOrphanedDigests.forEach(function (digest) {
          var countReq = attAndSeqStore.index('digestSeq').count(
            IDBKeyRange.bound(
              digest + '::', digest + '::\uffff', false, false));
          countReq.onsuccess = function (e) {
            var count = e.target.result;
            if (!count) {
              // orphaned
              attStore.delete(digest);
            }
          };
        });
      }

      revs.forEach(function (rev$$1) {
        var index = seqStore.index('_doc_id_rev');
        var key = docId + "::" + rev$$1;
        index.getKey(key).onsuccess = function (e) {
          var seq = e.target.result;
          if (typeof seq !== 'number') {
            return checkDone();
          }
          seqStore.delete(seq);

          var cursor = attAndSeqStore.index('seq')
            .openCursor(IDBKeyRange.only(seq));

          cursor.onsuccess = function (event) {
            var cursor = event.target.result;
            if (cursor) {
              var digest = cursor.value.digestSeq.split('::')[0];
              possiblyOrphanedDigests.push(digest);
              attAndSeqStore.delete(cursor.primaryKey);
              cursor.continue();
            } else { // done
              checkDone();
            }
          };
        };
      });
    }

    function openTransactionSafely(idb, stores, mode) {
      try {
        return {
          txn: idb.transaction(stores, mode)
        };
      } catch (err) {
        return {
          error: err
        };
      }
    }

    var changesHandler = new Changes();

    function idbBulkDocs(dbOpts, req, opts, api, idb, callback) {
      var docInfos = req.docs;
      var txn;
      var docStore;
      var bySeqStore;
      var attachStore;
      var attachAndSeqStore;
      var metaStore;
      var docInfoError;
      var metaDoc;

      for (var i = 0, len = docInfos.length; i < len; i++) {
        var doc = docInfos[i];
        if (doc._id && isLocalId(doc._id)) {
          continue;
        }
        doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);
        if (doc.error && !docInfoError) {
          docInfoError = doc;
        }
      }

      if (docInfoError) {
        return callback(docInfoError);
      }

      var allDocsProcessed = false;
      var docCountDelta = 0;
      var results = new Array(docInfos.length);
      var fetchedDocs = new ExportedMap();
      var preconditionErrored = false;
      var blobType = api._meta.blobSupport ? 'blob' : 'base64';

      preprocessAttachments(docInfos, blobType, function (err) {
        if (err) {
          return callback(err);
        }
        startTransaction();
      });

      function startTransaction() {

        var stores = [
          DOC_STORE, BY_SEQ_STORE,
          ATTACH_STORE,
          LOCAL_STORE, ATTACH_AND_SEQ_STORE,
          META_STORE
        ];
        var txnResult = openTransactionSafely(idb, stores, 'readwrite');
        if (txnResult.error) {
          return callback(txnResult.error);
        }
        txn = txnResult.txn;
        txn.onabort = idbError(callback);
        txn.ontimeout = idbError(callback);
        txn.oncomplete = complete;
        docStore = txn.objectStore(DOC_STORE);
        bySeqStore = txn.objectStore(BY_SEQ_STORE);
        attachStore = txn.objectStore(ATTACH_STORE);
        attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
        metaStore = txn.objectStore(META_STORE);

        metaStore.get(META_STORE).onsuccess = function (e) {
          metaDoc = e.target.result;
          updateDocCountIfReady();
        };

        verifyAttachments(function (err) {
          if (err) {
            preconditionErrored = true;
            return callback(err);
          }
          fetchExistingDocs();
        });
      }

      function onAllDocsProcessed() {
        allDocsProcessed = true;
        updateDocCountIfReady();
      }

      function idbProcessDocs() {
        processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,
                    txn, results, writeDoc, opts, onAllDocsProcessed);
      }

      function updateDocCountIfReady() {
        if (!metaDoc || !allDocsProcessed) {
          return;
        }
        // caching the docCount saves a lot of time in allDocs() and
        // info(), which is why we go to all the trouble of doing this
        metaDoc.docCount += docCountDelta;
        metaStore.put(metaDoc);
      }

      function fetchExistingDocs() {

        if (!docInfos.length) {
          return;
        }

        var numFetched = 0;

        function checkDone() {
          if (++numFetched === docInfos.length) {
            idbProcessDocs();
          }
        }

        function readMetadata(event) {
          var metadata = decodeMetadata(event.target.result);

          if (metadata) {
            fetchedDocs.set(metadata.id, metadata);
          }
          checkDone();
        }

        for (var i = 0, len = docInfos.length; i < len; i++) {
          var docInfo = docInfos[i];
          if (docInfo._id && isLocalId(docInfo._id)) {
            checkDone(); // skip local docs
            continue;
          }
          var req = docStore.get(docInfo.metadata.id);
          req.onsuccess = readMetadata;
        }
      }

      function complete() {
        if (preconditionErrored) {
          return;
        }

        changesHandler.notify(api._meta.name);
        callback(null, results);
      }

      function verifyAttachment(digest, callback) {

        var req = attachStore.get(digest);
        req.onsuccess = function (e) {
          if (!e.target.result) {
            var err = createError(MISSING_STUB,
              'unknown stub attachment with digest ' +
              digest);
            err.status = 412;
            callback(err);
          } else {
            callback();
          }
        };
      }

      function verifyAttachments(finish) {


        var digests = [];
        docInfos.forEach(function (docInfo) {
          if (docInfo.data && docInfo.data._attachments) {
            Object.keys(docInfo.data._attachments).forEach(function (filename) {
              var att = docInfo.data._attachments[filename];
              if (att.stub) {
                digests.push(att.digest);
              }
            });
          }
        });
        if (!digests.length) {
          return finish();
        }
        var numDone = 0;
        var err;

        function checkDone() {
          if (++numDone === digests.length) {
            finish(err);
          }
        }
        digests.forEach(function (digest) {
          verifyAttachment(digest, function (attErr) {
            if (attErr && !err) {
              err = attErr;
            }
            checkDone();
          });
        });
      }

      function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
                        isUpdate, delta, resultsIdx, callback) {

        docInfo.metadata.winningRev = winningRev$$1;
        docInfo.metadata.deleted = winningRevIsDeleted;

        var doc = docInfo.data;
        doc._id = docInfo.metadata.id;
        doc._rev = docInfo.metadata.rev;

        if (newRevIsDeleted) {
          doc._deleted = true;
        }

        var hasAttachments = doc._attachments &&
          Object.keys(doc._attachments).length;
        if (hasAttachments) {
          return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
            isUpdate, resultsIdx, callback);
        }

        docCountDelta += delta;
        updateDocCountIfReady();

        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
          isUpdate, resultsIdx, callback);
      }

      function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
                         isUpdate, resultsIdx, callback) {

        var doc = docInfo.data;
        var metadata = docInfo.metadata;

        doc._doc_id_rev = metadata.id + '::' + metadata.rev;
        delete doc._id;
        delete doc._rev;

        function afterPutDoc(e) {
          var revsToDelete = docInfo.stemmedRevs || [];

          if (isUpdate && api.auto_compaction) {
            revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));
          }

          if (revsToDelete && revsToDelete.length) {
            compactRevs(revsToDelete, docInfo.metadata.id, txn);
          }

          metadata.seq = e.target.result;
          // Current _rev is calculated from _rev_tree on read
          // delete metadata.rev;
          var metadataToStore = encodeMetadata(metadata, winningRev$$1,
            winningRevIsDeleted);
          var metaDataReq = docStore.put(metadataToStore);
          metaDataReq.onsuccess = afterPutMetadata;
        }

        function afterPutDocError(e) {
          // ConstraintError, need to update, not put (see #1638 for details)
          e.preventDefault(); // avoid transaction abort
          e.stopPropagation(); // avoid transaction onerror
          var index = bySeqStore.index('_doc_id_rev');
          var getKeyReq = index.getKey(doc._doc_id_rev);
          getKeyReq.onsuccess = function (e) {
            var putReq = bySeqStore.put(doc, e.target.result);
            putReq.onsuccess = afterPutDoc;
          };
        }

        function afterPutMetadata() {
          results[resultsIdx] = {
            ok: true,
            id: metadata.id,
            rev: metadata.rev
          };
          fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
          insertAttachmentMappings(docInfo, metadata.seq, callback);
        }

        var putReq = bySeqStore.put(doc);

        putReq.onsuccess = afterPutDoc;
        putReq.onerror = afterPutDocError;
      }

      function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
                                isUpdate, resultsIdx, callback) {


        var doc = docInfo.data;

        var numDone = 0;
        var attachments = Object.keys(doc._attachments);

        function collectResults() {
          if (numDone === attachments.length) {
            finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
              isUpdate, resultsIdx, callback);
          }
        }

        function attachmentSaved() {
          numDone++;
          collectResults();
        }

        attachments.forEach(function (key) {
          var att = docInfo.data._attachments[key];
          if (!att.stub) {
            var data = att.data;
            delete att.data;
            att.revpos = parseInt(winningRev$$1, 10);
            var digest = att.digest;
            saveAttachment(digest, data, attachmentSaved);
          } else {
            numDone++;
            collectResults();
          }
        });
      }

      // map seqs to attachment digests, which
      // we will need later during compaction
      function insertAttachmentMappings(docInfo, seq, callback) {

        var attsAdded = 0;
        var attsToAdd = Object.keys(docInfo.data._attachments || {});

        if (!attsToAdd.length) {
          return callback();
        }

        function checkDone() {
          if (++attsAdded === attsToAdd.length) {
            callback();
          }
        }

        function add(att) {
          var digest = docInfo.data._attachments[att].digest;
          var req = attachAndSeqStore.put({
            seq: seq,
            digestSeq: digest + '::' + seq
          });

          req.onsuccess = checkDone;
          req.onerror = function (e) {
            // this callback is for a constaint error, which we ignore
            // because this docid/rev has already been associated with
            // the digest (e.g. when new_edits == false)
            e.preventDefault(); // avoid transaction abort
            e.stopPropagation(); // avoid transaction onerror
            checkDone();
          };
        }
        for (var i = 0; i < attsToAdd.length; i++) {
          add(attsToAdd[i]); // do in parallel
        }
      }

      function saveAttachment(digest, data, callback) {


        var getKeyReq = attachStore.count(digest);
        getKeyReq.onsuccess = function (e) {
          var count = e.target.result;
          if (count) {
            return callback(); // already exists
          }
          var newAtt = {
            digest: digest,
            body: data
          };
          var putReq = attachStore.put(newAtt);
          putReq.onsuccess = callback;
        };
      }
    }

    // Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations
    // while falling back to a normal IDBCursor operation on browsers that don't support getAll() or
    // getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because
    // we're not processing each document one-at-a-time.
    function runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {

      if (batchSize === -1) {
        batchSize = 1000;
      }

      // Bail out of getAll()/getAllKeys() in the following cases:
      // 1) either method is unsupported - we need both
      // 2) batchSize is 1 (might as well use IDBCursor)
      // 3) descending – no real way to do this via getAll()/getAllKeys()

      var useGetAll = typeof objectStore.getAll === 'function' &&
        typeof objectStore.getAllKeys === 'function' &&
        batchSize > 1 && !descending;

      var keysBatch;
      var valuesBatch;
      var pseudoCursor;

      function onGetAll(e) {
        valuesBatch = e.target.result;
        if (keysBatch) {
          onBatch(keysBatch, valuesBatch, pseudoCursor);
        }
      }

      function onGetAllKeys(e) {
        keysBatch = e.target.result;
        if (valuesBatch) {
          onBatch(keysBatch, valuesBatch, pseudoCursor);
        }
      }

      function continuePseudoCursor() {
        if (!keysBatch.length) { // no more results
          return onBatch();
        }
        // fetch next batch, exclusive start
        var lastKey = keysBatch[keysBatch.length - 1];
        var newKeyRange;
        if (keyRange && keyRange.upper) {
          try {
            newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,
              true, keyRange.upperOpen);
          } catch (e) {
            if (e.name === "DataError" && e.code === 0) {
              return onBatch(); // we're done, startkey and endkey are equal
            }
          }
        } else {
          newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
        }
        keyRange = newKeyRange;
        keysBatch = null;
        valuesBatch = null;
        objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
        objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
      }

      function onCursor(e) {
        var cursor = e.target.result;
        if (!cursor) { // done
          return onBatch();
        }
        // regular IDBCursor acts like a batch where batch size is always 1
        onBatch([cursor.key], [cursor.value], cursor);
      }

      if (useGetAll) {
        pseudoCursor = {"continue": continuePseudoCursor};
        objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
        objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
      } else if (descending) {
        objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
      } else {
        objectStore.openCursor(keyRange).onsuccess = onCursor;
      }
    }

    // simple shim for objectStore.getAll(), falling back to IDBCursor
    function getAll(objectStore, keyRange, onSuccess) {
      if (typeof objectStore.getAll === 'function') {
        // use native getAll
        objectStore.getAll(keyRange).onsuccess = onSuccess;
        return;
      }
      // fall back to cursors
      var values = [];

      function onCursor(e) {
        var cursor = e.target.result;
        if (cursor) {
          values.push(cursor.value);
          cursor.continue();
        } else {
          onSuccess({
            target: {
              result: values
            }
          });
        }
      }

      objectStore.openCursor(keyRange).onsuccess = onCursor;
    }

    function allDocsKeys(keys, docStore, onBatch) {
      // It's not guaranted to be returned in right order  
      var valuesBatch = new Array(keys.length);
      var count = 0;
      keys.forEach(function (key, index) {
        docStore.get(key).onsuccess = function (event) {
          if (event.target.result) {
            valuesBatch[index] = event.target.result;
          } else {
            valuesBatch[index] = {key: key, error: 'not_found'};
          }
          count++;
          if (count === keys.length) {
            onBatch(keys, valuesBatch, {});
          }
        };
      });
    }

    function createKeyRange(start, end, inclusiveEnd, key, descending) {
      try {
        if (start && end) {
          if (descending) {
            return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
          } else {
            return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
          }
        } else if (start) {
          if (descending) {
            return IDBKeyRange.upperBound(start);
          } else {
            return IDBKeyRange.lowerBound(start);
          }
        } else if (end) {
          if (descending) {
            return IDBKeyRange.lowerBound(end, !inclusiveEnd);
          } else {
            return IDBKeyRange.upperBound(end, !inclusiveEnd);
          }
        } else if (key) {
          return IDBKeyRange.only(key);
        }
      } catch (e) {
        return {error: e};
      }
      return null;
    }

    function idbAllDocs(opts, idb, callback) {
      var start = 'startkey' in opts ? opts.startkey : false;
      var end = 'endkey' in opts ? opts.endkey : false;
      var key = 'key' in opts ? opts.key : false;
      var keys = 'keys' in opts ? opts.keys : false; 
      var skip = opts.skip || 0;
      var limit = typeof opts.limit === 'number' ? opts.limit : -1;
      var inclusiveEnd = opts.inclusive_end !== false;

      var keyRange ; 
      var keyRangeError;
      if (!keys) {
        keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);
        keyRangeError = keyRange && keyRange.error;
        if (keyRangeError && 
          !(keyRangeError.name === "DataError" && keyRangeError.code === 0)) {
          // DataError with error code 0 indicates start is less than end, so
          // can just do an empty query. Else need to throw
          return callback(createError(IDB_ERROR,
            keyRangeError.name, keyRangeError.message));
        }
      }

      var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];

      if (opts.attachments) {
        stores.push(ATTACH_STORE);
      }
      var txnResult = openTransactionSafely(idb, stores, 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      var txn = txnResult.txn;
      txn.oncomplete = onTxnComplete;
      txn.onabort = idbError(callback);
      var docStore = txn.objectStore(DOC_STORE);
      var seqStore = txn.objectStore(BY_SEQ_STORE);
      var metaStore = txn.objectStore(META_STORE);
      var docIdRevIndex = seqStore.index('_doc_id_rev');
      var results = [];
      var docCount;
      var updateSeq;

      metaStore.get(META_STORE).onsuccess = function (e) {
        docCount = e.target.result.docCount;
      };

      /* istanbul ignore if */
      if (opts.update_seq) {
        getMaxUpdateSeq(seqStore, function (e) { 
          if (e.target.result && e.target.result.length > 0) {
            updateSeq = e.target.result[0];
          }
        });
      }

      function getMaxUpdateSeq(objectStore, onSuccess) {
        function onCursor(e) {
          var cursor = e.target.result;
          var maxKey = undefined;
          if (cursor && cursor.key) {
            maxKey = cursor.key;
          } 
          return onSuccess({
            target: {
              result: [maxKey]
            }
          });
        }
        objectStore.openCursor(null, 'prev').onsuccess = onCursor;
      }

      // if the user specifies include_docs=true, then we don't
      // want to block the main cursor while we're fetching the doc
      function fetchDocAsynchronously(metadata, row, winningRev$$1) {
        var key = metadata.id + "::" + winningRev$$1;
        docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {
          row.doc = decodeDoc(e.target.result) || {};
          if (opts.conflicts) {
            var conflicts = collectConflicts(metadata);
            if (conflicts.length) {
              row.doc._conflicts = conflicts;
            }
          }
          fetchAttachmentsIfNecessary(row.doc, opts, txn);
        };
      }

      function allDocsInner(winningRev$$1, metadata) {
        var row = {
          id: metadata.id,
          key: metadata.id,
          value: {
            rev: winningRev$$1
          }
        };
        var deleted = metadata.deleted;
        if (deleted) {
          if (keys) {
            results.push(row);
            // deleted docs are okay with "keys" requests
            row.value.deleted = true;
            row.doc = null;
          }
        } else if (skip-- <= 0) {
          results.push(row);
          if (opts.include_docs) {
            fetchDocAsynchronously(metadata, row, winningRev$$1);
          }
        }
      }

      function processBatch(batchValues) {
        for (var i = 0, len = batchValues.length; i < len; i++) {
          if (results.length === limit) {
            break;
          }
          var batchValue = batchValues[i];
          if (batchValue.error && keys) {
            // key was not found with "keys" requests
            results.push(batchValue);
            continue;
          }
          var metadata = decodeMetadata(batchValue);
          var winningRev$$1 = metadata.winningRev;
          allDocsInner(winningRev$$1, metadata);
        }
      }

      function onBatch(batchKeys, batchValues, cursor) {
        if (!cursor) {
          return;
        }
        processBatch(batchValues);
        if (results.length < limit) {
          cursor.continue();
        }
      }

      function onGetAll(e) {
        var values = e.target.result;
        if (opts.descending) {
          values = values.reverse();
        }
        processBatch(values);
      }

      function onResultsReady() {
        var returnVal = {
          total_rows: docCount,
          offset: opts.skip,
          rows: results
        };
        
        /* istanbul ignore if */
        if (opts.update_seq && updateSeq !== undefined) {
          returnVal.update_seq = updateSeq;
        }
        callback(null, returnVal);
      }

      function onTxnComplete() {
        if (opts.attachments) {
          postProcessAttachments(results, opts.binary).then(onResultsReady);
        } else {
          onResultsReady();
        }
      }

      // don't bother doing any requests if start > end or limit === 0
      if (keyRangeError || limit === 0) {
        return;
      }
      if (keys) {
        return allDocsKeys(opts.keys, docStore, onBatch);
      }
      if (limit === -1) { // just fetch everything
        return getAll(docStore, keyRange, onGetAll);
      }
      // else do a cursor
      // choose a batch size based on the skip, since we'll need to skip that many
      runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);
    }

    //
    // Blobs are not supported in all versions of IndexedDB, notably
    // Chrome <37 and Android <5. In those versions, storing a blob will throw.
    //
    // Various other blob bugs exist in Chrome v37-42 (inclusive).
    // Detecting them is expensive and confusing to users, and Chrome 37-42
    // is at very low usage worldwide, so we do a hacky userAgent check instead.
    //
    // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
    // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
    // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
    //
    function checkBlobSupport(txn) {
      return new Promise(function (resolve) {
        var blob$$1 = createBlob(['']);
        var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');

        req.onsuccess = function () {
          var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
          var matchedEdge = navigator.userAgent.match(/Edge\//);
          // MS Edge pretends to be Chrome 42:
          // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
          resolve(matchedEdge || !matchedChrome ||
            parseInt(matchedChrome[1], 10) >= 43);
        };

        req.onerror = txn.onabort = function (e) {
          // If the transaction aborts now its due to not being able to
          // write to the database, likely due to the disk being full
          e.preventDefault();
          e.stopPropagation();
          resolve(false);
        };
      }).catch(function () {
        return false; // error, so assume unsupported
      });
    }

    function countDocs(txn, cb) {
      var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
      index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
        cb(e.target.result);
      };
    }

    // This task queue ensures that IDB open calls are done in their own tick

    var running = false;
    var queue$2 = [];

    function tryCode(fun, err, res, PouchDB) {
      try {
        fun(err, res);
      } catch (err) {
        // Shouldn't happen, but in some odd cases
        // IndexedDB implementations might throw a sync
        // error, in which case this will at least log it.
        PouchDB.emit('error', err);
      }
    }

    function applyNext() {
      if (running || !queue$2.length) {
        return;
      }
      running = true;
      queue$2.shift()();
    }

    function enqueueTask(action, callback, PouchDB) {
      queue$2.push(function runAction() {
        action(function runCallback(err, res) {
          tryCode(callback, err, res, PouchDB);
          running = false;
          lib(function runNext() {
            applyNext();
          });
        });
      });
      applyNext();
    }

    function changes(opts, api, dbName, idb) {
      opts = clone(opts);

      if (opts.continuous) {
        var id = dbName + ':' + uuid();
        changesHandler.addListener(dbName, id, api, opts);
        changesHandler.notify(dbName);
        return {
          cancel: function () {
            changesHandler.removeListener(dbName, id);
          }
        };
      }

      var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);

      opts.since = opts.since || 0;
      var lastSeq = opts.since;

      var limit = 'limit' in opts ? opts.limit : -1;
      if (limit === 0) {
        limit = 1; // per CouchDB _changes spec
      }

      var results = [];
      var numResults = 0;
      var filter = filterChange(opts);
      var docIdsToMetadata = new ExportedMap();

      var txn;
      var bySeqStore;
      var docStore;
      var docIdRevIndex;

      function onBatch(batchKeys, batchValues, cursor) {
        if (!cursor || !batchKeys.length) { // done
          return;
        }

        var winningDocs = new Array(batchKeys.length);
        var metadatas = new Array(batchKeys.length);

        function processMetadataAndWinningDoc(metadata, winningDoc) {
          var change = opts.processChange(winningDoc, metadata, opts);
          lastSeq = change.seq = metadata.seq;

          var filtered = filter(change);
          if (typeof filtered === 'object') { // anything but true/false indicates error
            return Promise.reject(filtered);
          }

          if (!filtered) {
            return Promise.resolve();
          }
          numResults++;
          if (opts.return_docs) {
            results.push(change);
          }
          // process the attachment immediately
          // for the benefit of live listeners
          if (opts.attachments && opts.include_docs) {
            return new Promise(function (resolve) {
              fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
                postProcessAttachments([change], opts.binary).then(function () {
                  resolve(change);
                });
              });
            });
          } else {
            return Promise.resolve(change);
          }
        }

        function onBatchDone() {
          var promises = [];
          for (var i = 0, len = winningDocs.length; i < len; i++) {
            if (numResults === limit) {
              break;
            }
            var winningDoc = winningDocs[i];
            if (!winningDoc) {
              continue;
            }
            var metadata = metadatas[i];
            promises.push(processMetadataAndWinningDoc(metadata, winningDoc));
          }

          Promise.all(promises).then(function (changes) {
            for (var i = 0, len = changes.length; i < len; i++) {
              if (changes[i]) {
                opts.onChange(changes[i]);
              }
            }
          }).catch(opts.complete);

          if (numResults !== limit) {
            cursor.continue();
          }
        }

        // Fetch all metadatas/winningdocs from this batch in parallel, then process
        // them all only once all data has been collected. This is done in parallel
        // because it's faster than doing it one-at-a-time.
        var numDone = 0;
        batchValues.forEach(function (value, i) {
          var doc = decodeDoc(value);
          var seq = batchKeys[i];
          fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {
            metadatas[i] = metadata;
            winningDocs[i] = winningDoc;
            if (++numDone === batchKeys.length) {
              onBatchDone();
            }
          });
        });
      }

      function onGetMetadata(doc, seq, metadata, cb) {
        if (metadata.seq !== seq) {
          // some other seq is later
          return cb();
        }

        if (metadata.winningRev === doc._rev) {
          // this is the winning doc
          return cb(metadata, doc);
        }

        // fetch winning doc in separate request
        var docIdRev = doc._id + '::' + metadata.winningRev;
        var req = docIdRevIndex.get(docIdRev);
        req.onsuccess = function (e) {
          cb(metadata, decodeDoc(e.target.result));
        };
      }

      function fetchWinningDocAndMetadata(doc, seq, cb) {
        if (docIds && !docIds.has(doc._id)) {
          return cb();
        }

        var metadata = docIdsToMetadata.get(doc._id);
        if (metadata) { // cached
          return onGetMetadata(doc, seq, metadata, cb);
        }
        // metadata not cached, have to go fetch it
        docStore.get(doc._id).onsuccess = function (e) {
          metadata = decodeMetadata(e.target.result);
          docIdsToMetadata.set(doc._id, metadata);
          onGetMetadata(doc, seq, metadata, cb);
        };
      }

      function finish() {
        opts.complete(null, {
          results: results,
          last_seq: lastSeq
        });
      }

      function onTxnComplete() {
        if (!opts.continuous && opts.attachments) {
          // cannot guarantee that postProcessing was already done,
          // so do it again
          postProcessAttachments(results).then(finish);
        } else {
          finish();
        }
      }

      var objectStores = [DOC_STORE, BY_SEQ_STORE];
      if (opts.attachments) {
        objectStores.push(ATTACH_STORE);
      }
      var txnResult = openTransactionSafely(idb, objectStores, 'readonly');
      if (txnResult.error) {
        return opts.complete(txnResult.error);
      }
      txn = txnResult.txn;
      txn.onabort = idbError(opts.complete);
      txn.oncomplete = onTxnComplete;

      bySeqStore = txn.objectStore(BY_SEQ_STORE);
      docStore = txn.objectStore(DOC_STORE);
      docIdRevIndex = bySeqStore.index('_doc_id_rev');

      var keyRange = (opts.since && !opts.descending) ?
        IDBKeyRange.lowerBound(opts.since, true) : null;

      runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);
    }

    var cachedDBs = new ExportedMap();
    var blobSupportPromise;
    var openReqList = new ExportedMap();

    function IdbPouch(opts, callback) {
      var api = this;

      enqueueTask(function (thisCallback) {
        init$1(api, opts, thisCallback);
      }, callback, api.constructor);
    }

    function init$1(api, opts, callback) {

      var dbName = opts.name;

      var idb = null;
      api._meta = null;

      // called when creating a fresh new database
      function createSchema(db) {
        var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
        db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})
          .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
        db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});
        db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});
        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);

        // added in v2
        docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

        // added in v3
        db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});

        // added in v4
        var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
          {autoIncrement: true});
        attAndSeqStore.createIndex('seq', 'seq');
        attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
      }

      // migration to version 2
      // unfortunately "deletedOrLocal" is a misnomer now that we no longer
      // store local docs in the main doc-store, but whaddyagonnado
      function addDeletedOrLocalIndex(txn, callback) {
        var docStore = txn.objectStore(DOC_STORE);
        docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

        docStore.openCursor().onsuccess = function (event) {
          var cursor = event.target.result;
          if (cursor) {
            var metadata = cursor.value;
            var deleted = isDeleted(metadata);
            metadata.deletedOrLocal = deleted ? "1" : "0";
            docStore.put(metadata);
            cursor.continue();
          } else {
            callback();
          }
        };
      }

      // migration to version 3 (part 1)
      function createLocalStoreSchema(db) {
        db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})
          .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
      }

      // migration to version 3 (part 2)
      function migrateLocalStore(txn, cb) {
        var localStore = txn.objectStore(LOCAL_STORE);
        var docStore = txn.objectStore(DOC_STORE);
        var seqStore = txn.objectStore(BY_SEQ_STORE);

        var cursor = docStore.openCursor();
        cursor.onsuccess = function (event) {
          var cursor = event.target.result;
          if (cursor) {
            var metadata = cursor.value;
            var docId = metadata.id;
            var local = isLocalId(docId);
            var rev$$1 = winningRev(metadata);
            if (local) {
              var docIdRev = docId + "::" + rev$$1;
              // remove all seq entries
              // associated with this docId
              var start = docId + "::";
              var end = docId + "::~";
              var index = seqStore.index('_doc_id_rev');
              var range = IDBKeyRange.bound(start, end, false, false);
              var seqCursor = index.openCursor(range);
              seqCursor.onsuccess = function (e) {
                seqCursor = e.target.result;
                if (!seqCursor) {
                  // done
                  docStore.delete(cursor.primaryKey);
                  cursor.continue();
                } else {
                  var data = seqCursor.value;
                  if (data._doc_id_rev === docIdRev) {
                    localStore.put(data);
                  }
                  seqStore.delete(seqCursor.primaryKey);
                  seqCursor.continue();
                }
              };
            } else {
              cursor.continue();
            }
          } else if (cb) {
            cb();
          }
        };
      }

      // migration to version 4 (part 1)
      function addAttachAndSeqStore(db) {
        var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
          {autoIncrement: true});
        attAndSeqStore.createIndex('seq', 'seq');
        attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
      }

      // migration to version 4 (part 2)
      function migrateAttsAndSeqs(txn, callback) {
        var seqStore = txn.objectStore(BY_SEQ_STORE);
        var attStore = txn.objectStore(ATTACH_STORE);
        var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

        // need to actually populate the table. this is the expensive part,
        // so as an optimization, check first that this database even
        // contains attachments
        var req = attStore.count();
        req.onsuccess = function (e) {
          var count = e.target.result;
          if (!count) {
            return callback(); // done
          }

          seqStore.openCursor().onsuccess = function (e) {
            var cursor = e.target.result;
            if (!cursor) {
              return callback(); // done
            }
            var doc = cursor.value;
            var seq = cursor.primaryKey;
            var atts = Object.keys(doc._attachments || {});
            var digestMap = {};
            for (var j = 0; j < atts.length; j++) {
              var att = doc._attachments[atts[j]];
              digestMap[att.digest] = true; // uniq digests, just in case
            }
            var digests = Object.keys(digestMap);
            for (j = 0; j < digests.length; j++) {
              var digest = digests[j];
              attAndSeqStore.put({
                seq: seq,
                digestSeq: digest + '::' + seq
              });
            }
            cursor.continue();
          };
        };
      }

      // migration to version 5
      // Instead of relying on on-the-fly migration of metadata,
      // this brings the doc-store to its modern form:
      // - metadata.winningrev
      // - metadata.seq
      // - stringify the metadata when storing it
      function migrateMetadata(txn) {

        function decodeMetadataCompat(storedObject) {
          if (!storedObject.data) {
            // old format, when we didn't store it stringified
            storedObject.deleted = storedObject.deletedOrLocal === '1';
            return storedObject;
          }
          return decodeMetadata(storedObject);
        }

        // ensure that every metadata has a winningRev and seq,
        // which was previously created on-the-fly but better to migrate
        var bySeqStore = txn.objectStore(BY_SEQ_STORE);
        var docStore = txn.objectStore(DOC_STORE);
        var cursor = docStore.openCursor();
        cursor.onsuccess = function (e) {
          var cursor = e.target.result;
          if (!cursor) {
            return; // done
          }
          var metadata = decodeMetadataCompat(cursor.value);

          metadata.winningRev = metadata.winningRev ||
            winningRev(metadata);

          function fetchMetadataSeq() {
            // metadata.seq was added post-3.2.0, so if it's missing,
            // we need to fetch it manually
            var start = metadata.id + '::';
            var end = metadata.id + '::\uffff';
            var req = bySeqStore.index('_doc_id_rev').openCursor(
              IDBKeyRange.bound(start, end));

            var metadataSeq = 0;
            req.onsuccess = function (e) {
              var cursor = e.target.result;
              if (!cursor) {
                metadata.seq = metadataSeq;
                return onGetMetadataSeq();
              }
              var seq = cursor.primaryKey;
              if (seq > metadataSeq) {
                metadataSeq = seq;
              }
              cursor.continue();
            };
          }

          function onGetMetadataSeq() {
            var metadataToStore = encodeMetadata(metadata,
              metadata.winningRev, metadata.deleted);

            var req = docStore.put(metadataToStore);
            req.onsuccess = function () {
              cursor.continue();
            };
          }

          if (metadata.seq) {
            return onGetMetadataSeq();
          }

          fetchMetadataSeq();
        };

      }

      api._remote = false;
      api.type = function () {
        return 'idb';
      };

      api._id = toPromise(function (callback) {
        callback(null, api._meta.instanceId);
      });

      api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
        idbBulkDocs(opts, req, reqOpts, api, idb, callback);
      };

      // First we look up the metadata in the ids database, then we fetch the
      // current revision(s) from the by sequence store
      api._get = function idb_get(id, opts, callback) {
        var doc;
        var metadata;
        var err;
        var txn = opts.ctx;
        if (!txn) {
          var txnResult = openTransactionSafely(idb,
            [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
          if (txnResult.error) {
            return callback(txnResult.error);
          }
          txn = txnResult.txn;
        }

        function finish() {
          callback(err, {doc: doc, metadata: metadata, ctx: txn});
        }

        txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
          metadata = decodeMetadata(e.target.result);
          // we can determine the result here if:
          // 1. there is no such document
          // 2. the document is deleted and we don't ask about specific rev
          // When we ask with opts.rev we expect the answer to be either
          // doc (possibly with _deleted=true) or missing error
          if (!metadata) {
            err = createError(MISSING_DOC, 'missing');
            return finish();
          }

          var rev$$1;
          if (!opts.rev) {
            rev$$1 = metadata.winningRev;
            var deleted = isDeleted(metadata);
            if (deleted) {
              err = createError(MISSING_DOC, "deleted");
              return finish();
            }
          } else {
            rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;
          }

          var objectStore = txn.objectStore(BY_SEQ_STORE);
          var key = metadata.id + '::' + rev$$1;

          objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
            doc = e.target.result;
            if (doc) {
              doc = decodeDoc(doc);
            }
            if (!doc) {
              err = createError(MISSING_DOC, 'missing');
              return finish();
            }
            finish();
          };
        };
      };

      api._getAttachment = function (docId, attachId, attachment, opts, callback) {
        var txn;
        if (opts.ctx) {
          txn = opts.ctx;
        } else {
          var txnResult = openTransactionSafely(idb,
            [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
          if (txnResult.error) {
            return callback(txnResult.error);
          }
          txn = txnResult.txn;
        }
        var digest = attachment.digest;
        var type = attachment.content_type;

        txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
          var body = e.target.result.body;
          readBlobData(body, type, opts.binary, function (blobData) {
            callback(null, blobData);
          });
        };
      };

      api._info = function idb_info(callback) {
        var updateSeq;
        var docCount;

        var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');
        if (txnResult.error) {
          return callback(txnResult.error);
        }
        var txn = txnResult.txn;
        txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
          docCount = e.target.result.docCount;
        };
        txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {
          var cursor = e.target.result;
          updateSeq = cursor ? cursor.key : 0;
        };

        txn.oncomplete = function () {
          callback(null, {
            doc_count: docCount,
            update_seq: updateSeq,
            // for debugging
            idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')
          });
        };
      };

      api._allDocs = function idb_allDocs(opts, callback) {
        idbAllDocs(opts, idb, callback);
      };

      api._changes = function idbChanges(opts) {
        return changes(opts, api, dbName, idb);
      };

      api._close = function (callback) {
        // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
        // "Returns immediately and closes the connection in a separate thread..."
        idb.close();
        cachedDBs.delete(dbName);
        callback();
      };

      api._getRevisionTree = function (docId, callback) {
        var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');
        if (txnResult.error) {
          return callback(txnResult.error);
        }
        var txn = txnResult.txn;
        var req = txn.objectStore(DOC_STORE).get(docId);
        req.onsuccess = function (event) {
          var doc = decodeMetadata(event.target.result);
          if (!doc) {
            callback(createError(MISSING_DOC));
          } else {
            callback(null, doc.rev_tree);
          }
        };
      };

      // This function removes revisions of document docId
      // which are listed in revs and sets this document
      // revision to to rev_tree
      api._doCompaction = function (docId, revs, callback) {
        var stores = [
          DOC_STORE,
          BY_SEQ_STORE,
          ATTACH_STORE,
          ATTACH_AND_SEQ_STORE
        ];
        var txnResult = openTransactionSafely(idb, stores, 'readwrite');
        if (txnResult.error) {
          return callback(txnResult.error);
        }
        var txn = txnResult.txn;

        var docStore = txn.objectStore(DOC_STORE);

        docStore.get(docId).onsuccess = function (event) {
          var metadata = decodeMetadata(event.target.result);
          traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                             revHash, ctx, opts) {
            var rev$$1 = pos + '-' + revHash;
            if (revs.indexOf(rev$$1) !== -1) {
              opts.status = 'missing';
            }
          });
          compactRevs(revs, docId, txn);
          var winningRev$$1 = metadata.winningRev;
          var deleted = metadata.deleted;
          txn.objectStore(DOC_STORE).put(
            encodeMetadata(metadata, winningRev$$1, deleted));
        };
        txn.onabort = idbError(callback);
        txn.oncomplete = function () {
          callback();
        };
      };


      api._getLocal = function (id, callback) {
        var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');
        if (txnResult.error) {
          return callback(txnResult.error);
        }
        var tx = txnResult.txn;
        var req = tx.objectStore(LOCAL_STORE).get(id);

        req.onerror = idbError(callback);
        req.onsuccess = function (e) {
          var doc = e.target.result;
          if (!doc) {
            callback(createError(MISSING_DOC));
          } else {
            delete doc['_doc_id_rev']; // for backwards compat
            callback(null, doc);
          }
        };
      };

      api._putLocal = function (doc, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        delete doc._revisions; // ignore this, trust the rev
        var oldRev = doc._rev;
        var id = doc._id;
        if (!oldRev) {
          doc._rev = '0-1';
        } else {
          doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
        }

        var tx = opts.ctx;
        var ret;
        if (!tx) {
          var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
          if (txnResult.error) {
            return callback(txnResult.error);
          }
          tx = txnResult.txn;
          tx.onerror = idbError(callback);
          tx.oncomplete = function () {
            if (ret) {
              callback(null, ret);
            }
          };
        }

        var oStore = tx.objectStore(LOCAL_STORE);
        var req;
        if (oldRev) {
          req = oStore.get(id);
          req.onsuccess = function (e) {
            var oldDoc = e.target.result;
            if (!oldDoc || oldDoc._rev !== oldRev) {
              callback(createError(REV_CONFLICT));
            } else { // update
              var req = oStore.put(doc);
              req.onsuccess = function () {
                ret = {ok: true, id: doc._id, rev: doc._rev};
                if (opts.ctx) { // return immediately
                  callback(null, ret);
                }
              };
            }
          };
        } else { // new doc
          req = oStore.add(doc);
          req.onerror = function (e) {
            // constraint error, already exists
            callback(createError(REV_CONFLICT));
            e.preventDefault(); // avoid transaction abort
            e.stopPropagation(); // avoid transaction onerror
          };
          req.onsuccess = function () {
            ret = {ok: true, id: doc._id, rev: doc._rev};
            if (opts.ctx) { // return immediately
              callback(null, ret);
            }
          };
        }
      };

      api._removeLocal = function (doc, opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        var tx = opts.ctx;
        if (!tx) {
          var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
          if (txnResult.error) {
            return callback(txnResult.error);
          }
          tx = txnResult.txn;
          tx.oncomplete = function () {
            if (ret) {
              callback(null, ret);
            }
          };
        }
        var ret;
        var id = doc._id;
        var oStore = tx.objectStore(LOCAL_STORE);
        var req = oStore.get(id);

        req.onerror = idbError(callback);
        req.onsuccess = function (e) {
          var oldDoc = e.target.result;
          if (!oldDoc || oldDoc._rev !== doc._rev) {
            callback(createError(MISSING_DOC));
          } else {
            oStore.delete(id);
            ret = {ok: true, id: id, rev: '0-0'};
            if (opts.ctx) { // return immediately
              callback(null, ret);
            }
          }
        };
      };

      api._destroy = function (opts, callback) {
        changesHandler.removeAllListeners(dbName);

        //Close open request for "dbName" database to fix ie delay.
        var openReq = openReqList.get(dbName);
        if (openReq && openReq.result) {
          openReq.result.close();
          cachedDBs.delete(dbName);
        }
        var req = indexedDB.deleteDatabase(dbName);

        req.onsuccess = function () {
          //Remove open request from the list.
          openReqList.delete(dbName);
          if (hasLocalStorage() && (dbName in localStorage)) {
            delete localStorage[dbName];
          }
          callback(null, { 'ok': true });
        };

        req.onerror = idbError(callback);
      };

      var cached = cachedDBs.get(dbName);

      if (cached) {
        idb = cached.idb;
        api._meta = cached.global;
        return lib(function () {
          callback(null, api);
        });
      }

      var req = indexedDB.open(dbName, ADAPTER_VERSION);
      openReqList.set(dbName, req);

      req.onupgradeneeded = function (e) {
        var db = e.target.result;
        if (e.oldVersion < 1) {
          return createSchema(db); // new db, initial schema
        }
        // do migrations

        var txn = e.currentTarget.transaction;
        // these migrations have to be done in this function, before
        // control is returned to the event loop, because IndexedDB

        if (e.oldVersion < 3) {
          createLocalStoreSchema(db); // v2 -> v3
        }
        if (e.oldVersion < 4) {
          addAttachAndSeqStore(db); // v3 -> v4
        }

        var migrations = [
          addDeletedOrLocalIndex, // v1 -> v2
          migrateLocalStore,      // v2 -> v3
          migrateAttsAndSeqs,     // v3 -> v4
          migrateMetadata         // v4 -> v5
        ];

        var i = e.oldVersion;

        function next() {
          var migration = migrations[i - 1];
          i++;
          if (migration) {
            migration(txn, next);
          }
        }

        next();
      };

      req.onsuccess = function (e) {

        idb = e.target.result;

        idb.onversionchange = function () {
          idb.close();
          cachedDBs.delete(dbName);
        };

        idb.onabort = function (e) {
          guardedConsole('error', 'Database has a global failure', e.target.error);
          idb.close();
          cachedDBs.delete(dbName);
        };

        // Do a few setup operations (in parallel as much as possible):
        // 1. Fetch meta doc
        // 2. Check blob support
        // 3. Calculate docCount
        // 4. Generate an instanceId if necessary
        // 5. Store docCount and instanceId on meta doc

        var txn = idb.transaction([
          META_STORE,
          DETECT_BLOB_SUPPORT_STORE,
          DOC_STORE
        ], 'readwrite');

        var storedMetaDoc = false;
        var metaDoc;
        var docCount;
        var blobSupport;
        var instanceId;

        function completeSetup() {
          if (typeof blobSupport === 'undefined' || !storedMetaDoc) {
            return;
          }
          api._meta = {
            name: dbName,
            instanceId: instanceId,
            blobSupport: blobSupport
          };

          cachedDBs.set(dbName, {
            idb: idb,
            global: api._meta
          });
          callback(null, api);
        }

        function storeMetaDocIfReady() {
          if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {
            return;
          }
          var instanceKey = dbName + '_id';
          if (instanceKey in metaDoc) {
            instanceId = metaDoc[instanceKey];
          } else {
            metaDoc[instanceKey] = instanceId = uuid();
          }
          metaDoc.docCount = docCount;
          txn.objectStore(META_STORE).put(metaDoc);
        }

        //
        // fetch or generate the instanceId
        //
        txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
          metaDoc = e.target.result || { id: META_STORE };
          storeMetaDocIfReady();
        };

        //
        // countDocs
        //
        countDocs(txn, function (count) {
          docCount = count;
          storeMetaDocIfReady();
        });

        //
        // check blob support
        //
        if (!blobSupportPromise) {
          // make sure blob support is only checked once
          blobSupportPromise = checkBlobSupport(txn);
        }

        blobSupportPromise.then(function (val) {
          blobSupport = val;
          completeSetup();
        });

        // only when the metadata put transaction has completed,
        // consider the setup done
        txn.oncomplete = function () {
          storedMetaDoc = true;
          completeSetup();
        };
        txn.onabort = idbError(callback);
      };

      req.onerror = function (e) {
        var msg = e.target.error && e.target.error.message;

        if (!msg) {
          msg = 'Failed to open indexedDB, are you in private browsing mode?';
        } else if (msg.indexOf("stored database is a higher version") !== -1) {
          msg = new Error('This DB was created with the newer "indexeddb" adapter, but you are trying to open it with the older "idb" adapter');
        }

        guardedConsole('error', msg);
        callback(createError(IDB_ERROR, msg));
      };
    }

    IdbPouch.valid = function () {
      // Following #7085 buggy idb versions (typically Safari < 10.1) are
      // considered valid.

      // On Firefox SecurityError is thrown while referencing indexedDB if cookies
      // are not allowed. `typeof indexedDB` also triggers the error.
      try {
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
      } catch (e) {
        return false;
      }
    };

    function IDBPouch (PouchDB) {
      PouchDB.adapter('idb', IdbPouch, true);
    }

    // dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool
    // but much smaller in code size. limits the number of concurrent promises that are executed


    function pool(promiseFactories, limit) {
      return new Promise(function (resolve, reject) {
        var running = 0;
        var current = 0;
        var done = 0;
        var len = promiseFactories.length;
        var err;

        function runNext() {
          running++;
          promiseFactories[current++]().then(onSuccess, onError);
        }

        function doNext() {
          if (++done === len) {
            /* istanbul ignore if */
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          } else {
            runNextBatch();
          }
        }

        function onSuccess() {
          running--;
          doNext();
        }

        /* istanbul ignore next */
        function onError(thisErr) {
          running--;
          err = err || thisErr;
          doNext();
        }

        function runNextBatch() {
          while (running < limit && current < len) {
            runNext();
          }
        }

        runNextBatch();
      });
    }

    var CHANGES_BATCH_SIZE = 25;
    var MAX_SIMULTANEOUS_REVS = 50;
    var CHANGES_TIMEOUT_BUFFER = 5000;
    var DEFAULT_HEARTBEAT = 10000;

    var supportsBulkGetMap = {};

    function readAttachmentsAsBlobOrBuffer(row) {
      var doc = row.doc || row.ok;
      var atts = doc && doc._attachments;
      if (!atts) {
        return;
      }
      Object.keys(atts).forEach(function (filename) {
        var att = atts[filename];
        att.data = b64ToBluffer(att.data, att.content_type);
      });
    }

    function encodeDocId(id) {
      if (/^_design/.test(id)) {
        return '_design/' + encodeURIComponent(id.slice(8));
      }
      if (/^_local/.test(id)) {
        return '_local/' + encodeURIComponent(id.slice(7));
      }
      return encodeURIComponent(id);
    }

    function preprocessAttachments$1(doc) {
      if (!doc._attachments || !Object.keys(doc._attachments)) {
        return Promise.resolve();
      }

      return Promise.all(Object.keys(doc._attachments).map(function (key) {
        var attachment = doc._attachments[key];
        if (attachment.data && typeof attachment.data !== 'string') {
          return new Promise(function (resolve) {
            blobToBase64(attachment.data, resolve);
          }).then(function (b64) {
            attachment.data = b64;
          });
        }
      }));
    }

    function hasUrlPrefix(opts) {
      if (!opts.prefix) {
        return false;
      }
      var protocol = parseUri(opts.prefix).protocol;
      return protocol === 'http' || protocol === 'https';
    }

    // Get all the information you possibly can about the URI given by name and
    // return it as a suitable object.
    function getHost(name, opts) {
      // encode db name if opts.prefix is a url (#5574)
      if (hasUrlPrefix(opts)) {
        var dbName = opts.name.substr(opts.prefix.length);
        // Ensure prefix has a trailing slash
        var prefix = opts.prefix.replace(/\/?$/, '/');
        name = prefix + encodeURIComponent(dbName);
      }

      var uri = parseUri(name);
      if (uri.user || uri.password) {
        uri.auth = {username: uri.user, password: uri.password};
      }

      // Split the path part of the URI into parts using '/' as the delimiter
      // after removing any leading '/' and any trailing '/'
      var parts = uri.path.replace(/(^\/|\/$)/g, '').split('/');

      uri.db = parts.pop();
      // Prevent double encoding of URI component
      if (uri.db.indexOf('%') === -1) {
        uri.db = encodeURIComponent(uri.db);
      }

      uri.path = parts.join('/');

      return uri;
    }

    // Generate a URL with the host data given by opts and the given path
    function genDBUrl(opts, path) {
      return genUrl(opts, opts.db + '/' + path);
    }

    // Generate a URL with the host data given by opts and the given path
    function genUrl(opts, path) {
      // If the host already has a path, then we need to have a path delimiter
      // Otherwise, the path delimiter is the empty string
      var pathDel = !opts.path ? '' : '/';

      // If the host already has a path, then we need to have a path delimiter
      // Otherwise, the path delimiter is the empty string
      return opts.protocol + '://' + opts.host +
             (opts.port ? (':' + opts.port) : '') +
             '/' + opts.path + pathDel + path;
    }

    function paramsToStr(params) {
      return '?' + Object.keys(params).map(function (k) {
        return k + '=' + encodeURIComponent(params[k]);
      }).join('&');
    }

    function shouldCacheBust(opts) {
      var ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?
          navigator.userAgent.toLowerCase() : '';
      var isIE = ua.indexOf('msie') !== -1;
      var isTrident = ua.indexOf('trident') !== -1;
      var isEdge = ua.indexOf('edge') !== -1;
      var isGET = !('method' in opts) || opts.method === 'GET';
      return (isIE || isTrident || isEdge) && isGET;
    }

    // Implements the PouchDB API for dealing with CouchDB instances over HTTP
    function HttpPouch(opts, callback) {

      // The functions that will be publicly available for HttpPouch
      var api = this;

      var host = getHost(opts.name, opts);
      var dbUrl = genDBUrl(host, '');

      opts = clone(opts);

      var ourFetch = function (url, options) {

        options = options || {};
        options.headers = options.headers || new h();

        options.credentials = 'include';

        if (opts.auth || host.auth) {
          var nAuth = opts.auth || host.auth;
          var str = nAuth.username + ':' + nAuth.password;
          var token = thisBtoa(unescape(encodeURIComponent(str)));
          options.headers.set('Authorization', 'Basic ' + token);
        }

        var headers = opts.headers || {};
        Object.keys(headers).forEach(function (key) {
          options.headers.append(key, headers[key]);
        });

        /* istanbul ignore if */
        if (shouldCacheBust(options)) {
          url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();
        }

        var fetchFun = opts.fetch || f$1;
        return fetchFun(url, options);
      };

      function adapterFun$$1(name, fun) {
        return adapterFun(name, argsarray(function (args) {
          setup().then(function () {
            return fun.apply(this, args);
          }).catch(function (e) {
            var callback = args.pop();
            callback(e);
          });
        })).bind(api);
      }

      function fetchJSON(url, options, callback) {

        var result = {};

        options = options || {};
        options.headers = options.headers || new h();

        if (!options.headers.get('Content-Type')) {
          options.headers.set('Content-Type', 'application/json');
        }
        if (!options.headers.get('Accept')) {
          options.headers.set('Accept', 'application/json');
        }

        return ourFetch(url, options).then(function (response) {
          result.ok = response.ok;
          result.status = response.status;
          return response.json();
        }).then(function (json) {
          result.data = json;
          if (!result.ok) {
            result.data.status = result.status;
            var err = generateErrorFromResponse(result.data);
            if (callback) {
              return callback(err);
            } else {
              throw err;
            }
          }

          if (Array.isArray(result.data)) {
            result.data = result.data.map(function (v) {
              if (v.error || v.missing) {
                return generateErrorFromResponse(v);
              } else {
                return v;
              }
            });
          }

          if (callback) {
            callback(null, result.data);
          } else {
            return result;
          }
        });
      }

      var setupPromise;

      function setup() {
        if (opts.skip_setup) {
          return Promise.resolve();
        }

        // If there is a setup in process or previous successful setup
        // done then we will use that
        // If previous setups have been rejected we will try again
        if (setupPromise) {
          return setupPromise;
        }

        setupPromise = fetchJSON(dbUrl).catch(function (err) {
          if (err && err.status && err.status === 404) {
            // Doesnt exist, create it
            explainError(404, 'PouchDB is just detecting if the remote exists.');
            return fetchJSON(dbUrl, {method: 'PUT'});
          } else {
            return Promise.reject(err);
          }
        }).catch(function (err) {
          // If we try to create a database that already exists, skipped in
          // istanbul since its catching a race condition.
          /* istanbul ignore if */
          if (err && err.status && err.status === 412) {
            return true;
          }
          return Promise.reject(err);
        });

        setupPromise.catch(function () {
          setupPromise = null;
        });

        return setupPromise;
      }

      lib(function () {
        callback(null, api);
      });

      api._remote = true;

      /* istanbul ignore next */
      api.type = function () {
        return 'http';
      };

      api.id = adapterFun$$1('id', function (callback) {
        ourFetch(genUrl(host, '')).then(function (response) {
          return response.json();
        }).catch(function () {
          return {};
        }).then(function (result) {
          // Bad response or missing `uuid` should not prevent ID generation.
          var uuid$$1 = (result && result.uuid) ?
              (result.uuid + host.db) : genDBUrl(host, '');
          callback(null, uuid$$1);
        });
      });

      // Sends a POST request to the host calling the couchdb _compact function
      //    version: The version of CouchDB it is running
      api.compact = adapterFun$$1('compact', function (opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        opts = clone(opts);

        fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'}).then(function () {
          function ping() {
            api.info(function (err, res) {
              // CouchDB may send a "compact_running:true" if it's
              // already compacting. PouchDB Server doesn't.
              /* istanbul ignore else */
              if (res && !res.compact_running) {
                callback(null, {ok: true});
              } else {
                setTimeout(ping, opts.interval || 200);
              }
            });
          }
          // Ping the http if it's finished compaction
          ping();
        });
      });

      api.bulkGet = adapterFun('bulkGet', function (opts, callback) {
        var self = this;

        function doBulkGet(cb) {
          var params = {};
          if (opts.revs) {
            params.revs = true;
          }
          if (opts.attachments) {
            /* istanbul ignore next */
            params.attachments = true;
          }
          if (opts.latest) {
            params.latest = true;
          }
          fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {
            method: 'POST',
            body: JSON.stringify({ docs: opts.docs})
          }).then(function (result) {
            if (opts.attachments && opts.binary) {
              result.data.results.forEach(function (res) {
                res.docs.forEach(readAttachmentsAsBlobOrBuffer);
              });
            }
            cb(null, result.data);
          }).catch(cb);
        }

        /* istanbul ignore next */
        function doBulkGetShim() {
          // avoid "url too long error" by splitting up into multiple requests
          var batchSize = MAX_SIMULTANEOUS_REVS;
          var numBatches = Math.ceil(opts.docs.length / batchSize);
          var numDone = 0;
          var results = new Array(numBatches);

          function onResult(batchNum) {
            return function (err, res) {
              // err is impossible because shim returns a list of errs in that case
              results[batchNum] = res.results;
              if (++numDone === numBatches) {
                callback(null, {results: flatten(results)});
              }
            };
          }

          for (var i = 0; i < numBatches; i++) {
            var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);
            subOpts.docs = opts.docs.slice(i * batchSize,
              Math.min(opts.docs.length, (i + 1) * batchSize));
            bulkGet(self, subOpts, onResult(i));
          }
        }

        // mark the whole database as either supporting or not supporting _bulk_get
        var dbUrl = genUrl(host, '');
        var supportsBulkGet = supportsBulkGetMap[dbUrl];

        /* istanbul ignore next */
        if (typeof supportsBulkGet !== 'boolean') {
          // check if this database supports _bulk_get
          doBulkGet(function (err, res) {
            if (err) {
              supportsBulkGetMap[dbUrl] = false;
              explainError(
                err.status,
                'PouchDB is just detecting if the remote ' +
                'supports the _bulk_get API.'
              );
              doBulkGetShim();
            } else {
              supportsBulkGetMap[dbUrl] = true;
              callback(null, res);
            }
          });
        } else if (supportsBulkGet) {
          doBulkGet(callback);
        } else {
          doBulkGetShim();
        }
      });

      // Calls GET on the host, which gets back a JSON string containing
      //    couchdb: A welcome string
      //    version: The version of CouchDB it is running
      api._info = function (callback) {
        setup().then(function () {
          return ourFetch(genDBUrl(host, ''));
        }).then(function (response) {
          return response.json();
        }).then(function (info) {
          info.host = genDBUrl(host, '');
          callback(null, info);
        }).catch(callback);
      };

      api.fetch = function (path, options) {
        return setup().then(function () {
          var url = path.substring(0, 1) === '/' ?
            genUrl(host, path.substring(1)) :
            genDBUrl(host, path);
          return ourFetch(url, options);
        });
      };

      // Get the document with the given id from the database given by host.
      // The id could be solely the _id in the database, or it may be a
      // _design/ID or _local/ID path
      api.get = adapterFun$$1('get', function (id, opts, callback) {
        // If no options were given, set the callback to the second parameter
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        opts = clone(opts);

        // List of parameters to add to the GET request
        var params = {};

        if (opts.revs) {
          params.revs = true;
        }

        if (opts.revs_info) {
          params.revs_info = true;
        }

        if (opts.latest) {
          params.latest = true;
        }

        if (opts.open_revs) {
          if (opts.open_revs !== "all") {
            opts.open_revs = JSON.stringify(opts.open_revs);
          }
          params.open_revs = opts.open_revs;
        }

        if (opts.rev) {
          params.rev = opts.rev;
        }

        if (opts.conflicts) {
          params.conflicts = opts.conflicts;
        }

        /* istanbul ignore if */
        if (opts.update_seq) {
          params.update_seq = opts.update_seq;
        }

        id = encodeDocId(id);

        function fetchAttachments(doc) {
          var atts = doc._attachments;
          var filenames = atts && Object.keys(atts);
          if (!atts || !filenames.length) {
            return;
          }
          // we fetch these manually in separate XHRs, because
          // Sync Gateway would normally send it back as multipart/mixed,
          // which we cannot parse. Also, this is more efficient than
          // receiving attachments as base64-encoded strings.
          function fetchData(filename) {
            var att = atts[filename];
            var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +
                '?rev=' + doc._rev;
            return ourFetch(genDBUrl(host, path)).then(function (response) {
              if ('buffer' in response) {
                return response.buffer();
              } else {
                /* istanbul ignore next */
                return response.blob();
              }
            }).then(function (blob) {
              if (opts.binary) {
                var typeFieldDescriptor = Object.getOwnPropertyDescriptor(blob.__proto__, 'type');
                if (!typeFieldDescriptor || typeFieldDescriptor.set) {
                  blob.type = att.content_type;
                }
                return blob;
              }
              return new Promise(function (resolve) {
                blobToBase64(blob, resolve);
              });
            }).then(function (data) {
              delete att.stub;
              delete att.length;
              att.data = data;
            });
          }

          var promiseFactories = filenames.map(function (filename) {
            return function () {
              return fetchData(filename);
            };
          });

          // This limits the number of parallel xhr requests to 5 any time
          // to avoid issues with maximum browser request limits
          return pool(promiseFactories, 5);
        }

        function fetchAllAttachments(docOrDocs) {
          if (Array.isArray(docOrDocs)) {
            return Promise.all(docOrDocs.map(function (doc) {
              if (doc.ok) {
                return fetchAttachments(doc.ok);
              }
            }));
          }
          return fetchAttachments(docOrDocs);
        }

        var url = genDBUrl(host, id + paramsToStr(params));
        fetchJSON(url).then(function (res) {
          return Promise.resolve().then(function () {
            if (opts.attachments) {
              return fetchAllAttachments(res.data);
            }
          }).then(function () {
            callback(null, res.data);
          });
        }).catch(function (e) {
          e.docId = id;
          callback(e);
        });
      });


      // Delete the document given by doc from the database given by host.
      api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, cb) {
        var doc;
        if (typeof optsOrRev === 'string') {
          // id, rev, opts, callback style
          doc = {
            _id: docOrId,
            _rev: optsOrRev
          };
          if (typeof opts === 'function') {
            cb = opts;
            opts = {};
          }
        } else {
          // doc, opts, callback style
          doc = docOrId;
          if (typeof optsOrRev === 'function') {
            cb = optsOrRev;
            opts = {};
          } else {
            cb = opts;
            opts = optsOrRev;
          }
        }

        var rev$$1 = (doc._rev || opts.rev);
        var url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1;

        fetchJSON(url, {method: 'DELETE'}, cb).catch(cb);
      });

      function encodeAttachmentId(attachmentId) {
        return attachmentId.split("/").map(encodeURIComponent).join("/");
      }

      // Get the attachment
      api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId,
                                                                opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        var params = opts.rev ? ('?rev=' + opts.rev) : '';
        var url = genDBUrl(host, encodeDocId(docId)) + '/' +
            encodeAttachmentId(attachmentId) + params;
        var contentType;
        ourFetch(url, {method: 'GET'}).then(function (response) {
          contentType = response.headers.get('content-type');
          if (!response.ok) {
            throw response;
          } else {
            if (typeof process !== 'undefined' && !browser$1 && typeof response.buffer === 'function') {
              return response.buffer();
            } else {
              /* istanbul ignore next */
              return response.blob();
            }
          }
        }).then(function (blob) {
          // TODO: also remove
          if (typeof process !== 'undefined' && !browser$1) {
            blob.type = contentType;
          }
          callback(null, blob);
        }).catch(function (err) {
          callback(err);
        });
      });

      // Remove the attachment given by the id and rev
      api.removeAttachment =  adapterFun$$1('removeAttachment', function (docId,
                                                                       attachmentId,
                                                                       rev$$1,
                                                                       callback) {
        var url = genDBUrl(host, encodeDocId(docId) + '/' +
                           encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;
        fetchJSON(url, {method: 'DELETE'}, callback).catch(callback);
      });

      // Add the attachment given by blob and its contentType property
      // to the document with the given id, the revision given by rev, and
      // add it to the database given by host.
      api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId,
                                                                rev$$1, blob,
                                                                type, callback) {
        if (typeof type === 'function') {
          callback = type;
          type = blob;
          blob = rev$$1;
          rev$$1 = null;
        }
        var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
        var url = genDBUrl(host, id);
        if (rev$$1) {
          url += '?rev=' + rev$$1;
        }

        if (typeof blob === 'string') {
          // input is assumed to be a base64 string
          var binary;
          try {
            binary = thisAtob(blob);
          } catch (err) {
            return callback(createError(BAD_ARG,
                            'Attachment is not a valid base64 string'));
          }
          blob = binary ? binStringToBluffer(binary, type) : '';
        }

        // Add the attachment
        fetchJSON(url, {
          headers: new h({'Content-Type': type}),
          method: 'PUT',
          body: blob
        }, callback).catch(callback);
      });

      // Update/create multiple documents given by req in the database
      // given by host.
      api._bulkDocs = function (req, opts, callback) {
        // If new_edits=false then it prevents the database from creating
        // new revision numbers for the documents. Instead it just uses
        // the old ones. This is used in database replication.
        req.new_edits = opts.new_edits;

        setup().then(function () {
          return Promise.all(req.docs.map(preprocessAttachments$1));
        }).then(function () {
          // Update/create the documents
          return fetchJSON(genDBUrl(host, '_bulk_docs'), {
            method: 'POST',
            body: JSON.stringify(req)
          }, callback);
        }).catch(callback);
      };


      // Update/create document
      api._put = function (doc, opts, callback) {
        setup().then(function () {
          return preprocessAttachments$1(doc);
        }).then(function () {
          return fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {
            method: 'PUT',
            body: JSON.stringify(doc)
          });
        }).then(function (result) {
          callback(null, result.data);
        }).catch(function (err) {
          err.docId = doc && doc._id;
          callback(err);
        });
      };


      // Get a listing of the documents in the database given
      // by host and ordered by increasing id.
      api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        opts = clone(opts);

        // List of parameters to add to the GET request
        var params = {};
        var body;
        var method = 'GET';

        if (opts.conflicts) {
          params.conflicts = true;
        }

        /* istanbul ignore if */
        if (opts.update_seq) {
          params.update_seq = true;
        }

        if (opts.descending) {
          params.descending = true;
        }

        if (opts.include_docs) {
          params.include_docs = true;
        }

        // added in CouchDB 1.6.0
        if (opts.attachments) {
          params.attachments = true;
        }

        if (opts.key) {
          params.key = JSON.stringify(opts.key);
        }

        if (opts.start_key) {
          opts.startkey = opts.start_key;
        }

        if (opts.startkey) {
          params.startkey = JSON.stringify(opts.startkey);
        }

        if (opts.end_key) {
          opts.endkey = opts.end_key;
        }

        if (opts.endkey) {
          params.endkey = JSON.stringify(opts.endkey);
        }

        if (typeof opts.inclusive_end !== 'undefined') {
          params.inclusive_end = !!opts.inclusive_end;
        }

        if (typeof opts.limit !== 'undefined') {
          params.limit = opts.limit;
        }

        if (typeof opts.skip !== 'undefined') {
          params.skip = opts.skip;
        }

        var paramStr = paramsToStr(params);

        if (typeof opts.keys !== 'undefined') {
          method = 'POST';
          body = {keys: opts.keys};
        }

        fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {
           method: method,
          body: JSON.stringify(body)
        }).then(function (result) {
          if (opts.include_docs && opts.attachments && opts.binary) {
            result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);
          }
          callback(null, result.data);
        }).catch(callback);
      });

      // Get a list of changes made to documents in the database given by host.
      // TODO According to the README, there should be two other methods here,
      // api.changes.addListener and api.changes.removeListener.
      api._changes = function (opts) {

        // We internally page the results of a changes request, this means
        // if there is a large set of changes to be returned we can start
        // processing them quicker instead of waiting on the entire
        // set of changes to return and attempting to process them at once
        var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;

        opts = clone(opts);

        if (opts.continuous && !('heartbeat' in opts)) {
          opts.heartbeat = DEFAULT_HEARTBEAT;
        }

        var requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;

        // ensure CHANGES_TIMEOUT_BUFFER applies
        if ('timeout' in opts && opts.timeout &&
          (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {
            requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;
        }

        /* istanbul ignore if */
        if ('heartbeat' in opts && opts.heartbeat &&
           (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {
            requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;
        }

        var params = {};
        if ('timeout' in opts && opts.timeout) {
          params.timeout = opts.timeout;
        }

        var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
        var leftToFetch = limit;

        if (opts.style) {
          params.style = opts.style;
        }

        if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
          params.include_docs = true;
        }

        if (opts.attachments) {
          params.attachments = true;
        }

        if (opts.continuous) {
          params.feed = 'longpoll';
        }

        if (opts.seq_interval) {
          params.seq_interval = opts.seq_interval;
        }

        if (opts.conflicts) {
          params.conflicts = true;
        }

        if (opts.descending) {
          params.descending = true;
        }

        /* istanbul ignore if */
        if (opts.update_seq) {
          params.update_seq = true;
        }

        if ('heartbeat' in opts) {
          // If the heartbeat value is false, it disables the default heartbeat
          if (opts.heartbeat) {
            params.heartbeat = opts.heartbeat;
          }
        }

        if (opts.filter && typeof opts.filter === 'string') {
          params.filter = opts.filter;
        }

        if (opts.view && typeof opts.view === 'string') {
          params.filter = '_view';
          params.view = opts.view;
        }

        // If opts.query_params exists, pass it through to the changes request.
        // These parameters may be used by the filter on the source database.
        if (opts.query_params && typeof opts.query_params === 'object') {
          for (var param_name in opts.query_params) {
            /* istanbul ignore else */
            if (opts.query_params.hasOwnProperty(param_name)) {
              params[param_name] = opts.query_params[param_name];
            }
          }
        }

        var method = 'GET';
        var body;

        if (opts.doc_ids) {
          // set this automagically for the user; it's annoying that couchdb
          // requires both a "filter" and a "doc_ids" param.
          params.filter = '_doc_ids';
          method = 'POST';
          body = {doc_ids: opts.doc_ids };
        }
        /* istanbul ignore next */
        else if (opts.selector) {
          // set this automagically for the user, similar to above
          params.filter = '_selector';
          method = 'POST';
          body = {selector: opts.selector };
        }

        var controller = new a();
        var lastFetchedSeq;

        // Get all the changes starting wtih the one immediately after the
        // sequence number given by since.
        var fetchData = function (since, callback) {
          if (opts.aborted) {
            return;
          }
          params.since = since;
          // "since" can be any kind of json object in Cloudant/CouchDB 2.x
          /* istanbul ignore next */
          if (typeof params.since === "object") {
            params.since = JSON.stringify(params.since);
          }

          if (opts.descending) {
            if (limit) {
              params.limit = leftToFetch;
            }
          } else {
            params.limit = (!limit || leftToFetch > batchSize) ?
              batchSize : leftToFetch;
          }

          // Set the options for the ajax call
          var url = genDBUrl(host, '_changes' + paramsToStr(params));
          var fetchOpts = {
            signal: controller.signal,
            method: method,
            body: JSON.stringify(body)
          };
          lastFetchedSeq = since;

          /* istanbul ignore if */
          if (opts.aborted) {
            return;
          }

          // Get the changes
          setup().then(function () {
            return fetchJSON(url, fetchOpts, callback);
          }).catch(callback);
        };

        // If opts.since exists, get all the changes from the sequence
        // number given by opts.since. Otherwise, get all the changes
        // from the sequence number 0.
        var results = {results: []};

        var fetched = function (err, res) {
          if (opts.aborted) {
            return;
          }
          var raw_results_length = 0;
          // If the result of the ajax call (res) contains changes (res.results)
          if (res && res.results) {
            raw_results_length = res.results.length;
            results.last_seq = res.last_seq;
            var pending = null;
            var lastSeq = null;
            // Attach 'pending' property if server supports it (CouchDB 2.0+)
            /* istanbul ignore if */
            if (typeof res.pending === 'number') {
              pending = res.pending;
            }
            if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {
              lastSeq = results.last_seq;
            }
            // For each change
            var req = {};
            req.query = opts.query_params;
            res.results = res.results.filter(function (c) {
              leftToFetch--;
              var ret = filterChange(opts)(c);
              if (ret) {
                if (opts.include_docs && opts.attachments && opts.binary) {
                  readAttachmentsAsBlobOrBuffer(c);
                }
                if (opts.return_docs) {
                  results.results.push(c);
                }
                opts.onChange(c, pending, lastSeq);
              }
              return ret;
            });
          } else if (err) {
            // In case of an error, stop listening for changes and call
            // opts.complete
            opts.aborted = true;
            opts.complete(err);
            return;
          }

          // The changes feed may have timed out with no results
          // if so reuse last update sequence
          if (res && res.last_seq) {
            lastFetchedSeq = res.last_seq;
          }

          var finished = (limit && leftToFetch <= 0) ||
            (res && raw_results_length < batchSize) ||
            (opts.descending);

          if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {
            // Queue a call to fetch again with the newest sequence number
            lib(function () { fetchData(lastFetchedSeq, fetched); });
          } else {
            // We're done, call the callback
            opts.complete(null, results);
          }
        };

        fetchData(opts.since || 0, fetched);

        // Return a method to cancel this method from processing any more
        return {
          cancel: function () {
            opts.aborted = true;
            controller.abort();
          }
        };
      };

      // Given a set of document/revision IDs (given by req), tets the subset of
      // those that do NOT correspond to revisions stored in the database.
      // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
      api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {
        // If no options were given, set the callback to be the second parameter
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }

        // Get the missing document/revision IDs
        fetchJSON(genDBUrl(host, '_revs_diff'), {
          method: 'POST',
          body: JSON.stringify(req)
        }, callback).catch(callback);
      });

      api._close = function (callback) {
        callback();
      };

      api._destroy = function (options, callback) {
        fetchJSON(genDBUrl(host, ''), {method: 'DELETE'}).then(function (json) {
          callback(null, json);
        }).catch(function (err) {
          /* istanbul ignore if */
          if (err.status === 404) {
            callback(null, {ok: true});
          } else {
            callback(err);
          }
        });
      };
    }

    // HttpPouch is a valid adapter.
    HttpPouch.valid = function () {
      return true;
    };

    function HttpPouch$1 (PouchDB) {
      PouchDB.adapter('http', HttpPouch, false);
      PouchDB.adapter('https', HttpPouch, false);
    }

    function QueryParseError(message) {
      this.status = 400;
      this.name = 'query_parse_error';
      this.message = message;
      this.error = true;
      try {
        Error.captureStackTrace(this, QueryParseError);
      } catch (e) {}
    }

    inherits_browser(QueryParseError, Error);

    function NotFoundError(message) {
      this.status = 404;
      this.name = 'not_found';
      this.message = message;
      this.error = true;
      try {
        Error.captureStackTrace(this, NotFoundError);
      } catch (e) {}
    }

    inherits_browser(NotFoundError, Error);

    function BuiltInError(message) {
      this.status = 500;
      this.name = 'invalid_value';
      this.message = message;
      this.error = true;
      try {
        Error.captureStackTrace(this, BuiltInError);
      } catch (e) {}
    }

    inherits_browser(BuiltInError, Error);

    function promisedCallback(promise, callback) {
      if (callback) {
        promise.then(function (res) {
          lib(function () {
            callback(null, res);
          });
        }, function (reason) {
          lib(function () {
            callback(reason);
          });
        });
      }
      return promise;
    }

    function callbackify(fun) {
      return argsarray(function (args) {
        var cb = args.pop();
        var promise = fun.apply(this, args);
        if (typeof cb === 'function') {
          promisedCallback(promise, cb);
        }
        return promise;
      });
    }

    // Promise finally util similar to Q.finally
    function fin(promise, finalPromiseFactory) {
      return promise.then(function (res) {
        return finalPromiseFactory().then(function () {
          return res;
        });
      }, function (reason) {
        return finalPromiseFactory().then(function () {
          throw reason;
        });
      });
    }

    function sequentialize(queue, promiseFactory) {
      return function () {
        var args = arguments;
        var that = this;
        return queue.add(function () {
          return promiseFactory.apply(that, args);
        });
      };
    }

    // uniq an array of strings, order not guaranteed
    // similar to underscore/lodash _.uniq
    function uniq(arr) {
      var theSet = new ExportedSet(arr);
      var result = new Array(theSet.size);
      var index = -1;
      theSet.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }

    function mapToKeysArray(map) {
      var result = new Array(map.size);
      var index = -1;
      map.forEach(function (value, key) {
        result[++index] = key;
      });
      return result;
    }

    function createBuiltInError(name) {
      var message = 'builtin ' + name +
        ' function requires map values to be numbers' +
        ' or number arrays';
      return new BuiltInError(message);
    }

    function sum(values) {
      var result = 0;
      for (var i = 0, len = values.length; i < len; i++) {
        var num = values[i];
        if (typeof num !== 'number') {
          if (Array.isArray(num)) {
            // lists of numbers are also allowed, sum them separately
            result = typeof result === 'number' ? [result] : result;
            for (var j = 0, jLen = num.length; j < jLen; j++) {
              var jNum = num[j];
              if (typeof jNum !== 'number') {
                throw createBuiltInError('_sum');
              } else if (typeof result[j] === 'undefined') {
                result.push(jNum);
              } else {
                result[j] += jNum;
              }
            }
          } else { // not array/number
            throw createBuiltInError('_sum');
          }
        } else if (typeof result === 'number') {
          result += num;
        } else { // add number to array
          result[0] += num;
        }
      }
      return result;
    }

    var log = guardedConsole.bind(null, 'log');
    var isArray = Array.isArray;
    var toJSON = JSON.parse;

    function evalFunctionWithEval(func, emit) {
      return scopeEval(
        "return (" + func.replace(/;\s*$/, "") + ");",
        {
          emit: emit,
          sum: sum,
          log: log,
          isArray: isArray,
          toJSON: toJSON
        }
      );
    }

    /*
     * Simple task queue to sequentialize actions. Assumes
     * callbacks will eventually fire (once).
     */


    function TaskQueue$1() {
      this.promise = new Promise(function (fulfill) {fulfill(); });
    }
    TaskQueue$1.prototype.add = function (promiseFactory) {
      this.promise = this.promise.catch(function () {
        // just recover
      }).then(function () {
        return promiseFactory();
      });
      return this.promise;
    };
    TaskQueue$1.prototype.finish = function () {
      return this.promise;
    };

    function stringify$1(input) {
      if (!input) {
        return 'undefined'; // backwards compat for empty reduce
      }
      // for backwards compat with mapreduce, functions/strings are stringified
      // as-is. everything else is JSON-stringified.
      switch (typeof input) {
        case 'function':
          // e.g. a mapreduce map
          return input.toString();
        case 'string':
          // e.g. a mapreduce built-in _reduce function
          return input.toString();
        default:
          // e.g. a JSON object in the case of mango queries
          return JSON.stringify(input);
      }
    }

    /* create a string signature for a view so we can cache it and uniq it */
    function createViewSignature(mapFun, reduceFun) {
      // the "undefined" part is for backwards compatibility
      return stringify$1(mapFun) + stringify$1(reduceFun) + 'undefined';
    }

    function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {
      var viewSignature = createViewSignature(mapFun, reduceFun);

      var cachedViews;
      if (!temporary) {
        // cache this to ensure we don't try to update the same view twice
        cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};
        if (cachedViews[viewSignature]) {
          return cachedViews[viewSignature];
        }
      }

      var promiseForView = sourceDB.info().then(function (info) {

        var depDbName = info.db_name + '-mrview-' +
          (temporary ? 'temp' : stringMd5(viewSignature));

        // save the view name in the source db so it can be cleaned up if necessary
        // (e.g. when the _design doc is deleted, remove all associated view data)
        function diffFunction(doc) {
          doc.views = doc.views || {};
          var fullViewName = viewName;
          if (fullViewName.indexOf('/') === -1) {
            fullViewName = viewName + '/' + viewName;
          }
          var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
          /* istanbul ignore if */
          if (depDbs[depDbName]) {
            return; // no update necessary
          }
          depDbs[depDbName] = true;
          return doc;
        }
        return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {
          return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
            var db = res.db;
            db.auto_compaction = true;
            var view = {
              name: depDbName,
              db: db,
              sourceDB: sourceDB,
              adapter: sourceDB.adapter,
              mapFun: mapFun,
              reduceFun: reduceFun
            };
            return view.db.get('_local/lastSeq').catch(function (err) {
              /* istanbul ignore if */
              if (err.status !== 404) {
                throw err;
              }
            }).then(function (lastSeqDoc) {
              view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
              if (cachedViews) {
                view.db.once('destroyed', function () {
                  delete cachedViews[viewSignature];
                });
              }
              return view;
            });
          });
        });
      });

      if (cachedViews) {
        cachedViews[viewSignature] = promiseForView;
      }
      return promiseForView;
    }

    var persistentQueues = {};
    var tempViewQueue = new TaskQueue$1();
    var CHANGES_BATCH_SIZE$1 = 50;

    function parseViewName(name) {
      // can be either 'ddocname/viewname' or just 'viewname'
      // (where the ddoc name is the same)
      return name.indexOf('/') === -1 ? [name, name] : name.split('/');
    }

    function isGenOne(changes) {
      // only return true if the current change is 1-
      // and there are no other leafs
      return changes.length === 1 && /^1-/.test(changes[0].rev);
    }

    function emitError(db, e) {
      try {
        db.emit('error', e);
      } catch (err) {
        guardedConsole('error',
          'The user\'s map/reduce function threw an uncaught error.\n' +
          'You can debug this error by doing:\n' +
          'myDatabase.on(\'error\', function (err) { debugger; });\n' +
          'Please double-check your map/reduce function.');
        guardedConsole('error', e);
      }
    }

    /**
     * Returns an "abstract" mapreduce object of the form:
     *
     *   {
     *     query: queryFun,
     *     viewCleanup: viewCleanupFun
     *   }
     *
     * Arguments are:
     *
     * localDoc: string
     *   This is for the local doc that gets saved in order to track the
     *   "dependent" DBs and clean them up for viewCleanup. It should be
     *   unique, so that indexer plugins don't collide with each other.
     * mapper: function (mapFunDef, emit)
     *   Returns a map function based on the mapFunDef, which in the case of
     *   normal map/reduce is just the de-stringified function, but may be
     *   something else, such as an object in the case of pouchdb-find.
     * reducer: function (reduceFunDef)
     *   Ditto, but for reducing. Modules don't have to support reducing
     *   (e.g. pouchdb-find).
     * ddocValidator: function (ddoc, viewName)
     *   Throws an error if the ddoc or viewName is not valid.
     *   This could be a way to communicate to the user that the configuration for the
     *   indexer is invalid.
     */
    function createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {

      function tryMap(db, fun, doc) {
        // emit an event if there was an error thrown by a map function.
        // putting try/catches in a single function also avoids deoptimizations.
        try {
          fun(doc);
        } catch (e) {
          emitError(db, e);
        }
      }

      function tryReduce(db, fun, keys, values, rereduce) {
        // same as above, but returning the result or an error. there are two separate
        // functions to avoid extra memory allocations since the tryCode() case is used
        // for custom map functions (common) vs this function, which is only used for
        // custom reduce functions (rare)
        try {
          return {output : fun(keys, values, rereduce)};
        } catch (e) {
          emitError(db, e);
          return {error: e};
        }
      }

      function sortByKeyThenValue(x, y) {
        var keyCompare = collate(x.key, y.key);
        return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
      }

      function sliceResults(results, limit, skip) {
        skip = skip || 0;
        if (typeof limit === 'number') {
          return results.slice(skip, limit + skip);
        } else if (skip > 0) {
          return results.slice(skip);
        }
        return results;
      }

      function rowToDocId(row) {
        var val = row.value;
        // Users can explicitly specify a joined doc _id, or it
        // defaults to the doc _id that emitted the key/value.
        var docId = (val && typeof val === 'object' && val._id) || row.id;
        return docId;
      }

      function readAttachmentsAsBlobOrBuffer(res) {
        res.rows.forEach(function (row) {
          var atts = row.doc && row.doc._attachments;
          if (!atts) {
            return;
          }
          Object.keys(atts).forEach(function (filename) {
            var att = atts[filename];
            atts[filename].data = b64ToBluffer(att.data, att.content_type);
          });
        });
      }

      function postprocessAttachments(opts) {
        return function (res) {
          if (opts.include_docs && opts.attachments && opts.binary) {
            readAttachmentsAsBlobOrBuffer(res);
          }
          return res;
        };
      }

      function addHttpParam(paramName, opts, params, asJson) {
        // add an http param from opts to params, optionally json-encoded
        var val = opts[paramName];
        if (typeof val !== 'undefined') {
          if (asJson) {
            val = encodeURIComponent(JSON.stringify(val));
          }
          params.push(paramName + '=' + val);
        }
      }

      function coerceInteger(integerCandidate) {
        if (typeof integerCandidate !== 'undefined') {
          var asNumber = Number(integerCandidate);
          // prevents e.g. '1foo' or '1.1' being coerced to 1
          if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {
            return asNumber;
          } else {
            return integerCandidate;
          }
        }
      }

      function coerceOptions(opts) {
        opts.group_level = coerceInteger(opts.group_level);
        opts.limit = coerceInteger(opts.limit);
        opts.skip = coerceInteger(opts.skip);
        return opts;
      }

      function checkPositiveInteger(number) {
        if (number) {
          if (typeof number !== 'number') {
            return  new QueryParseError('Invalid value for integer: "' +
              number + '"');
          }
          if (number < 0) {
            return new QueryParseError('Invalid value for positive integer: ' +
              '"' + number + '"');
          }
        }
      }

      function checkQueryParseError(options, fun) {
        var startkeyName = options.descending ? 'endkey' : 'startkey';
        var endkeyName = options.descending ? 'startkey' : 'endkey';

        if (typeof options[startkeyName] !== 'undefined' &&
          typeof options[endkeyName] !== 'undefined' &&
          collate(options[startkeyName], options[endkeyName]) > 0) {
          throw new QueryParseError('No rows can match your key range, ' +
            'reverse your start_key and end_key or set {descending : true}');
        } else if (fun.reduce && options.reduce !== false) {
          if (options.include_docs) {
            throw new QueryParseError('{include_docs:true} is invalid for reduce');
          } else if (options.keys && options.keys.length > 1 &&
            !options.group && !options.group_level) {
            throw new QueryParseError('Multi-key fetches for reduce views must use ' +
              '{group: true}');
          }
        }
        ['group_level', 'limit', 'skip'].forEach(function (optionName) {
          var error = checkPositiveInteger(options[optionName]);
          if (error) {
            throw error;
          }
        });
      }

      function httpQuery(db, fun, opts) {
        // List of parameters to add to the PUT request
        var params = [];
        var body;
        var method = 'GET';
        var ok, status;

        // If opts.reduce exists and is defined, then add it to the list
        // of parameters.
        // If reduce=false then the results are that of only the map function
        // not the final result of map and reduce.
        addHttpParam('reduce', opts, params);
        addHttpParam('include_docs', opts, params);
        addHttpParam('attachments', opts, params);
        addHttpParam('limit', opts, params);
        addHttpParam('descending', opts, params);
        addHttpParam('group', opts, params);
        addHttpParam('group_level', opts, params);
        addHttpParam('skip', opts, params);
        addHttpParam('stale', opts, params);
        addHttpParam('conflicts', opts, params);
        addHttpParam('startkey', opts, params, true);
        addHttpParam('start_key', opts, params, true);
        addHttpParam('endkey', opts, params, true);
        addHttpParam('end_key', opts, params, true);
        addHttpParam('inclusive_end', opts, params);
        addHttpParam('key', opts, params, true);
        addHttpParam('update_seq', opts, params);

        // Format the list of parameters into a valid URI query string
        params = params.join('&');
        params = params === '' ? '' : '?' + params;

        // If keys are supplied, issue a POST to circumvent GET query string limits
        // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
        if (typeof opts.keys !== 'undefined') {
          var MAX_URL_LENGTH = 2000;
          // according to http://stackoverflow.com/a/417184/680742,
          // the de facto URL length limit is 2000 characters

          var keysAsString =
            'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
          if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
            // If the keys are short enough, do a GET. we do this to work around
            // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)
            params += (params[0] === '?' ? '&' : '?') + keysAsString;
          } else {
            method = 'POST';
            if (typeof fun === 'string') {
              body = {keys: opts.keys};
            } else { // fun is {map : mapfun}, so append to this
              fun.keys = opts.keys;
            }
          }
        }

        // We are referencing a query defined in the design doc
        if (typeof fun === 'string') {
          var parts = parseViewName(fun);
          return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {
            headers: new h({'Content-Type': 'application/json'}),
            method: method,
            body: JSON.stringify(body)
          }).then(function (response) {
            ok = response.ok;
            status = response.status;
            return response.json();
          }).then(function (result) {
            if (!ok) {
              result.status = status;
              throw generateErrorFromResponse(result);
            }
            // fail the entire request if the result contains an error
            result.rows.forEach(function (row) {
              /* istanbul ignore if */
              if (row.value && row.value.error && row.value.error === "builtin_reduce_error") {
                throw new Error(row.reason);
              }
            });
            return result;
          }).then(postprocessAttachments(opts));
        }

        // We are using a temporary view, terrible for performance, good for testing
        body = body || {};
        Object.keys(fun).forEach(function (key) {
          if (Array.isArray(fun[key])) {
            body[key] = fun[key];
          } else {
            body[key] = fun[key].toString();
          }
        });

        return db.fetch('_temp_view' + params, {
          headers: new h({'Content-Type': 'application/json'}),
          method: 'POST',
          body: JSON.stringify(body)
        }).then(function (response) {
            ok = response.ok;
            status = response.status;
          return response.json();
        }).then(function (result) {
          if (!ok) {
            result.status = status;
            throw generateErrorFromResponse(result);
          }
          return result;
        }).then(postprocessAttachments(opts));
      }

      // custom adapters can define their own api._query
      // and override the default behavior
      /* istanbul ignore next */
      function customQuery(db, fun, opts) {
        return new Promise(function (resolve, reject) {
          db._query(fun, opts, function (err, res) {
            if (err) {
              return reject(err);
            }
            resolve(res);
          });
        });
      }

      // custom adapters can define their own api._viewCleanup
      // and override the default behavior
      /* istanbul ignore next */
      function customViewCleanup(db) {
        return new Promise(function (resolve, reject) {
          db._viewCleanup(function (err, res) {
            if (err) {
              return reject(err);
            }
            resolve(res);
          });
        });
      }

      function defaultsTo(value) {
        return function (reason) {
          /* istanbul ignore else */
          if (reason.status === 404) {
            return value;
          } else {
            throw reason;
          }
        };
      }

      // returns a promise for a list of docs to update, based on the input docId.
      // the order doesn't matter, because post-3.2.0, bulkDocs
      // is an atomic operation in all three adapters.
      function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
        var metaDocId = '_local/doc_' + docId;
        var defaultMetaDoc = {_id: metaDocId, keys: []};
        var docData = docIdsToChangesAndEmits.get(docId);
        var indexableKeysToKeyValues = docData[0];
        var changes = docData[1];

        function getMetaDoc() {
          if (isGenOne(changes)) {
            // generation 1, so we can safely assume initial state
            // for performance reasons (avoids unnecessary GETs)
            return Promise.resolve(defaultMetaDoc);
          }
          return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));
        }

        function getKeyValueDocs(metaDoc) {
          if (!metaDoc.keys.length) {
            // no keys, no need for a lookup
            return Promise.resolve({rows: []});
          }
          return view.db.allDocs({
            keys: metaDoc.keys,
            include_docs: true
          });
        }

        function processKeyValueDocs(metaDoc, kvDocsRes) {
          var kvDocs = [];
          var oldKeys = new ExportedSet();

          for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
            var row = kvDocsRes.rows[i];
            var doc = row.doc;
            if (!doc) { // deleted
              continue;
            }
            kvDocs.push(doc);
            oldKeys.add(doc._id);
            doc._deleted = !indexableKeysToKeyValues.has(doc._id);
            if (!doc._deleted) {
              var keyValue = indexableKeysToKeyValues.get(doc._id);
              if ('value' in keyValue) {
                doc.value = keyValue.value;
              }
            }
          }
          var newKeys = mapToKeysArray(indexableKeysToKeyValues);
          newKeys.forEach(function (key) {
            if (!oldKeys.has(key)) {
              // new doc
              var kvDoc = {
                _id: key
              };
              var keyValue = indexableKeysToKeyValues.get(key);
              if ('value' in keyValue) {
                kvDoc.value = keyValue.value;
              }
              kvDocs.push(kvDoc);
            }
          });
          metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));
          kvDocs.push(metaDoc);

          return kvDocs;
        }

        return getMetaDoc().then(function (metaDoc) {
          return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
            return processKeyValueDocs(metaDoc, kvDocsRes);
          });
        });
      }

      // updates all emitted key/value docs and metaDocs in the mrview database
      // for the given batch of documents from the source database
      function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
        var seqDocId = '_local/lastSeq';
        return view.db.get(seqDocId)
          .catch(defaultsTo({_id: seqDocId, seq: 0}))
          .then(function (lastSeqDoc) {
            var docIds = mapToKeysArray(docIdsToChangesAndEmits);
            return Promise.all(docIds.map(function (docId) {
              return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
            })).then(function (listOfDocsToPersist) {
              var docsToPersist = flatten(listOfDocsToPersist);
              lastSeqDoc.seq = seq;
              docsToPersist.push(lastSeqDoc);
              // write all docs in a single operation, update the seq once
              return view.db.bulkDocs({docs : docsToPersist});
            });
          });
      }

      function getQueue(view) {
        var viewName = typeof view === 'string' ? view : view.name;
        var queue = persistentQueues[viewName];
        if (!queue) {
          queue = persistentQueues[viewName] = new TaskQueue$1();
        }
        return queue;
      }

      function updateView(view) {
        return sequentialize(getQueue(view), function () {
          return updateViewInQueue(view);
        })();
      }

      function updateViewInQueue(view) {
        // bind the emit function once
        var mapResults;
        var doc;

        function emit(key, value) {
          var output = {id: doc._id, key: normalizeKey(key)};
          // Don't explicitly store the value unless it's defined and non-null.
          // This saves on storage space, because often people don't use it.
          if (typeof value !== 'undefined' && value !== null) {
            output.value = normalizeKey(value);
          }
          mapResults.push(output);
        }

        var mapFun = mapper(view.mapFun, emit);

        var currentSeq = view.seq || 0;

        function processChange(docIdsToChangesAndEmits, seq) {
          return function () {
            return saveKeyValues(view, docIdsToChangesAndEmits, seq);
          };
        }

        var queue = new TaskQueue$1();

        function processNextBatch() {
          return view.sourceDB.changes({
            return_docs: true,
            conflicts: true,
            include_docs: true,
            style: 'all_docs',
            since: currentSeq,
            limit: CHANGES_BATCH_SIZE$1
          }).then(processBatch);
        }

        function processBatch(response) {
          var results = response.results;
          if (!results.length) {
            return;
          }
          var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);
          queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
          if (results.length < CHANGES_BATCH_SIZE$1) {
            return;
          }
          return processNextBatch();
        }

        function createDocIdsToChangesAndEmits(results) {
          var docIdsToChangesAndEmits = new ExportedMap();
          for (var i = 0, len = results.length; i < len; i++) {
            var change = results[i];
            if (change.doc._id[0] !== '_') {
              mapResults = [];
              doc = change.doc;

              if (!doc._deleted) {
                tryMap(view.sourceDB, mapFun, doc);
              }
              mapResults.sort(sortByKeyThenValue);

              var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);
              docIdsToChangesAndEmits.set(change.doc._id, [
                indexableKeysToKeyValues,
                change.changes
              ]);
            }
            currentSeq = change.seq;
          }
          return docIdsToChangesAndEmits;
        }

        function createIndexableKeysToKeyValues(mapResults) {
          var indexableKeysToKeyValues = new ExportedMap();
          var lastKey;
          for (var i = 0, len = mapResults.length; i < len; i++) {
            var emittedKeyValue = mapResults[i];
            var complexKey = [emittedKeyValue.key, emittedKeyValue.id];
            if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {
              complexKey.push(i); // dup key+id, so make it unique
            }
            indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);
            lastKey = emittedKeyValue.key;
          }
          return indexableKeysToKeyValues;
        }

        return processNextBatch().then(function () {
          return queue.finish();
        }).then(function () {
          view.seq = currentSeq;
        });
      }

      function reduceView(view, results, options) {
        if (options.group_level === 0) {
          delete options.group_level;
        }

        var shouldGroup = options.group || options.group_level;

        var reduceFun = reducer(view.reduceFun);

        var groups = [];
        var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :
          options.group_level;
        results.forEach(function (e) {
          var last = groups[groups.length - 1];
          var groupKey = shouldGroup ? e.key : null;

          // only set group_level for array keys
          if (shouldGroup && Array.isArray(groupKey)) {
            groupKey = groupKey.slice(0, lvl);
          }

          if (last && collate(last.groupKey, groupKey) === 0) {
            last.keys.push([e.key, e.id]);
            last.values.push(e.value);
            return;
          }
          groups.push({
            keys: [[e.key, e.id]],
            values: [e.value],
            groupKey: groupKey
          });
        });
        results = [];
        for (var i = 0, len = groups.length; i < len; i++) {
          var e = groups[i];
          var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);
          if (reduceTry.error && reduceTry.error instanceof BuiltInError) {
            // CouchDB returns an error if a built-in errors out
            throw reduceTry.error;
          }
          results.push({
            // CouchDB just sets the value to null if a non-built-in errors out
            value: reduceTry.error ? null : reduceTry.output,
            key: e.groupKey
          });
        }
        // no total_rows/offset when reducing
        return {rows: sliceResults(results, options.limit, options.skip)};
      }

      function queryView(view, opts) {
        return sequentialize(getQueue(view), function () {
          return queryViewInQueue(view, opts);
        })();
      }

      function queryViewInQueue(view, opts) {
        var totalRows;
        var shouldReduce = view.reduceFun && opts.reduce !== false;
        var skip = opts.skip || 0;
        if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
          // equivalent query
          opts.limit = 0;
          delete opts.keys;
        }

        function fetchFromView(viewOpts) {
          viewOpts.include_docs = true;
          return view.db.allDocs(viewOpts).then(function (res) {
            totalRows = res.total_rows;
            return res.rows.map(function (result) {

              // implicit migration - in older versions of PouchDB,
              // we explicitly stored the doc as {id: ..., key: ..., value: ...}
              // this is tested in a migration test
              /* istanbul ignore next */
              if ('value' in result.doc && typeof result.doc.value === 'object' &&
                result.doc.value !== null) {
                var keys = Object.keys(result.doc.value).sort();
                // this detection method is not perfect, but it's unlikely the user
                // emitted a value which was an object with these 3 exact keys
                var expectedKeys = ['id', 'key', 'value'];
                if (!(keys < expectedKeys || keys > expectedKeys)) {
                  return result.doc.value;
                }
              }

              var parsedKeyAndDocId = parseIndexableString(result.doc._id);
              return {
                key: parsedKeyAndDocId[0],
                id: parsedKeyAndDocId[1],
                value: ('value' in result.doc ? result.doc.value : null)
              };
            });
          });
        }

        function onMapResultsReady(rows) {
          var finalResults;
          if (shouldReduce) {
            finalResults = reduceView(view, rows, opts);
          } else {
            finalResults = {
              total_rows: totalRows,
              offset: skip,
              rows: rows
            };
          }
          /* istanbul ignore if */
          if (opts.update_seq) {
            finalResults.update_seq = view.seq;
          }
          if (opts.include_docs) {
            var docIds = uniq(rows.map(rowToDocId));

            return view.sourceDB.allDocs({
              keys: docIds,
              include_docs: true,
              conflicts: opts.conflicts,
              attachments: opts.attachments,
              binary: opts.binary
            }).then(function (allDocsRes) {
              var docIdsToDocs = new ExportedMap();
              allDocsRes.rows.forEach(function (row) {
                docIdsToDocs.set(row.id, row.doc);
              });
              rows.forEach(function (row) {
                var docId = rowToDocId(row);
                var doc = docIdsToDocs.get(docId);
                if (doc) {
                  row.doc = doc;
                }
              });
              return finalResults;
            });
          } else {
            return finalResults;
          }
        }

        if (typeof opts.keys !== 'undefined') {
          var keys = opts.keys;
          var fetchPromises = keys.map(function (key) {
            var viewOpts = {
              startkey : toIndexableString([key]),
              endkey   : toIndexableString([key, {}])
            };
            /* istanbul ignore if */
            if (opts.update_seq) {
              viewOpts.update_seq = true;
            }
            return fetchFromView(viewOpts);
          });
          return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);
        } else { // normal query, no 'keys'
          var viewOpts = {
            descending : opts.descending
          };
          /* istanbul ignore if */
          if (opts.update_seq) {
            viewOpts.update_seq = true;
          }
          var startkey;
          var endkey;
          if ('start_key' in opts) {
            startkey = opts.start_key;
          }
          if ('startkey' in opts) {
            startkey = opts.startkey;
          }
          if ('end_key' in opts) {
            endkey = opts.end_key;
          }
          if ('endkey' in opts) {
            endkey = opts.endkey;
          }
          if (typeof startkey !== 'undefined') {
            viewOpts.startkey = opts.descending ?
              toIndexableString([startkey, {}]) :
              toIndexableString([startkey]);
          }
          if (typeof endkey !== 'undefined') {
            var inclusiveEnd = opts.inclusive_end !== false;
            if (opts.descending) {
              inclusiveEnd = !inclusiveEnd;
            }

            viewOpts.endkey = toIndexableString(
              inclusiveEnd ? [endkey, {}] : [endkey]);
          }
          if (typeof opts.key !== 'undefined') {
            var keyStart = toIndexableString([opts.key]);
            var keyEnd = toIndexableString([opts.key, {}]);
            if (viewOpts.descending) {
              viewOpts.endkey = keyStart;
              viewOpts.startkey = keyEnd;
            } else {
              viewOpts.startkey = keyStart;
              viewOpts.endkey = keyEnd;
            }
          }
          if (!shouldReduce) {
            if (typeof opts.limit === 'number') {
              viewOpts.limit = opts.limit;
            }
            viewOpts.skip = skip;
          }
          return fetchFromView(viewOpts).then(onMapResultsReady);
        }
      }

      function httpViewCleanup(db) {
        return db.fetch('_view_cleanup', {
          headers: new h({'Content-Type': 'application/json'}),
          method: 'POST'
        }).then(function (response) {
          return response.json();
        });
      }

      function localViewCleanup(db) {
        return db.get('_local/' + localDocName).then(function (metaDoc) {
          var docsToViews = new ExportedMap();
          Object.keys(metaDoc.views).forEach(function (fullViewName) {
            var parts = parseViewName(fullViewName);
            var designDocName = '_design/' + parts[0];
            var viewName = parts[1];
            var views = docsToViews.get(designDocName);
            if (!views) {
              views = new ExportedSet();
              docsToViews.set(designDocName, views);
            }
            views.add(viewName);
          });
          var opts = {
            keys : mapToKeysArray(docsToViews),
            include_docs : true
          };
          return db.allDocs(opts).then(function (res) {
            var viewsToStatus = {};
            res.rows.forEach(function (row) {
              var ddocName = row.key.substring(8); // cuts off '_design/'
              docsToViews.get(row.key).forEach(function (viewName) {
                var fullViewName = ddocName + '/' + viewName;
                /* istanbul ignore if */
                if (!metaDoc.views[fullViewName]) {
                  // new format, without slashes, to support PouchDB 2.2.0
                  // migration test in pouchdb's browser.migration.js verifies this
                  fullViewName = viewName;
                }
                var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
                // design doc deleted, or view function nonexistent
                var statusIsGood = row.doc && row.doc.views &&
                  row.doc.views[viewName];
                viewDBNames.forEach(function (viewDBName) {
                  viewsToStatus[viewDBName] =
                    viewsToStatus[viewDBName] || statusIsGood;
                });
              });
            });
            var dbsToDelete = Object.keys(viewsToStatus).filter(
              function (viewDBName) { return !viewsToStatus[viewDBName]; });
            var destroyPromises = dbsToDelete.map(function (viewDBName) {
              return sequentialize(getQueue(viewDBName), function () {
                return new db.constructor(viewDBName, db.__opts).destroy();
              })();
            });
            return Promise.all(destroyPromises).then(function () {
              return {ok: true};
            });
          });
        }, defaultsTo({ok: true}));
      }

      function queryPromised(db, fun, opts) {
        /* istanbul ignore next */
        if (typeof db._query === 'function') {
          return customQuery(db, fun, opts);
        }
        if (isRemote(db)) {
          return httpQuery(db, fun, opts);
        }

        if (typeof fun !== 'string') {
          // temp_view
          checkQueryParseError(opts, fun);

          tempViewQueue.add(function () {
            var createViewPromise = createView(
              /* sourceDB */ db,
              /* viewName */ 'temp_view/temp_view',
              /* mapFun */ fun.map,
              /* reduceFun */ fun.reduce,
              /* temporary */ true,
              /* localDocName */ localDocName);
            return createViewPromise.then(function (view) {
              return fin(updateView(view).then(function () {
                return queryView(view, opts);
              }), function () {
                return view.db.destroy();
              });
            });
          });
          return tempViewQueue.finish();
        } else {
          // persistent view
          var fullViewName = fun;
          var parts = parseViewName(fullViewName);
          var designDocName = parts[0];
          var viewName = parts[1];
          return db.get('_design/' + designDocName).then(function (doc) {
            var fun = doc.views && doc.views[viewName];

            if (!fun) {
              // basic validator; it's assumed that every subclass would want this
              throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +
                viewName);
            }

            ddocValidator(doc, viewName);
            checkQueryParseError(opts, fun);

            var createViewPromise = createView(
              /* sourceDB */ db,
              /* viewName */ fullViewName,
              /* mapFun */ fun.map,
              /* reduceFun */ fun.reduce,
              /* temporary */ false,
              /* localDocName */ localDocName);
            return createViewPromise.then(function (view) {
              if (opts.stale === 'ok' || opts.stale === 'update_after') {
                if (opts.stale === 'update_after') {
                  lib(function () {
                    updateView(view);
                  });
                }
                return queryView(view, opts);
              } else { // stale not ok
                return updateView(view).then(function () {
                  return queryView(view, opts);
                });
              }
            });
          });
        }
      }

      function abstractQuery(fun, opts, callback) {
        var db = this;
        if (typeof opts === 'function') {
          callback = opts;
          opts = {};
        }
        opts = opts ? coerceOptions(opts) : {};

        if (typeof fun === 'function') {
          fun = {map : fun};
        }

        var promise = Promise.resolve().then(function () {
          return queryPromised(db, fun, opts);
        });
        promisedCallback(promise, callback);
        return promise;
      }

      var abstractViewCleanup = callbackify(function () {
        var db = this;
        /* istanbul ignore next */
        if (typeof db._viewCleanup === 'function') {
          return customViewCleanup(db);
        }
        if (isRemote(db)) {
          return httpViewCleanup(db);
        }
        return localViewCleanup(db);
      });

      return {
        query: abstractQuery,
        viewCleanup: abstractViewCleanup
      };
    }

    var builtInReduce = {
      _sum: function (keys, values) {
        return sum(values);
      },

      _count: function (keys, values) {
        return values.length;
      },

      _stats: function (keys, values) {
        // no need to implement rereduce=true, because Pouch
        // will never call it
        function sumsqr(values) {
          var _sumsqr = 0;
          for (var i = 0, len = values.length; i < len; i++) {
            var num = values[i];
            _sumsqr += (num * num);
          }
          return _sumsqr;
        }
        return {
          sum     : sum(values),
          min     : Math.min.apply(null, values),
          max     : Math.max.apply(null, values),
          count   : values.length,
          sumsqr : sumsqr(values)
        };
      }
    };

    function getBuiltIn(reduceFunString) {
      if (/^_sum/.test(reduceFunString)) {
        return builtInReduce._sum;
      } else if (/^_count/.test(reduceFunString)) {
        return builtInReduce._count;
      } else if (/^_stats/.test(reduceFunString)) {
        return builtInReduce._stats;
      } else if (/^_/.test(reduceFunString)) {
        throw new Error(reduceFunString + ' is not a supported reduce function.');
      }
    }

    function mapper(mapFun, emit) {
      // for temp_views one can use emit(doc, emit), see #38
      if (typeof mapFun === "function" && mapFun.length === 2) {
        var origMap = mapFun;
        return function (doc) {
          return origMap(doc, emit);
        };
      } else {
        return evalFunctionWithEval(mapFun.toString(), emit);
      }
    }

    function reducer(reduceFun) {
      var reduceFunString = reduceFun.toString();
      var builtIn = getBuiltIn(reduceFunString);
      if (builtIn) {
        return builtIn;
      } else {
        return evalFunctionWithEval(reduceFunString);
      }
    }

    function ddocValidator(ddoc, viewName) {
      var fun = ddoc.views && ddoc.views[viewName];
      if (typeof fun.map !== 'string') {
        throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +
          viewName + ', instead found object of type: ' + typeof fun.map);
      }
    }

    var localDocName = 'mrviews';
    var abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);

    function query(fun, opts, callback) {
      return abstract.query.call(this, fun, opts, callback);
    }

    function viewCleanup(callback) {
      return abstract.viewCleanup.call(this, callback);
    }

    var mapreduce = {
      query: query,
      viewCleanup: viewCleanup
    };

    function isGenOne$1(rev$$1) {
      return /^1-/.test(rev$$1);
    }

    function fileHasChanged(localDoc, remoteDoc, filename) {
      return !localDoc._attachments ||
             !localDoc._attachments[filename] ||
             localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;
    }

    function getDocAttachments(db, doc) {
      var filenames = Object.keys(doc._attachments);
      return Promise.all(filenames.map(function (filename) {
        return db.getAttachment(doc._id, filename, {rev: doc._rev});
      }));
    }

    function getDocAttachmentsFromTargetOrSource(target, src, doc) {
      var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);
      var filenames = Object.keys(doc._attachments);

      if (!doCheckForLocalAttachments) {
        return getDocAttachments(src, doc);
      }

      return target.get(doc._id).then(function (localDoc) {
        return Promise.all(filenames.map(function (filename) {
          if (fileHasChanged(localDoc, doc, filename)) {
            return src.getAttachment(doc._id, filename);
          }

          return target.getAttachment(localDoc._id, filename);
        }));
      }).catch(function (error) {
        /* istanbul ignore if */
        if (error.status !== 404) {
          throw error;
        }

        return getDocAttachments(src, doc);
      });
    }

    function createBulkGetOpts(diffs) {
      var requests = [];
      Object.keys(diffs).forEach(function (id) {
        var missingRevs = diffs[id].missing;
        missingRevs.forEach(function (missingRev) {
          requests.push({
            id: id,
            rev: missingRev
          });
        });
      });

      return {
        docs: requests,
        revs: true,
        latest: true
      };
    }

    //
    // Fetch all the documents from the src as described in the "diffs",
    // which is a mapping of docs IDs to revisions. If the state ever
    // changes to "cancelled", then the returned promise will be rejected.
    // Else it will be resolved with a list of fetched documents.
    //
    function getDocs(src, target, diffs, state) {
      diffs = clone(diffs); // we do not need to modify this

      var resultDocs = [],
          ok = true;

      function getAllDocs() {

        var bulkGetOpts = createBulkGetOpts(diffs);

        if (!bulkGetOpts.docs.length) { // optimization: skip empty requests
          return;
        }

        return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {
          /* istanbul ignore if */
          if (state.cancelled) {
            throw new Error('cancelled');
          }
          return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {
            return Promise.all(bulkGetInfo.docs.map(function (doc) {
              var remoteDoc = doc.ok;

              if (doc.error) {
                // when AUTO_COMPACTION is set, docs can be returned which look
                // like this: {"missing":"1-7c3ac256b693c462af8442f992b83696"}
                ok = false;
              }

              if (!remoteDoc || !remoteDoc._attachments) {
                return remoteDoc;
              }

              return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)
                       .then(function (attachments) {
                               var filenames = Object.keys(remoteDoc._attachments);
                               attachments
                                 .forEach(function (attachment, i) {
                                            var att = remoteDoc._attachments[filenames[i]];
                                            delete att.stub;
                                            delete att.length;
                                            att.data = attachment;
                                          });

                                          return remoteDoc;
                                        });
            }));
          }))

          .then(function (results) {
            resultDocs = resultDocs.concat(flatten(results).filter(Boolean));
          });
        });
      }

      function hasAttachments(doc) {
        return doc._attachments && Object.keys(doc._attachments).length > 0;
      }

      function hasConflicts(doc) {
        return doc._conflicts && doc._conflicts.length > 0;
      }

      function fetchRevisionOneDocs(ids) {
        // Optimization: fetch gen-1 docs and attachments in
        // a single request using _all_docs
        return src.allDocs({
          keys: ids,
          include_docs: true,
          conflicts: true
        }).then(function (res) {
          if (state.cancelled) {
            throw new Error('cancelled');
          }
          res.rows.forEach(function (row) {
            if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||
                hasAttachments(row.doc) || hasConflicts(row.doc)) {
              // if any of these conditions apply, we need to fetch using get()
              return;
            }

            // strip _conflicts array to appease CSG (#5793)
            /* istanbul ignore if */
            if (row.doc._conflicts) {
              delete row.doc._conflicts;
            }

            // the doc we got back from allDocs() is sufficient
            resultDocs.push(row.doc);
            delete diffs[row.id];
          });
        });
      }

      function getRevisionOneDocs() {
        // filter out the generation 1 docs and get them
        // leaving the non-generation one docs to be got otherwise
        var ids = Object.keys(diffs).filter(function (id) {
          var missing = diffs[id].missing;
          return missing.length === 1 && isGenOne$1(missing[0]);
        });
        if (ids.length > 0) {
          return fetchRevisionOneDocs(ids);
        }
      }

      function returnResult() {
        return { ok:ok, docs:resultDocs };
      }

      return Promise.resolve()
        .then(getRevisionOneDocs)
        .then(getAllDocs)
        .then(returnResult);
    }

    var CHECKPOINT_VERSION = 1;
    var REPLICATOR = "pouchdb";
    // This is an arbitrary number to limit the
    // amount of replication history we save in the checkpoint.
    // If we save too much, the checkpoing docs will become very big,
    // if we save fewer, we'll run a greater risk of having to
    // read all the changes from 0 when checkpoint PUTs fail
    // CouchDB 2.0 has a more involved history pruning,
    // but let's go for the simple version for now.
    var CHECKPOINT_HISTORY_SIZE = 5;
    var LOWEST_SEQ = 0;

    function updateCheckpoint(db, id, checkpoint, session, returnValue) {
      return db.get(id).catch(function (err) {
        if (err.status === 404) {
          if (db.adapter === 'http' || db.adapter === 'https') {
            explainError(
              404, 'PouchDB is just checking if a remote checkpoint exists.'
            );
          }
          return {
            session_id: session,
            _id: id,
            history: [],
            replicator: REPLICATOR,
            version: CHECKPOINT_VERSION
          };
        }
        throw err;
      }).then(function (doc) {
        if (returnValue.cancelled) {
          return;
        }

        // if the checkpoint has not changed, do not update
        if (doc.last_seq === checkpoint) {
          return;
        }

        // Filter out current entry for this replication
        doc.history = (doc.history || []).filter(function (item) {
          return item.session_id !== session;
        });

        // Add the latest checkpoint to history
        doc.history.unshift({
          last_seq: checkpoint,
          session_id: session
        });

        // Just take the last pieces in history, to
        // avoid really big checkpoint docs.
        // see comment on history size above
        doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);

        doc.version = CHECKPOINT_VERSION;
        doc.replicator = REPLICATOR;

        doc.session_id = session;
        doc.last_seq = checkpoint;

        return db.put(doc).catch(function (err) {
          if (err.status === 409) {
            // retry; someone is trying to write a checkpoint simultaneously
            return updateCheckpoint(db, id, checkpoint, session, returnValue);
          }
          throw err;
        });
      });
    }

    function Checkpointer(src, target, id, returnValue, opts) {
      this.src = src;
      this.target = target;
      this.id = id;
      this.returnValue = returnValue;
      this.opts = opts || {};
    }

    Checkpointer.prototype.writeCheckpoint = function (checkpoint, session) {
      var self = this;
      return this.updateTarget(checkpoint, session).then(function () {
        return self.updateSource(checkpoint, session);
      });
    };

    Checkpointer.prototype.updateTarget = function (checkpoint, session) {
      if (this.opts.writeTargetCheckpoint) {
        return updateCheckpoint(this.target, this.id, checkpoint,
          session, this.returnValue);
      } else {
        return Promise.resolve(true);
      }
    };

    Checkpointer.prototype.updateSource = function (checkpoint, session) {
      if (this.opts.writeSourceCheckpoint) {
        var self = this;
        return updateCheckpoint(this.src, this.id, checkpoint,
          session, this.returnValue)
          .catch(function (err) {
            if (isForbiddenError(err)) {
              self.opts.writeSourceCheckpoint = false;
              return true;
            }
            throw err;
          });
      } else {
        return Promise.resolve(true);
      }
    };

    var comparisons = {
      "undefined": function (targetDoc, sourceDoc) {
        // This is the previous comparison function
        if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {
          return sourceDoc.last_seq;
        }
        /* istanbul ignore next */
        return 0;
      },
      "1": function (targetDoc, sourceDoc) {
        // This is the comparison function ported from CouchDB
        return compareReplicationLogs(sourceDoc, targetDoc).last_seq;
      }
    };

    Checkpointer.prototype.getCheckpoint = function () {
      var self = this;

      if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {
        return self.src.get(self.id).then(function (sourceDoc) {
          return sourceDoc.last_seq || LOWEST_SEQ;
        }).catch(function (err) {
          /* istanbul ignore if */
          if (err.status !== 404) {
            throw err;
          }
          return LOWEST_SEQ;
        });
      }

      return self.target.get(self.id).then(function (targetDoc) {
        if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {
          return targetDoc.last_seq || LOWEST_SEQ;
        }

        return self.src.get(self.id).then(function (sourceDoc) {
          // Since we can't migrate an old version doc to a new one
          // (no session id), we just go with the lowest seq in this case
          /* istanbul ignore if */
          if (targetDoc.version !== sourceDoc.version) {
            return LOWEST_SEQ;
          }

          var version;
          if (targetDoc.version) {
            version = targetDoc.version.toString();
          } else {
            version = "undefined";
          }

          if (version in comparisons) {
            return comparisons[version](targetDoc, sourceDoc);
          }
          /* istanbul ignore next */
          return LOWEST_SEQ;
        }, function (err) {
          if (err.status === 404 && targetDoc.last_seq) {
            return self.src.put({
              _id: self.id,
              last_seq: LOWEST_SEQ
            }).then(function () {
              return LOWEST_SEQ;
            }, function (err) {
              if (isForbiddenError(err)) {
                self.opts.writeSourceCheckpoint = false;
                return targetDoc.last_seq;
              }
              /* istanbul ignore next */
              return LOWEST_SEQ;
            });
          }
          throw err;
        });
      }).catch(function (err) {
        if (err.status !== 404) {
          throw err;
        }
        return LOWEST_SEQ;
      });
    };
    // This checkpoint comparison is ported from CouchDBs source
    // they come from here:
    // https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906

    function compareReplicationLogs(srcDoc, tgtDoc) {
      if (srcDoc.session_id === tgtDoc.session_id) {
        return {
          last_seq: srcDoc.last_seq,
          history: srcDoc.history
        };
      }

      return compareReplicationHistory(srcDoc.history, tgtDoc.history);
    }

    function compareReplicationHistory(sourceHistory, targetHistory) {
      // the erlang loop via function arguments is not so easy to repeat in JS
      // therefore, doing this as recursion
      var S = sourceHistory[0];
      var sourceRest = sourceHistory.slice(1);
      var T = targetHistory[0];
      var targetRest = targetHistory.slice(1);

      if (!S || targetHistory.length === 0) {
        return {
          last_seq: LOWEST_SEQ,
          history: []
        };
      }

      var sourceId = S.session_id;
      /* istanbul ignore if */
      if (hasSessionId(sourceId, targetHistory)) {
        return {
          last_seq: S.last_seq,
          history: sourceHistory
        };
      }

      var targetId = T.session_id;
      if (hasSessionId(targetId, sourceRest)) {
        return {
          last_seq: T.last_seq,
          history: targetRest
        };
      }

      return compareReplicationHistory(sourceRest, targetRest);
    }

    function hasSessionId(sessionId, history) {
      var props = history[0];
      var rest = history.slice(1);

      if (!sessionId || history.length === 0) {
        return false;
      }

      if (sessionId === props.session_id) {
        return true;
      }

      return hasSessionId(sessionId, rest);
    }

    function isForbiddenError(err) {
      return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;
    }

    var STARTING_BACK_OFF = 0;

    function backOff(opts, returnValue, error, callback) {
      if (opts.retry === false) {
        returnValue.emit('error', error);
        returnValue.removeAllListeners();
        return;
      }
      /* istanbul ignore if */
      if (typeof opts.back_off_function !== 'function') {
        opts.back_off_function = defaultBackOff;
      }
      returnValue.emit('requestError', error);
      if (returnValue.state === 'active' || returnValue.state === 'pending') {
        returnValue.emit('paused', error);
        returnValue.state = 'stopped';
        var backOffSet = function backoffTimeSet() {
          opts.current_back_off = STARTING_BACK_OFF;
        };
        var removeBackOffSetter = function removeBackOffTimeSet() {
          returnValue.removeListener('active', backOffSet);
        };
        returnValue.once('paused', removeBackOffSetter);
        returnValue.once('active', backOffSet);
      }

      opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;
      opts.current_back_off = opts.back_off_function(opts.current_back_off);
      setTimeout(callback, opts.current_back_off);
    }

    function sortObjectPropertiesByKey(queryParams) {
      return Object.keys(queryParams).sort(collate).reduce(function (result, key) {
        result[key] = queryParams[key];
        return result;
      }, {});
    }

    // Generate a unique id particular to this replication.
    // Not guaranteed to align perfectly with CouchDB's rep ids.
    function generateReplicationId(src, target, opts) {
      var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';
      var filterFun = opts.filter ? opts.filter.toString() : '';
      var queryParams = '';
      var filterViewName =  '';
      var selector = '';

      // possibility for checkpoints to be lost here as behaviour of
      // JSON.stringify is not stable (see #6226)
      /* istanbul ignore if */
      if (opts.selector) {
        selector = JSON.stringify(opts.selector);
      }

      if (opts.filter && opts.query_params) {
        queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));
      }

      if (opts.filter && opts.filter === '_view') {
        filterViewName = opts.view.toString();
      }

      return Promise.all([src.id(), target.id()]).then(function (res) {
        var queryData = res[0] + res[1] + filterFun + filterViewName +
          queryParams + docIds + selector;
        return new Promise(function (resolve) {
          binaryMd5(queryData, resolve);
        });
      }).then(function (md5sum) {
        // can't use straight-up md5 alphabet, because
        // the char '/' is interpreted as being for attachments,
        // and + is also not url-safe
        md5sum = md5sum.replace(/\//g, '.').replace(/\+/g, '_');
        return '_local/' + md5sum;
      });
    }

    function replicate(src, target, opts, returnValue, result) {
      var batches = [];               // list of batches to be processed
      var currentBatch;               // the batch currently being processed
      var pendingBatch = {
        seq: 0,
        changes: [],
        docs: []
      }; // next batch, not yet ready to be processed
      var writingCheckpoint = false;  // true while checkpoint is being written
      var changesCompleted = false;   // true when all changes received
      var replicationCompleted = false; // true when replication has completed
      var last_seq = 0;
      var continuous = opts.continuous || opts.live || false;
      var batch_size = opts.batch_size || 100;
      var batches_limit = opts.batches_limit || 10;
      var changesPending = false;     // true while src.changes is running
      var doc_ids = opts.doc_ids;
      var selector = opts.selector;
      var repId;
      var checkpointer;
      var changedDocs = [];
      // Like couchdb, every replication gets a unique session id
      var session = uuid();

      result = result || {
        ok: true,
        start_time: new Date().toISOString(),
        docs_read: 0,
        docs_written: 0,
        doc_write_failures: 0,
        errors: []
      };

      var changesOpts = {};
      returnValue.ready(src, target);

      function initCheckpointer() {
        if (checkpointer) {
          return Promise.resolve();
        }
        return generateReplicationId(src, target, opts).then(function (res) {
          repId = res;

          var checkpointOpts = {};
          if (opts.checkpoint === false) {
            checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };
          } else if (opts.checkpoint === 'source') {
            checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };
          } else if (opts.checkpoint === 'target') {
            checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };
          } else {
            checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };
          }

          checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);
        });
      }

      function writeDocs() {
        changedDocs = [];

        if (currentBatch.docs.length === 0) {
          return;
        }
        var docs = currentBatch.docs;
        var bulkOpts = {timeout: opts.timeout};
        return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {
          /* istanbul ignore if */
          if (returnValue.cancelled) {
            completeReplication();
            throw new Error('cancelled');
          }

          // `res` doesn't include full documents (which live in `docs`), so we create a map of 
          // (id -> error), and check for errors while iterating over `docs`
          var errorsById = Object.create(null);
          res.forEach(function (res) {
            if (res.error) {
              errorsById[res.id] = res;
            }
          });

          var errorsNo = Object.keys(errorsById).length;
          result.doc_write_failures += errorsNo;
          result.docs_written += docs.length - errorsNo;

          docs.forEach(function (doc) {
            var error = errorsById[doc._id];
            if (error) {
              result.errors.push(error);
              // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
              var errorName = (error.name || '').toLowerCase();
              if (errorName === 'unauthorized' || errorName === 'forbidden') {
                returnValue.emit('denied', clone(error));
              } else {
                throw error;
              }
            } else {
              changedDocs.push(doc);
            }
          });

        }, function (err) {
          result.doc_write_failures += docs.length;
          throw err;
        });
      }

      function finishBatch() {
        if (currentBatch.error) {
          throw new Error('There was a problem getting docs.');
        }
        result.last_seq = last_seq = currentBatch.seq;
        var outResult = clone(result);
        if (changedDocs.length) {
          outResult.docs = changedDocs;
          // Attach 'pending' property if server supports it (CouchDB 2.0+)
          /* istanbul ignore if */
          if (typeof currentBatch.pending === 'number') {
            outResult.pending = currentBatch.pending;
            delete currentBatch.pending;
          }
          returnValue.emit('change', outResult);
        }
        writingCheckpoint = true;
        return checkpointer.writeCheckpoint(currentBatch.seq,
            session).then(function () {
          writingCheckpoint = false;
          /* istanbul ignore if */
          if (returnValue.cancelled) {
            completeReplication();
            throw new Error('cancelled');
          }
          currentBatch = undefined;
          getChanges();
        }).catch(function (err) {
          onCheckpointError(err);
          throw err;
        });
      }

      function getDiffs() {
        var diff = {};
        currentBatch.changes.forEach(function (change) {
          // Couchbase Sync Gateway emits these, but we can ignore them
          /* istanbul ignore if */
          if (change.id === "_user/") {
            return;
          }
          diff[change.id] = change.changes.map(function (x) {
            return x.rev;
          });
        });
        return target.revsDiff(diff).then(function (diffs) {
          /* istanbul ignore if */
          if (returnValue.cancelled) {
            completeReplication();
            throw new Error('cancelled');
          }
          // currentBatch.diffs elements are deleted as the documents are written
          currentBatch.diffs = diffs;
        });
      }

      function getBatchDocs() {
        return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {
          currentBatch.error = !got.ok;
          got.docs.forEach(function (doc) {
            delete currentBatch.diffs[doc._id];
            result.docs_read++;
            currentBatch.docs.push(doc);
          });
        });
      }

      function startNextBatch() {
        if (returnValue.cancelled || currentBatch) {
          return;
        }
        if (batches.length === 0) {
          processPendingBatch(true);
          return;
        }
        currentBatch = batches.shift();
        getDiffs()
          .then(getBatchDocs)
          .then(writeDocs)
          .then(finishBatch)
          .then(startNextBatch)
          .catch(function (err) {
            abortReplication('batch processing terminated with error', err);
          });
      }


      function processPendingBatch(immediate$$1) {
        if (pendingBatch.changes.length === 0) {
          if (batches.length === 0 && !currentBatch) {
            if ((continuous && changesOpts.live) || changesCompleted) {
              returnValue.state = 'pending';
              returnValue.emit('paused');
            }
            if (changesCompleted) {
              completeReplication();
            }
          }
          return;
        }
        if (
          immediate$$1 ||
          changesCompleted ||
          pendingBatch.changes.length >= batch_size
        ) {
          batches.push(pendingBatch);
          pendingBatch = {
            seq: 0,
            changes: [],
            docs: []
          };
          if (returnValue.state === 'pending' || returnValue.state === 'stopped') {
            returnValue.state = 'active';
            returnValue.emit('active');
          }
          startNextBatch();
        }
      }


      function abortReplication(reason, err) {
        if (replicationCompleted) {
          return;
        }
        if (!err.message) {
          err.message = reason;
        }
        result.ok = false;
        result.status = 'aborting';
        batches = [];
        pendingBatch = {
          seq: 0,
          changes: [],
          docs: []
        };
        completeReplication(err);
      }


      function completeReplication(fatalError) {
        if (replicationCompleted) {
          return;
        }
        /* istanbul ignore if */
        if (returnValue.cancelled) {
          result.status = 'cancelled';
          if (writingCheckpoint) {
            return;
          }
        }
        result.status = result.status || 'complete';
        result.end_time = new Date().toISOString();
        result.last_seq = last_seq;
        replicationCompleted = true;

        if (fatalError) {
          // need to extend the error because Firefox considers ".result" read-only
          fatalError = createError(fatalError);
          fatalError.result = result;

          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
          var errorName = (fatalError.name || '').toLowerCase();
          if (errorName === 'unauthorized' || errorName === 'forbidden') {
            returnValue.emit('error', fatalError);
            returnValue.removeAllListeners();
          } else {
            backOff(opts, returnValue, fatalError, function () {
              replicate(src, target, opts, returnValue);
            });
          }
        } else {
          returnValue.emit('complete', result);
          returnValue.removeAllListeners();
        }
      }


      function onChange(change, pending, lastSeq) {
        /* istanbul ignore if */
        if (returnValue.cancelled) {
          return completeReplication();
        }
        // Attach 'pending' property if server supports it (CouchDB 2.0+)
        /* istanbul ignore if */
        if (typeof pending === 'number') {
          pendingBatch.pending = pending;
        }

        var filter = filterChange(opts)(change);
        if (!filter) {
          return;
        }
        pendingBatch.seq = change.seq || lastSeq;
        pendingBatch.changes.push(change);
        lib(function () {
          processPendingBatch(batches.length === 0 && changesOpts.live);
        });
      }


      function onChangesComplete(changes) {
        changesPending = false;
        /* istanbul ignore if */
        if (returnValue.cancelled) {
          return completeReplication();
        }

        // if no results were returned then we're done,
        // else fetch more
        if (changes.results.length > 0) {
          changesOpts.since = changes.results[changes.results.length - 1].seq;
          getChanges();
          processPendingBatch(true);
        } else {

          var complete = function () {
            if (continuous) {
              changesOpts.live = true;
              getChanges();
            } else {
              changesCompleted = true;
            }
            processPendingBatch(true);
          };

          // update the checkpoint so we start from the right seq next time
          if (!currentBatch && changes.results.length === 0) {
            writingCheckpoint = true;
            checkpointer.writeCheckpoint(changes.last_seq,
                session).then(function () {
              writingCheckpoint = false;
              result.last_seq = last_seq = changes.last_seq;
              complete();
            })
            .catch(onCheckpointError);
          } else {
            complete();
          }
        }
      }


      function onChangesError(err) {
        changesPending = false;
        /* istanbul ignore if */
        if (returnValue.cancelled) {
          return completeReplication();
        }
        abortReplication('changes rejected', err);
      }


      function getChanges() {
        if (!(
          !changesPending &&
          !changesCompleted &&
          batches.length < batches_limit
          )) {
          return;
        }
        changesPending = true;
        function abortChanges() {
          changes.cancel();
        }
        function removeListener() {
          returnValue.removeListener('cancel', abortChanges);
        }

        if (returnValue._changes) { // remove old changes() and listeners
          returnValue.removeListener('cancel', returnValue._abortChanges);
          returnValue._changes.cancel();
        }
        returnValue.once('cancel', abortChanges);

        var changes = src.changes(changesOpts)
          .on('change', onChange);
        changes.then(removeListener, removeListener);
        changes.then(onChangesComplete)
          .catch(onChangesError);

        if (opts.retry) {
          // save for later so we can cancel if necessary
          returnValue._changes = changes;
          returnValue._abortChanges = abortChanges;
        }
      }


      function startChanges() {
        initCheckpointer().then(function () {
          /* istanbul ignore if */
          if (returnValue.cancelled) {
            completeReplication();
            return;
          }
          return checkpointer.getCheckpoint().then(function (checkpoint) {
            last_seq = checkpoint;
            changesOpts = {
              since: last_seq,
              limit: batch_size,
              batch_size: batch_size,
              style: 'all_docs',
              doc_ids: doc_ids,
              selector: selector,
              return_docs: true // required so we know when we're done
            };
            if (opts.filter) {
              if (typeof opts.filter !== 'string') {
                // required for the client-side filter in onChange
                changesOpts.include_docs = true;
              } else { // ddoc filter
                changesOpts.filter = opts.filter;
              }
            }
            if ('heartbeat' in opts) {
              changesOpts.heartbeat = opts.heartbeat;
            }
            if ('timeout' in opts) {
              changesOpts.timeout = opts.timeout;
            }
            if (opts.query_params) {
              changesOpts.query_params = opts.query_params;
            }
            if (opts.view) {
              changesOpts.view = opts.view;
            }
            getChanges();
          });
        }).catch(function (err) {
          abortReplication('getCheckpoint rejected with ', err);
        });
      }

      /* istanbul ignore next */
      function onCheckpointError(err) {
        writingCheckpoint = false;
        abortReplication('writeCheckpoint completed with error', err);
      }

      /* istanbul ignore if */
      if (returnValue.cancelled) { // cancelled immediately
        completeReplication();
        return;
      }

      if (!returnValue._addedListeners) {
        returnValue.once('cancel', completeReplication);

        if (typeof opts.complete === 'function') {
          returnValue.once('error', opts.complete);
          returnValue.once('complete', function (result) {
            opts.complete(null, result);
          });
        }
        returnValue._addedListeners = true;
      }

      if (typeof opts.since === 'undefined') {
        startChanges();
      } else {
        initCheckpointer().then(function () {
          writingCheckpoint = true;
          return checkpointer.writeCheckpoint(opts.since, session);
        }).then(function () {
          writingCheckpoint = false;
          /* istanbul ignore if */
          if (returnValue.cancelled) {
            completeReplication();
            return;
          }
          last_seq = opts.since;
          startChanges();
        }).catch(onCheckpointError);
      }
    }

    // We create a basic promise so the caller can cancel the replication possibly
    // before we have actually started listening to changes etc
    inherits_browser(Replication, EventEmitter);
    function Replication() {
      EventEmitter.call(this);
      this.cancelled = false;
      this.state = 'pending';
      var self = this;
      var promise = new Promise(function (fulfill, reject) {
        self.once('complete', fulfill);
        self.once('error', reject);
      });
      self.then = function (resolve, reject) {
        return promise.then(resolve, reject);
      };
      self.catch = function (reject) {
        return promise.catch(reject);
      };
      // As we allow error handling via "error" event as well,
      // put a stub in here so that rejecting never throws UnhandledError.
      self.catch(function () {});
    }

    Replication.prototype.cancel = function () {
      this.cancelled = true;
      this.state = 'cancelled';
      this.emit('cancel');
    };

    Replication.prototype.ready = function (src, target) {
      var self = this;
      if (self._readyCalled) {
        return;
      }
      self._readyCalled = true;

      function onDestroy() {
        self.cancel();
      }
      src.once('destroyed', onDestroy);
      target.once('destroyed', onDestroy);
      function cleanup() {
        src.removeListener('destroyed', onDestroy);
        target.removeListener('destroyed', onDestroy);
      }
      self.once('complete', cleanup);
    };

    function toPouch(db, opts) {
      var PouchConstructor = opts.PouchConstructor;
      if (typeof db === 'string') {
        return new PouchConstructor(db, opts);
      } else {
        return db;
      }
    }

    function replicateWrapper(src, target, opts, callback) {

      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      if (typeof opts === 'undefined') {
        opts = {};
      }

      if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {
        throw createError(BAD_REQUEST,
                           "`doc_ids` filter parameter is not a list.");
      }

      opts.complete = callback;
      opts = clone(opts);
      opts.continuous = opts.continuous || opts.live;
      opts.retry = ('retry' in opts) ? opts.retry : false;
      /*jshint validthis:true */
      opts.PouchConstructor = opts.PouchConstructor || this;
      var replicateRet = new Replication(opts);
      var srcPouch = toPouch(src, opts);
      var targetPouch = toPouch(target, opts);
      replicate(srcPouch, targetPouch, opts, replicateRet);
      return replicateRet;
    }

    inherits_browser(Sync, EventEmitter);
    function sync(src, target, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      if (typeof opts === 'undefined') {
        opts = {};
      }
      opts = clone(opts);
      /*jshint validthis:true */
      opts.PouchConstructor = opts.PouchConstructor || this;
      src = toPouch(src, opts);
      target = toPouch(target, opts);
      return new Sync(src, target, opts, callback);
    }

    function Sync(src, target, opts, callback) {
      var self = this;
      this.canceled = false;

      var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;
      var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;

      this.push = replicateWrapper(src, target, optsPush);
      this.pull = replicateWrapper(target, src, optsPull);

      this.pushPaused = true;
      this.pullPaused = true;

      function pullChange(change) {
        self.emit('change', {
          direction: 'pull',
          change: change
        });
      }
      function pushChange(change) {
        self.emit('change', {
          direction: 'push',
          change: change
        });
      }
      function pushDenied(doc) {
        self.emit('denied', {
          direction: 'push',
          doc: doc
        });
      }
      function pullDenied(doc) {
        self.emit('denied', {
          direction: 'pull',
          doc: doc
        });
      }
      function pushPaused() {
        self.pushPaused = true;
        /* istanbul ignore if */
        if (self.pullPaused) {
          self.emit('paused');
        }
      }
      function pullPaused() {
        self.pullPaused = true;
        /* istanbul ignore if */
        if (self.pushPaused) {
          self.emit('paused');
        }
      }
      function pushActive() {
        self.pushPaused = false;
        /* istanbul ignore if */
        if (self.pullPaused) {
          self.emit('active', {
            direction: 'push'
          });
        }
      }
      function pullActive() {
        self.pullPaused = false;
        /* istanbul ignore if */
        if (self.pushPaused) {
          self.emit('active', {
            direction: 'pull'
          });
        }
      }

      var removed = {};

      function removeAll(type) { // type is 'push' or 'pull'
        return function (event, func) {
          var isChange = event === 'change' &&
            (func === pullChange || func === pushChange);
          var isDenied = event === 'denied' &&
            (func === pullDenied || func === pushDenied);
          var isPaused = event === 'paused' &&
            (func === pullPaused || func === pushPaused);
          var isActive = event === 'active' &&
            (func === pullActive || func === pushActive);

          if (isChange || isDenied || isPaused || isActive) {
            if (!(event in removed)) {
              removed[event] = {};
            }
            removed[event][type] = true;
            if (Object.keys(removed[event]).length === 2) {
              // both push and pull have asked to be removed
              self.removeAllListeners(event);
            }
          }
        };
      }

      if (opts.live) {
        this.push.on('complete', self.pull.cancel.bind(self.pull));
        this.pull.on('complete', self.push.cancel.bind(self.push));
      }

      function addOneListener(ee, event, listener) {
        if (ee.listeners(event).indexOf(listener) == -1) {
          ee.on(event, listener);
        }
      }

      this.on('newListener', function (event) {
        if (event === 'change') {
          addOneListener(self.pull, 'change', pullChange);
          addOneListener(self.push, 'change', pushChange);
        } else if (event === 'denied') {
          addOneListener(self.pull, 'denied', pullDenied);
          addOneListener(self.push, 'denied', pushDenied);
        } else if (event === 'active') {
          addOneListener(self.pull, 'active', pullActive);
          addOneListener(self.push, 'active', pushActive);
        } else if (event === 'paused') {
          addOneListener(self.pull, 'paused', pullPaused);
          addOneListener(self.push, 'paused', pushPaused);
        }
      });

      this.on('removeListener', function (event) {
        if (event === 'change') {
          self.pull.removeListener('change', pullChange);
          self.push.removeListener('change', pushChange);
        } else if (event === 'denied') {
          self.pull.removeListener('denied', pullDenied);
          self.push.removeListener('denied', pushDenied);
        } else if (event === 'active') {
          self.pull.removeListener('active', pullActive);
          self.push.removeListener('active', pushActive);
        } else if (event === 'paused') {
          self.pull.removeListener('paused', pullPaused);
          self.push.removeListener('paused', pushPaused);
        }
      });

      this.pull.on('removeListener', removeAll('pull'));
      this.push.on('removeListener', removeAll('push'));

      var promise = Promise.all([
        this.push,
        this.pull
      ]).then(function (resp) {
        var out = {
          push: resp[0],
          pull: resp[1]
        };
        self.emit('complete', out);
        if (callback) {
          callback(null, out);
        }
        self.removeAllListeners();
        return out;
      }, function (err) {
        self.cancel();
        if (callback) {
          // if there's a callback, then the callback can receive
          // the error event
          callback(err);
        } else {
          // if there's no callback, then we're safe to emit an error
          // event, which would otherwise throw an unhandled error
          // due to 'error' being a special event in EventEmitters
          self.emit('error', err);
        }
        self.removeAllListeners();
        if (callback) {
          // no sense throwing if we're already emitting an 'error' event
          throw err;
        }
      });

      this.then = function (success, err) {
        return promise.then(success, err);
      };

      this.catch = function (err) {
        return promise.catch(err);
      };
    }

    Sync.prototype.cancel = function () {
      if (!this.canceled) {
        this.canceled = true;
        this.push.cancel();
        this.pull.cancel();
      }
    };

    function replication(PouchDB) {
      PouchDB.replicate = replicateWrapper;
      PouchDB.sync = sync;

      Object.defineProperty(PouchDB.prototype, 'replicate', {
        get: function () {
          var self = this;
          if (typeof this.replicateMethods === 'undefined') {
            this.replicateMethods = {
              from: function (other, opts, callback) {
                return self.constructor.replicate(other, self, opts, callback);
              },
              to: function (other, opts, callback) {
                return self.constructor.replicate(self, other, opts, callback);
              }
            };
          }
          return this.replicateMethods;
        }
      });

      PouchDB.prototype.sync = function (dbName, opts, callback) {
        return this.constructor.sync(this, dbName, opts, callback);
      };
    }

    PouchDB.plugin(IDBPouch)
      .plugin(HttpPouch$1)
      .plugin(mapreduce)
      .plugin(replication);

    /* src\Database\Database.svelte generated by Svelte v3.32.1 */

    function create_fragment$v(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Database", slots, []);
    	let { db } = $$props;
    	let { name } = $$props;
    	let { initDocsSrc = null } = $$props;

    	onMount(async () => {
    		const database = new PouchDB(name);
    		const res = await database.info(); // wait until database is up

    		if (res.update_seq === 0 && initDocsSrc !== null) {
    			// if there is no revision (aka nothing) in the DB and a JSON to initialize the DB
    			const res = await fetch(initDocsSrc);

    			const docs = await res.json();
    			database.bulkDocs(docs); // populate the database with the initial docs
    		}

    		$$invalidate(0, db = database);
    	});

    	const writable_props = ["db", "name", "initDocsSrc"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Database> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("db" in $$props) $$invalidate(0, db = $$props.db);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("initDocsSrc" in $$props) $$invalidate(2, initDocsSrc = $$props.initDocsSrc);
    	};

    	$$self.$capture_state = () => ({ onMount, PouchDB, db, name, initDocsSrc });

    	$$self.$inject_state = $$props => {
    		if ("db" in $$props) $$invalidate(0, db = $$props.db);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("initDocsSrc" in $$props) $$invalidate(2, initDocsSrc = $$props.initDocsSrc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [db, name, initDocsSrc];
    }

    class Database extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { db: 0, name: 1, initDocsSrc: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Database",
    			options,
    			id: create_fragment$v.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*db*/ ctx[0] === undefined && !("db" in props)) {
    			console.warn("<Database> was created without expected prop 'db'");
    		}

    		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
    			console.warn("<Database> was created without expected prop 'name'");
    		}
    	}

    	get db() {
    		throw new Error("<Database>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set db(value) {
    		throw new Error("<Database>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Database>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Database>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get initDocsSrc() {
    		throw new Error("<Database>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set initDocsSrc(value) {
    		throw new Error("<Database>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var object_hash = createCommonjsModule(function (module, exports) {
    !function(e){module.exports=e();}(function(){return function o(i,u,a){function s(n,e){if(!u[n]){if(!i[n]){var t="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&t)return t(n,!0);if(f)return f(n,!0);throw new Error("Cannot find module '"+n+"'")}var r=u[n]={exports:{}};i[n][0].call(r.exports,function(e){var t=i[n][1][e];return s(t||e)},r,r.exports,o,i,u,a);}return u[n].exports}for(var f="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<a.length;e++)s(a[e]);return s}({1:[function(w,b,m){(function(e,t,f,n,r,o,i,u,a){var s=w("crypto");function l(e,t){return function(e,t){var n;n="passthrough"!==t.algorithm?s.createHash(t.algorithm):new y;void 0===n.write&&(n.write=n.update,n.end=n.update);g(t,n).dispatch(e),n.update||n.end("");if(n.digest)return n.digest("buffer"===t.encoding?void 0:t.encoding);var r=n.read();return "buffer"!==t.encoding?r.toString(t.encoding):r}(e,t=h(e,t))}(m=b.exports=l).sha1=function(e){return l(e)},m.keys=function(e){return l(e,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},m.MD5=function(e){return l(e,{algorithm:"md5",encoding:"hex"})},m.keysMD5=function(e){return l(e,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var c=s.getHashes?s.getHashes().slice():["sha1","md5"];c.push("passthrough");var d=["buffer","hex","binary","base64"];function h(e,t){t=t||{};var n={};if(n.algorithm=t.algorithm||"sha1",n.encoding=t.encoding||"hex",n.excludeValues=!!t.excludeValues,n.algorithm=n.algorithm.toLowerCase(),n.encoding=n.encoding.toLowerCase(),n.ignoreUnknown=!0===t.ignoreUnknown,n.respectType=!1!==t.respectType,n.respectFunctionNames=!1!==t.respectFunctionNames,n.respectFunctionProperties=!1!==t.respectFunctionProperties,n.unorderedArrays=!0===t.unorderedArrays,n.unorderedSets=!1!==t.unorderedSets,n.unorderedObjects=!1!==t.unorderedObjects,n.replacer=t.replacer||void 0,n.excludeKeys=t.excludeKeys||void 0,void 0===e)throw new Error("Object argument required.");for(var r=0;r<c.length;++r)c[r].toLowerCase()===n.algorithm.toLowerCase()&&(n.algorithm=c[r]);if(-1===c.indexOf(n.algorithm))throw new Error('Algorithm "'+n.algorithm+'"  not supported. supported values: '+c.join(", "));if(-1===d.indexOf(n.encoding)&&"passthrough"!==n.algorithm)throw new Error('Encoding "'+n.encoding+'"  not supported. supported values: '+d.join(", "));return n}function p(e){if("function"==typeof e){return null!=/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e))}}function g(u,t,a){a=a||[];function s(e){return t.update?t.update(e,"utf8"):t.write(e,"utf8")}return {dispatch:function(e){return u.replacer&&(e=u.replacer(e)),this["_"+(null===e?"null":typeof e)](e)},_object:function(t){var e=Object.prototype.toString.call(t),n=/\[object (.*)\]/i.exec(e);n=(n=n?n[1]:"unknown:["+e+"]").toLowerCase();var r;if(0<=(r=a.indexOf(t)))return this.dispatch("[CIRCULAR:"+r+"]");if(a.push(t),void 0!==f&&f.isBuffer&&f.isBuffer(t))return s("buffer:"),s(t);if("object"===n||"function"===n||"asyncfunction"===n){var o=Object.keys(t);u.unorderedObjects&&(o=o.sort()),!1===u.respectType||p(t)||o.splice(0,0,"prototype","__proto__","constructor"),u.excludeKeys&&(o=o.filter(function(e){return !u.excludeKeys(e)})),s("object:"+o.length+":");var i=this;return o.forEach(function(e){i.dispatch(e),s(":"),u.excludeValues||i.dispatch(t[e]),s(",");})}if(!this["_"+n]){if(u.ignoreUnknown)return s("["+n+"]");throw new Error('Unknown object type "'+n+'"')}this["_"+n](t);},_array:function(e,t){t=void 0!==t?t:!1!==u.unorderedArrays;var n=this;if(s("array:"+e.length+":"),!t||e.length<=1)return e.forEach(function(e){return n.dispatch(e)});var r=[],o=e.map(function(e){var t=new y,n=a.slice();return g(u,t,n).dispatch(e),r=r.concat(n.slice(a.length)),t.read().toString()});return a=a.concat(r),o.sort(),this._array(o,!1)},_date:function(e){return s("date:"+e.toJSON())},_symbol:function(e){return s("symbol:"+e.toString())},_error:function(e){return s("error:"+e.toString())},_boolean:function(e){return s("bool:"+e.toString())},_string:function(e){s("string:"+e.length+":"),s(e.toString());},_function:function(e){s("fn:"),p(e)?this.dispatch("[native]"):this.dispatch(e.toString()),!1!==u.respectFunctionNames&&this.dispatch("function-name:"+String(e.name)),u.respectFunctionProperties&&this._object(e);},_number:function(e){return s("number:"+e.toString())},_xml:function(e){return s("xml:"+e.toString())},_null:function(){return s("Null")},_undefined:function(){return s("Undefined")},_regexp:function(e){return s("regex:"+e.toString())},_uint8array:function(e){return s("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint8clampedarray:function(e){return s("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(e))},_int8array:function(e){return s("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint16array:function(e){return s("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_int16array:function(e){return s("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_uint32array:function(e){return s("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_int32array:function(e){return s("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_float32array:function(e){return s("float32array:"),this.dispatch(Array.prototype.slice.call(e))},_float64array:function(e){return s("float64array:"),this.dispatch(Array.prototype.slice.call(e))},_arraybuffer:function(e){return s("arraybuffer:"),this.dispatch(new Uint8Array(e))},_url:function(e){return s("url:"+e.toString())},_map:function(e){s("map:");var t=Array.from(e);return this._array(t,!1!==u.unorderedSets)},_set:function(e){s("set:");var t=Array.from(e);return this._array(t,!1!==u.unorderedSets)},_file:function(e){return s("file:"),this.dispatch([e.name,e.size,e.type,e.lastModfied])},_blob:function(){if(u.ignoreUnknown)return s("[blob]");throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')},_domwindow:function(){return s("domwindow")},_process:function(){return s("process")},_timer:function(){return s("timer")},_pipe:function(){return s("pipe")},_tcp:function(){return s("tcp")},_udp:function(){return s("udp")},_tty:function(){return s("tty")},_statwatcher:function(){return s("statwatcher")},_securecontext:function(){return s("securecontext")},_connection:function(){return s("connection")},_zlib:function(){return s("zlib")},_context:function(){return s("context")},_nodescript:function(){return s("nodescript")},_httpparser:function(){return s("httpparser")},_dataview:function(){return s("dataview")},_signal:function(){return s("signal")},_fsevent:function(){return s("fsevent")},_tlswrap:function(){return s("tlswrap")}}}function y(){return {buf:"",write:function(e){this.buf+=e;},end:function(e){this.buf+=e;},read:function(){return this.buf}}}m.writeToStream=function(e,t,n){return void 0===n&&(n=t,t={}),g(t=h(e,t),n).dispatch(e)};}).call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_5812b7fb.js","/");},{buffer:3,crypto:5,lYpoI2:10}],2:[function(e,t,f){(function(e,t,n,r,o,i,u,a,s){!function(e){var f="undefined"!=typeof Uint8Array?Uint8Array:Array,n="+".charCodeAt(0),r="/".charCodeAt(0),o="0".charCodeAt(0),i="a".charCodeAt(0),u="A".charCodeAt(0),a="-".charCodeAt(0),s="_".charCodeAt(0);function l(e){var t=e.charCodeAt(0);return t===n||t===a?62:t===r||t===s?63:t<o?-1:t<o+10?t-o+26+26:t<u+26?t-u:t<i+26?t-i+26:void 0}e.toByteArray=function(e){var t,n;if(0<e.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.length,o="="===e.charAt(r-2)?2:"="===e.charAt(r-1)?1:0,i=new f(3*e.length/4-o),u=0<o?e.length-4:e.length,a=0;function s(e){i[a++]=e;}for(t=0;t<u;t+=4,0)s((16711680&(n=l(e.charAt(t))<<18|l(e.charAt(t+1))<<12|l(e.charAt(t+2))<<6|l(e.charAt(t+3))))>>16),s((65280&n)>>8),s(255&n);return 2==o?s(255&(n=l(e.charAt(t))<<2|l(e.charAt(t+1))>>4)):1==o&&(s((n=l(e.charAt(t))<<10|l(e.charAt(t+1))<<4|l(e.charAt(t+2))>>2)>>8&255),s(255&n)),i},e.fromByteArray=function(e){var t,n,r,o,i=e.length%3,u="";function a(e){return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)}for(t=0,r=e.length-i;t<r;t+=3)n=(e[t]<<16)+(e[t+1]<<8)+e[t+2],u+=a((o=n)>>18&63)+a(o>>12&63)+a(o>>6&63)+a(63&o);switch(i){case 1:u+=a((n=e[e.length-1])>>2),u+=a(n<<4&63),u+="==";break;case 2:u+=a((n=(e[e.length-2]<<8)+e[e.length-1])>>10),u+=a(n>>4&63),u+=a(n<<2&63),u+="=";}return u};}(void 0===f?this.base64js={}:f);}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib");},{buffer:3,lYpoI2:10}],3:[function(O,e,H){(function(e,t,g,n,r,o,i,u,a){var s=O("base64-js"),f=O("ieee754");function g(e,t,n){if(!(this instanceof g))return new g(e,t,n);var r,o,i,u,a,s=typeof e;if("base64"===t&&"string"==s)for(e=(r=e).trim?r.trim():r.replace(/^\s+|\s+$/g,"");e.length%4!=0;)e+="=";if("number"==s)o=x(e);else if("string"==s)o=g.byteLength(e,t);else {if("object"!=s)throw new Error("First argument needs to be a number, array or string.");o=x(e.length);}if(g._useTypedArrays?i=g._augment(new Uint8Array(o)):((i=this).length=o,i._isBuffer=!0),g._useTypedArrays&&"number"==typeof e.byteLength)i._set(e);else if(S(a=e)||g.isBuffer(a)||a&&"object"==typeof a&&"number"==typeof a.length)for(u=0;u<o;u++)g.isBuffer(e)?i[u]=e.readUInt8(u):i[u]=e[u];else if("string"==s)i.write(e,0,t);else if("number"==s&&!g._useTypedArrays&&!n)for(u=0;u<o;u++)i[u]=0;return i}function y(e,t,n,r){return g._charsWritten=T(function(e){for(var t=[],n=0;n<e.length;n++)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function w(e,t,n,r){return g._charsWritten=T(function(e){for(var t,n,r,o=[],i=0;i<e.length;i++)t=e.charCodeAt(i),n=t>>8,r=t%256,o.push(r),o.push(n);return o}(t),e,n,r)}function l(e,t,n){var r="";n=Math.min(e.length,n);for(var o=t;o<n;o++)r+=String.fromCharCode(e[o]);return r}function c(e,t,n,r){r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+1<e.length,"Trying to read beyond buffer length"));var o,i=e.length;if(!(i<=t))return n?(o=e[t],t+1<i&&(o|=e[t+1]<<8)):(o=e[t]<<8,t+1<i&&(o|=e[t+1])),o}function d(e,t,n,r){r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+3<e.length,"Trying to read beyond buffer length"));var o,i=e.length;if(!(i<=t))return n?(t+2<i&&(o=e[t+2]<<16),t+1<i&&(o|=e[t+1]<<8),o|=e[t],t+3<i&&(o+=e[t+3]<<24>>>0)):(t+1<i&&(o=e[t+1]<<16),t+2<i&&(o|=e[t+2]<<8),t+3<i&&(o|=e[t+3]),o+=e[t]<<24>>>0),o}function h(e,t,n,r){if(r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+1<e.length,"Trying to read beyond buffer length")),!(e.length<=t)){var o=c(e,t,n,!0);return 32768&o?-1*(65535-o+1):o}}function p(e,t,n,r){if(r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+3<e.length,"Trying to read beyond buffer length")),!(e.length<=t)){var o=d(e,t,n,!0);return 2147483648&o?-1*(4294967295-o+1):o}}function b(e,t,n,r){return r||(D("boolean"==typeof n,"missing or invalid endian"),D(t+3<e.length,"Trying to read beyond buffer length")),f.read(e,t,n,23,4)}function m(e,t,n,r){return r||(D("boolean"==typeof n,"missing or invalid endian"),D(t+7<e.length,"Trying to read beyond buffer length")),f.read(e,t,n,52,8)}function v(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+1<e.length,"trying to write beyond buffer length"),N(t,65535));var i=e.length;if(!(i<=n))for(var u=0,a=Math.min(i-n,2);u<a;u++)e[n+u]=(t&255<<8*(r?u:1-u))>>>8*(r?u:1-u);}function _(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+3<e.length,"trying to write beyond buffer length"),N(t,4294967295));var i=e.length;if(!(i<=n))for(var u=0,a=Math.min(i-n,4);u<a;u++)e[n+u]=t>>>8*(r?u:3-u)&255;}function E(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+1<e.length,"Trying to write beyond buffer length"),Y(t,32767,-32768)),e.length<=n||v(e,0<=t?t:65535+t+1,n,r,o);}function I(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+3<e.length,"Trying to write beyond buffer length"),Y(t,2147483647,-2147483648)),e.length<=n||_(e,0<=t?t:4294967295+t+1,n,r,o);}function A(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+3<e.length,"Trying to write beyond buffer length"),F(t,34028234663852886e22,-34028234663852886e22)),e.length<=n||f.write(e,t,n,r,23,4);}function B(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+7<e.length,"Trying to write beyond buffer length"),F(t,17976931348623157e292,-17976931348623157e292)),e.length<=n||f.write(e,t,n,r,52,8);}H.Buffer=g,H.SlowBuffer=g,H.INSPECT_MAX_BYTES=50,g.poolSize=8192,g._useTypedArrays=function(){try{var e=new ArrayBuffer(0),t=new Uint8Array(e);return t.foo=function(){return 42},42===t.foo()&&"function"==typeof t.subarray}catch(e){return !1}}(),g.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},g.isBuffer=function(e){return !(null==e||!e._isBuffer)},g.byteLength=function(e,t){var n;switch(e+="",t||"utf8"){case"hex":n=e.length/2;break;case"utf8":case"utf-8":n=C(e).length;break;case"ascii":case"binary":case"raw":n=e.length;break;case"base64":n=k(e).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":n=2*e.length;break;default:throw new Error("Unknown encoding")}return n},g.concat=function(e,t){if(D(S(e),"Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."),0===e.length)return new g(0);if(1===e.length)return e[0];if("number"!=typeof t)for(o=t=0;o<e.length;o++)t+=e[o].length;for(var n=new g(t),r=0,o=0;o<e.length;o++){var i=e[o];i.copy(n,r),r+=i.length;}return n},g.prototype.write=function(e,t,n,r){var o;isFinite(t)?isFinite(n)||(r=n,n=void 0):(o=r,r=t,t=n,n=o),t=Number(t)||0;var i,u,a,s,f,l,c,d,h,p=this.length-t;switch((!n||p<(n=Number(n)))&&(n=p),r=String(r||"utf8").toLowerCase()){case"hex":i=function(e,t,n,r){n=Number(n)||0;var o=e.length-n;(!r||o<(r=Number(r)))&&(r=o);var i=t.length;D(i%2==0,"Invalid hex string"),i/2<r&&(r=i/2);for(var u=0;u<r;u++){var a=parseInt(t.substr(2*u,2),16);D(!isNaN(a),"Invalid hex string"),e[n+u]=a;}return g._charsWritten=2*u,u}(this,e,t,n);break;case"utf8":case"utf-8":l=this,c=e,d=t,h=n,i=g._charsWritten=T(C(c),l,d,h);break;case"ascii":case"binary":i=y(this,e,t,n);break;case"base64":u=this,a=e,s=t,f=n,i=g._charsWritten=T(k(a),u,s,f);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":i=w(this,e,t,n);break;default:throw new Error("Unknown encoding")}return i},g.prototype.toString=function(e,t,n){var r,o,i,u,a=this;if(e=String(e||"utf8").toLowerCase(),t=Number(t)||0,(n=void 0!==n?Number(n):n=a.length)===t)return "";switch(e){case"hex":r=function(e,t,n){var r=e.length;(!t||t<0)&&(t=0);(!n||n<0||r<n)&&(n=r);for(var o="",i=t;i<n;i++)o+=j(e[i]);return o}(a,t,n);break;case"utf8":case"utf-8":r=function(e,t,n){var r="",o="";n=Math.min(e.length,n);for(var i=t;i<n;i++)e[i]<=127?(r+=M(o)+String.fromCharCode(e[i]),o=""):o+="%"+e[i].toString(16);return r+M(o)}(a,t,n);break;case"ascii":case"binary":r=l(a,t,n);break;case"base64":o=a,u=n,r=0===(i=t)&&u===o.length?s.fromByteArray(o):s.fromByteArray(o.slice(i,u));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":r=function(e,t,n){for(var r=e.slice(t,n),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}(a,t,n);break;default:throw new Error("Unknown encoding")}return r},g.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},g.prototype.copy=function(e,t,n,r){if(n=n||0,r||0===r||(r=this.length),t=t||0,r!==n&&0!==e.length&&0!==this.length){D(n<=r,"sourceEnd < sourceStart"),D(0<=t&&t<e.length,"targetStart out of bounds"),D(0<=n&&n<this.length,"sourceStart out of bounds"),D(0<=r&&r<=this.length,"sourceEnd out of bounds"),r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var o=r-n;if(o<100||!g._useTypedArrays)for(var i=0;i<o;i++)e[i+t]=this[i+n];else e._set(this.subarray(n,n+o),t);}},g.prototype.slice=function(e,t){var n=this.length;if(e=U(e,n,0),t=U(t,n,n),g._useTypedArrays)return g._augment(this.subarray(e,t));for(var r=t-e,o=new g(r,void 0,!0),i=0;i<r;i++)o[i]=this[i+e];return o},g.prototype.get=function(e){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(e)},g.prototype.set=function(e,t){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(e,t)},g.prototype.readUInt8=function(e,t){if(t||(D(null!=e,"missing offset"),D(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return this[e]},g.prototype.readUInt16LE=function(e,t){return c(this,e,!0,t)},g.prototype.readUInt16BE=function(e,t){return c(this,e,!1,t)},g.prototype.readUInt32LE=function(e,t){return d(this,e,!0,t)},g.prototype.readUInt32BE=function(e,t){return d(this,e,!1,t)},g.prototype.readInt8=function(e,t){if(t||(D(null!=e,"missing offset"),D(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return 128&this[e]?-1*(255-this[e]+1):this[e]},g.prototype.readInt16LE=function(e,t){return h(this,e,!0,t)},g.prototype.readInt16BE=function(e,t){return h(this,e,!1,t)},g.prototype.readInt32LE=function(e,t){return p(this,e,!0,t)},g.prototype.readInt32BE=function(e,t){return p(this,e,!1,t)},g.prototype.readFloatLE=function(e,t){return b(this,e,!0,t)},g.prototype.readFloatBE=function(e,t){return b(this,e,!1,t)},g.prototype.readDoubleLE=function(e,t){return m(this,e,!0,t)},g.prototype.readDoubleBE=function(e,t){return m(this,e,!1,t)},g.prototype.writeUInt8=function(e,t,n){n||(D(null!=e,"missing value"),D(null!=t,"missing offset"),D(t<this.length,"trying to write beyond buffer length"),N(e,255)),t>=this.length||(this[t]=e);},g.prototype.writeUInt16LE=function(e,t,n){v(this,e,t,!0,n);},g.prototype.writeUInt16BE=function(e,t,n){v(this,e,t,!1,n);},g.prototype.writeUInt32LE=function(e,t,n){_(this,e,t,!0,n);},g.prototype.writeUInt32BE=function(e,t,n){_(this,e,t,!1,n);},g.prototype.writeInt8=function(e,t,n){n||(D(null!=e,"missing value"),D(null!=t,"missing offset"),D(t<this.length,"Trying to write beyond buffer length"),Y(e,127,-128)),t>=this.length||(0<=e?this.writeUInt8(e,t,n):this.writeUInt8(255+e+1,t,n));},g.prototype.writeInt16LE=function(e,t,n){E(this,e,t,!0,n);},g.prototype.writeInt16BE=function(e,t,n){E(this,e,t,!1,n);},g.prototype.writeInt32LE=function(e,t,n){I(this,e,t,!0,n);},g.prototype.writeInt32BE=function(e,t,n){I(this,e,t,!1,n);},g.prototype.writeFloatLE=function(e,t,n){A(this,e,t,!0,n);},g.prototype.writeFloatBE=function(e,t,n){A(this,e,t,!1,n);},g.prototype.writeDoubleLE=function(e,t,n){B(this,e,t,!0,n);},g.prototype.writeDoubleBE=function(e,t,n){B(this,e,t,!1,n);},g.prototype.fill=function(e,t,n){if(e=e||0,t=t||0,n=n||this.length,"string"==typeof e&&(e=e.charCodeAt(0)),D("number"==typeof e&&!isNaN(e),"value is not a number"),D(t<=n,"end < start"),n!==t&&0!==this.length){D(0<=t&&t<this.length,"start out of bounds"),D(0<=n&&n<=this.length,"end out of bounds");for(var r=t;r<n;r++)this[r]=e;}},g.prototype.inspect=function(){for(var e=[],t=this.length,n=0;n<t;n++)if(e[n]=j(this[n]),n===H.INSPECT_MAX_BYTES){e[n+1]="...";break}return "<Buffer "+e.join(" ")+">"},g.prototype.toArrayBuffer=function(){if("undefined"==typeof Uint8Array)throw new Error("Buffer.toArrayBuffer not supported in this browser");if(g._useTypedArrays)return new g(this).buffer;for(var e=new Uint8Array(this.length),t=0,n=e.length;t<n;t+=1)e[t]=this[t];return e.buffer};var L=g.prototype;function U(e,t,n){return "number"!=typeof e?n:t<=(e=~~e)?t:0<=e||0<=(e+=t)?e:0}function x(e){return (e=~~Math.ceil(+e))<0?0:e}function S(e){return (Array.isArray||function(e){return "[object Array]"===Object.prototype.toString.call(e)})(e)}function j(e){return e<16?"0"+e.toString(16):e.toString(16)}function C(e){for(var t=[],n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<=127)t.push(e.charCodeAt(n));else {var o=n;55296<=r&&r<=57343&&n++;for(var i=encodeURIComponent(e.slice(o,n+1)).substr(1).split("%"),u=0;u<i.length;u++)t.push(parseInt(i[u],16));}}return t}function k(e){return s.toByteArray(e)}function T(e,t,n,r){for(var o=0;o<r&&!(o+n>=t.length||o>=e.length);o++)t[o+n]=e[o];return o}function M(e){try{return decodeURIComponent(e)}catch(e){return String.fromCharCode(65533)}}function N(e,t){D("number"==typeof e,"cannot write a non-number as a number"),D(0<=e,"specified a negative value for writing an unsigned value"),D(e<=t,"value is larger than maximum value for type"),D(Math.floor(e)===e,"value has a fractional component");}function Y(e,t,n){D("number"==typeof e,"cannot write a non-number as a number"),D(e<=t,"value larger than maximum allowed value"),D(n<=e,"value smaller than minimum allowed value"),D(Math.floor(e)===e,"value has a fractional component");}function F(e,t,n){D("number"==typeof e,"cannot write a non-number as a number"),D(e<=t,"value larger than maximum allowed value"),D(n<=e,"value smaller than minimum allowed value");}function D(e,t){if(!e)throw new Error(t||"Failed assertion")}g._augment=function(e){return e._isBuffer=!0,e._get=e.get,e._set=e.set,e.get=L.get,e.set=L.set,e.write=L.write,e.toString=L.toString,e.toLocaleString=L.toString,e.toJSON=L.toJSON,e.copy=L.copy,e.slice=L.slice,e.readUInt8=L.readUInt8,e.readUInt16LE=L.readUInt16LE,e.readUInt16BE=L.readUInt16BE,e.readUInt32LE=L.readUInt32LE,e.readUInt32BE=L.readUInt32BE,e.readInt8=L.readInt8,e.readInt16LE=L.readInt16LE,e.readInt16BE=L.readInt16BE,e.readInt32LE=L.readInt32LE,e.readInt32BE=L.readInt32BE,e.readFloatLE=L.readFloatLE,e.readFloatBE=L.readFloatBE,e.readDoubleLE=L.readDoubleLE,e.readDoubleBE=L.readDoubleBE,e.writeUInt8=L.writeUInt8,e.writeUInt16LE=L.writeUInt16LE,e.writeUInt16BE=L.writeUInt16BE,e.writeUInt32LE=L.writeUInt32LE,e.writeUInt32BE=L.writeUInt32BE,e.writeInt8=L.writeInt8,e.writeInt16LE=L.writeInt16LE,e.writeInt16BE=L.writeInt16BE,e.writeInt32LE=L.writeInt32LE,e.writeInt32BE=L.writeInt32BE,e.writeFloatLE=L.writeFloatLE,e.writeFloatBE=L.writeFloatBE,e.writeDoubleLE=L.writeDoubleLE,e.writeDoubleBE=L.writeDoubleBE,e.fill=L.fill,e.inspect=L.inspect,e.toArrayBuffer=L.toArrayBuffer,e};}).call(this,O("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},O("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer");},{"base64-js":2,buffer:3,ieee754:11,lYpoI2:10}],4:[function(c,d,e){(function(e,t,u,n,r,o,i,a,s){var u=c("buffer").Buffer,f=4,l=new u(f);l.fill(0);d.exports={hash:function(e,t,n,r){return u.isBuffer(e)||(e=new u(e)),function(e,t,n){for(var r=new u(t),o=n?r.writeInt32BE:r.writeInt32LE,i=0;i<e.length;i++)o.call(r,e[i],4*i,!0);return r}(t(function(e,t){var n;e.length%f!=0&&(n=e.length+(f-e.length%f),e=u.concat([e,l],n));for(var r=[],o=t?e.readInt32BE:e.readInt32LE,i=0;i<e.length;i+=f)r.push(o.call(e,i));return r}(e,r),8*e.length),n,r)}};}).call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{buffer:3,lYpoI2:10}],5:[function(w,e,b){(function(e,t,a,n,r,o,i,u,s){var a=w("buffer").Buffer,f=w("./sha"),l=w("./sha256"),c=w("./rng"),d={sha1:f,sha256:l,md5:w("./md5")},h=64,p=new a(h);function g(e,r){var o=d[e=e||"sha1"],i=[];return o||y("algorithm:",e,"is not yet supported"),{update:function(e){return a.isBuffer(e)||(e=new a(e)),i.push(e),e.length,this},digest:function(e){var t=a.concat(i),n=r?function(e,t,n){a.isBuffer(t)||(t=new a(t)),a.isBuffer(n)||(n=new a(n)),t.length>h?t=e(t):t.length<h&&(t=a.concat([t,p],h));for(var r=new a(h),o=new a(h),i=0;i<h;i++)r[i]=54^t[i],o[i]=92^t[i];var u=e(a.concat([r,n]));return e(a.concat([o,u]))}(o,r,t):o(t);return i=null,e?n.toString(e):n}}}function y(){var e=[].slice.call(arguments).join(" ");throw new Error([e,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}p.fill(0),b.createHash=function(e){return g(e)},b.createHmac=g,b.randomBytes=function(e,t){if(!t||!t.call)return new a(c(e));try{t.call(this,void 0,new a(c(e)));}catch(e){t(e);}},function(e,t){for(var n in e)t(e[n],n);}(["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],function(e){b[e]=function(){y("sorry,",e,"is not implemented yet");};});}).call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:10}],6:[function(w,b,e){(function(e,t,n,r,o,i,u,a,s){var f=w("./helpers");function l(e,t){e[t>>5]|=128<<t%32,e[14+(t+64>>>9<<4)]=t;for(var n=1732584193,r=-271733879,o=-1732584194,i=271733878,u=0;u<e.length;u+=16){var a=n,s=r,f=o,l=i,n=d(n,r,o,i,e[u+0],7,-680876936),i=d(i,n,r,o,e[u+1],12,-389564586),o=d(o,i,n,r,e[u+2],17,606105819),r=d(r,o,i,n,e[u+3],22,-1044525330);n=d(n,r,o,i,e[u+4],7,-176418897),i=d(i,n,r,o,e[u+5],12,1200080426),o=d(o,i,n,r,e[u+6],17,-1473231341),r=d(r,o,i,n,e[u+7],22,-45705983),n=d(n,r,o,i,e[u+8],7,1770035416),i=d(i,n,r,o,e[u+9],12,-1958414417),o=d(o,i,n,r,e[u+10],17,-42063),r=d(r,o,i,n,e[u+11],22,-1990404162),n=d(n,r,o,i,e[u+12],7,1804603682),i=d(i,n,r,o,e[u+13],12,-40341101),o=d(o,i,n,r,e[u+14],17,-1502002290),n=h(n,r=d(r,o,i,n,e[u+15],22,1236535329),o,i,e[u+1],5,-165796510),i=h(i,n,r,o,e[u+6],9,-1069501632),o=h(o,i,n,r,e[u+11],14,643717713),r=h(r,o,i,n,e[u+0],20,-373897302),n=h(n,r,o,i,e[u+5],5,-701558691),i=h(i,n,r,o,e[u+10],9,38016083),o=h(o,i,n,r,e[u+15],14,-660478335),r=h(r,o,i,n,e[u+4],20,-405537848),n=h(n,r,o,i,e[u+9],5,568446438),i=h(i,n,r,o,e[u+14],9,-1019803690),o=h(o,i,n,r,e[u+3],14,-187363961),r=h(r,o,i,n,e[u+8],20,1163531501),n=h(n,r,o,i,e[u+13],5,-1444681467),i=h(i,n,r,o,e[u+2],9,-51403784),o=h(o,i,n,r,e[u+7],14,1735328473),n=p(n,r=h(r,o,i,n,e[u+12],20,-1926607734),o,i,e[u+5],4,-378558),i=p(i,n,r,o,e[u+8],11,-2022574463),o=p(o,i,n,r,e[u+11],16,1839030562),r=p(r,o,i,n,e[u+14],23,-35309556),n=p(n,r,o,i,e[u+1],4,-1530992060),i=p(i,n,r,o,e[u+4],11,1272893353),o=p(o,i,n,r,e[u+7],16,-155497632),r=p(r,o,i,n,e[u+10],23,-1094730640),n=p(n,r,o,i,e[u+13],4,681279174),i=p(i,n,r,o,e[u+0],11,-358537222),o=p(o,i,n,r,e[u+3],16,-722521979),r=p(r,o,i,n,e[u+6],23,76029189),n=p(n,r,o,i,e[u+9],4,-640364487),i=p(i,n,r,o,e[u+12],11,-421815835),o=p(o,i,n,r,e[u+15],16,530742520),n=g(n,r=p(r,o,i,n,e[u+2],23,-995338651),o,i,e[u+0],6,-198630844),i=g(i,n,r,o,e[u+7],10,1126891415),o=g(o,i,n,r,e[u+14],15,-1416354905),r=g(r,o,i,n,e[u+5],21,-57434055),n=g(n,r,o,i,e[u+12],6,1700485571),i=g(i,n,r,o,e[u+3],10,-1894986606),o=g(o,i,n,r,e[u+10],15,-1051523),r=g(r,o,i,n,e[u+1],21,-2054922799),n=g(n,r,o,i,e[u+8],6,1873313359),i=g(i,n,r,o,e[u+15],10,-30611744),o=g(o,i,n,r,e[u+6],15,-1560198380),r=g(r,o,i,n,e[u+13],21,1309151649),n=g(n,r,o,i,e[u+4],6,-145523070),i=g(i,n,r,o,e[u+11],10,-1120210379),o=g(o,i,n,r,e[u+2],15,718787259),r=g(r,o,i,n,e[u+9],21,-343485551),n=y(n,a),r=y(r,s),o=y(o,f),i=y(i,l);}return Array(n,r,o,i)}function c(e,t,n,r,o,i){return y((u=y(y(t,e),y(r,i)))<<(a=o)|u>>>32-a,n);var u,a;}function d(e,t,n,r,o,i,u){return c(t&n|~t&r,e,t,o,i,u)}function h(e,t,n,r,o,i,u){return c(t&r|n&~r,e,t,o,i,u)}function p(e,t,n,r,o,i,u){return c(t^n^r,e,t,o,i,u)}function g(e,t,n,r,o,i,u){return c(n^(t|~r),e,t,o,i,u)}function y(e,t){var n=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(n>>16)<<16|65535&n}b.exports=function(e){return f.hash(e,l,16)};}).call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./helpers":4,buffer:3,lYpoI2:10}],7:[function(e,c,t){(function(e,t,n,r,o,i,u,a,s){var l;l=function(e){for(var t,n=new Array(e),r=0;r<e;r++)0==(3&r)&&(t=4294967296*Math.random()),n[r]=t>>>((3&r)<<3)&255;return n},c.exports=l;}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{buffer:3,lYpoI2:10}],8:[function(c,d,e){(function(e,t,n,r,o,i,u,a,s){var f=c("./helpers");function l(e,t){e[t>>5]|=128<<24-t%32,e[15+(t+64>>9<<4)]=t;for(var n,r,o,i,u,a=Array(80),s=1732584193,f=-271733879,l=-1732584194,c=271733878,d=-1009589776,h=0;h<e.length;h+=16){for(var p=s,g=f,y=l,w=c,b=d,m=0;m<80;m++){a[m]=m<16?e[h+m]:E(a[m-3]^a[m-8]^a[m-14]^a[m-16],1);var v=_(_(E(s,5),(o=f,i=l,u=c,(r=m)<20?o&i|~o&u:!(r<40)&&r<60?o&i|o&u|i&u:o^i^u)),_(_(d,a[m]),(n=m)<20?1518500249:n<40?1859775393:n<60?-1894007588:-899497514)),d=c,c=l,l=E(f,30),f=s,s=v;}s=_(s,p),f=_(f,g),l=_(l,y),c=_(c,w),d=_(d,b);}return Array(s,f,l,c,d)}function _(e,t){var n=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(n>>16)<<16|65535&n}function E(e,t){return e<<t|e>>>32-t}d.exports=function(e){return f.hash(e,l,20,!0)};}).call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./helpers":4,buffer:3,lYpoI2:10}],9:[function(c,d,e){(function(e,t,n,r,o,i,u,a,s){function B(e,t){var n=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(n>>16)<<16|65535&n}function L(e,t){return e>>>t|e<<32-t}function f(e,t){var n,r,o,i,u,a,s,f,l,c,d=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),h=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),p=new Array(64);e[t>>5]|=128<<24-t%32,e[15+(t+64>>9<<4)]=t;for(var g,y,w,b,m,v,_,E,I=0;I<e.length;I+=16){n=h[0],r=h[1],o=h[2],i=h[3],u=h[4],a=h[5],s=h[6],f=h[7];for(var A=0;A<64;A++)p[A]=A<16?e[A+I]:B(B(B((E=p[A-2],L(E,17)^L(E,19)^E>>>10),p[A-7]),(_=p[A-15],L(_,7)^L(_,18)^_>>>3)),p[A-16]),l=B(B(B(B(f,L(v=u,6)^L(v,11)^L(v,25)),(m=u)&a^~m&s),d[A]),p[A]),c=B(L(b=n,2)^L(b,13)^L(b,22),(g=n)&(y=r)^g&(w=o)^y&w),f=s,s=a,a=u,u=B(i,l),i=o,o=r,r=n,n=B(l,c);h[0]=B(n,h[0]),h[1]=B(r,h[1]),h[2]=B(o,h[2]),h[3]=B(i,h[3]),h[4]=B(u,h[4]),h[5]=B(a,h[5]),h[6]=B(s,h[6]),h[7]=B(f,h[7]);}return h}var l=c("./helpers");d.exports=function(e){return l.hash(e,f,32,!0)};}).call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./helpers":4,buffer:3,lYpoI2:10}],10:[function(e,l,t){(function(e,t,n,r,o,i,u,a,s){function f(){}(e=l.exports={}).nextTick=function(){var e="undefined"!=typeof window&&window.setImmediate,t="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(e)return function(e){return window.setImmediate(e)};if(t){var n=[];return window.addEventListener("message",function(e){var t=e.source;t!==window&&null!==t||"process-tick"!==e.data||(e.stopPropagation(),0<n.length&&n.shift()());},!0),function(e){n.push(e),window.postMessage("process-tick","*");}}return function(e){setTimeout(e,0);}}(),e.title="browser",e.browser=!0,e.env={},e.argv=[],e.on=f,e.addListener=f,e.once=f,e.off=f,e.removeListener=f,e.removeAllListeners=f,e.emit=f,e.binding=function(e){throw new Error("process.binding is not supported")},e.cwd=function(){return "/"},e.chdir=function(e){throw new Error("process.chdir is not supported")};}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process");},{buffer:3,lYpoI2:10}],11:[function(e,t,f){(function(e,t,n,r,o,i,u,a,s){f.read=function(e,t,n,r,o){var i,u,a=8*o-r-1,s=(1<<a)-1,f=s>>1,l=-7,c=n?o-1:0,d=n?-1:1,h=e[t+c];for(c+=d,i=h&(1<<-l)-1,h>>=-l,l+=a;0<l;i=256*i+e[t+c],c+=d,l-=8);for(u=i&(1<<-l)-1,i>>=-l,l+=r;0<l;u=256*u+e[t+c],c+=d,l-=8);if(0===i)i=1-f;else {if(i===s)return u?NaN:1/0*(h?-1:1);u+=Math.pow(2,r),i-=f;}return (h?-1:1)*u*Math.pow(2,i-r)},f.write=function(e,t,n,r,o,i){var u,a,s,f=8*i-o-1,l=(1<<f)-1,c=l>>1,d=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:i-1,p=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,u=l):(u=Math.floor(Math.log(t)/Math.LN2),t*(s=Math.pow(2,-u))<1&&(u--,s*=2),2<=(t+=1<=u+c?d/s:d*Math.pow(2,1-c))*s&&(u++,s/=2),l<=u+c?(a=0,u=l):1<=u+c?(a=(t*s-1)*Math.pow(2,o),u+=c):(a=t*Math.pow(2,c-1)*Math.pow(2,o),u=0));8<=o;e[n+h]=255&a,h+=p,a/=256,o-=8);for(u=u<<o|a,f+=o;0<f;e[n+h]=255&u,h+=p,u/=256,f-=8);e[n+h-p]|=128*g;};}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/ieee754/index.js","/node_modules/ieee754");},{buffer:3,lYpoI2:10}]},{},[1])(1)});
    });

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init$2 () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init$2();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init$2();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray$1 = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray$1(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray$1(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        _extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray$2(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray$2(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject$1(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject$1(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject$1(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject$1(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject$1(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    /* src\Database\DatabaseDocuments.svelte generated by Svelte v3.32.1 */

    const { Error: Error_1$2, console: console_1$1 } = globals;

    function create_fragment$w(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DatabaseDocuments", slots, []);
    	let { docsPromise = null } = $$props;
    	let { docs = null } = $$props;
    	let { db = null } = $$props;
    	let localDocsHash = "";

    	function setDocsPromise() {
    		$$invalidate(0, docsPromise = fetchDocs());
    	}

    	function generateLocalDocsHash() {
    		$$invalidate(3, localDocsHash = object_hash(docs));
    	}

    	async function fetchDocs() {
    		if (!db) throw new Error("database must be up");
    		const documents = await db.allDocs({ include_docs: true, update_seq: true });

    		// For testing purpose
    		// await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
    		// const rnd = Math.random();
    		// if (rnd < 1/3)
    		//     throw new Error('not working');
    		// if (rnd < 2/3)
    		//     return [];
    		return documents.rows.map(row => row.doc);
    	}

    	const writable_props = ["docsPromise", "docs", "db"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<DatabaseDocuments> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("docsPromise" in $$props) $$invalidate(0, docsPromise = $$props.docsPromise);
    		if ("docs" in $$props) $$invalidate(1, docs = $$props.docs);
    		if ("db" in $$props) $$invalidate(2, db = $$props.db);
    	};

    	$$self.$capture_state = () => ({
    		PouchDB,
    		hash: object_hash,
    		inspect,
    		docsPromise,
    		docs,
    		db,
    		localDocsHash,
    		setDocsPromise,
    		generateLocalDocsHash,
    		fetchDocs
    	});

    	$$self.$inject_state = $$props => {
    		if ("docsPromise" in $$props) $$invalidate(0, docsPromise = $$props.docsPromise);
    		if ("docs" in $$props) $$invalidate(1, docs = $$props.docs);
    		if ("db" in $$props) $$invalidate(2, db = $$props.db);
    		if ("localDocsHash" in $$props) $$invalidate(3, localDocsHash = $$props.localDocsHash);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*db*/ 4) {
    			 if (db !== null) {
    				// if database is ready
    				setDocsPromise();
    			}
    		}

    		if ($$self.$$.dirty & /*docsPromise*/ 1) {
    			 if (docsPromise !== null) {
    				(async () => {
    					$$invalidate(1, docs = await docsPromise);
    					generateLocalDocsHash();
    				})();
    			}
    		}

    		if ($$self.$$.dirty & /*docs, localDocsHash, db*/ 14) {
    			 if (docs !== null) {
    				if (object_hash(docs) !== localDocsHash) {
    					db.bulkDocs(docs);
    					setDocsPromise();
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*db*/ 4) {
    			 console.debug("db", db);
    		}

    		if ($$self.$$.dirty & /*docsPromise*/ 1) {
    			 console.debug("docsPromise", docsPromise);
    		}

    		if ($$self.$$.dirty & /*docs*/ 2) {
    			 console.debug("docs", docs);
    		}
    	};

    	return [docsPromise, docs, db, localDocsHash];
    }

    class DatabaseDocuments extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { docsPromise: 0, docs: 1, db: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatabaseDocuments",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get docsPromise() {
    		throw new Error_1$2("<DatabaseDocuments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set docsPromise(value) {
    		throw new Error_1$2("<DatabaseDocuments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get docs() {
    		throw new Error_1$2("<DatabaseDocuments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set docs(value) {
    		throw new Error_1$2("<DatabaseDocuments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get db() {
    		throw new Error_1$2("<DatabaseDocuments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set db(value) {
    		throw new Error_1$2("<DatabaseDocuments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\UI\Book.svelte generated by Svelte v3.32.1 */

    const { console: console_1$2 } = globals;

    const file$t = "src\\UI\\Book.svelte";

    // (40:0) {:else}
    function create_else_block_1$1(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				class: "mb-3",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, book*/ 17) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(40:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:0) {#if context === "detail"}
    function create_if_block$b(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				class: "justify-content-center",
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, handleAddToCart, book*/ 21) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(19:0) {#if context === \\\"detail\\\"}",
    		ctx
    	});

    	return block;
    }

    // (45:16) <CardTitle class="h6 mt-2">
    function create_default_slot_9(ctx) {
    	let t_value = /*book*/ ctx[0].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*book*/ 1 && t_value !== (t_value = /*book*/ ctx[0].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(45:16) <CardTitle class=\\\"h6 mt-2\\\">",
    		ctx
    	});

    	return block;
    }

    // (46:16) <CardSubtitle class="text-muted">
    function create_default_slot_8(ctx) {
    	let t0;
    	let t1_value = /*book*/ ctx[0].author + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("by ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*book*/ 1 && t1_value !== (t1_value = /*book*/ ctx[0].author + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(46:16) <CardSubtitle class=\\\"text-muted\\\">",
    		ctx
    	});

    	return block;
    }

    // (43:12) <CardHeader>
    function create_default_slot_7(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_title_value;
    	let t0;
    	let cardtitle;
    	let t1;
    	let cardsubtitle;
    	let current;

    	cardtitle = new CardTitle({
    			props: {
    				class: "h6 mt-2",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cardsubtitle = new CardSubtitle({
    			props: {
    				class: "text-muted",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			img = element("img");
    			t0 = space();
    			create_component(cardtitle.$$.fragment);
    			t1 = space();
    			create_component(cardsubtitle.$$.fragment);
    			attr_dev(img, "class", "w-100");
    			if (img.src !== (img_src_value = "data:image/jpeg;base64, " + /*book*/ ctx[0].img.data)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*book*/ ctx[0].title);
    			attr_dev(img, "title", img_title_value = /*book*/ ctx[0].title);
    			attr_dev(img, "onerror", "this.src='image/not-found.png'");
    			add_location(img, file$t, 43, 16, 1317);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(cardtitle, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cardsubtitle, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*book*/ 1 && img.src !== (img_src_value = "data:image/jpeg;base64, " + /*book*/ ctx[0].img.data)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*book*/ 1 && img_alt_value !== (img_alt_value = /*book*/ ctx[0].title)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (!current || dirty & /*book*/ 1 && img_title_value !== (img_title_value = /*book*/ ctx[0].title)) {
    				attr_dev(img, "title", img_title_value);
    			}

    			const cardtitle_changes = {};

    			if (dirty & /*$$scope, book*/ 17) {
    				cardtitle_changes.$$scope = { dirty, ctx };
    			}

    			cardtitle.$set(cardtitle_changes);
    			const cardsubtitle_changes = {};

    			if (dirty & /*$$scope, book*/ 17) {
    				cardsubtitle_changes.$$scope = { dirty, ctx };
    			}

    			cardsubtitle.$set(cardsubtitle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardtitle.$$.fragment, local);
    			transition_in(cardsubtitle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardtitle.$$.fragment, local);
    			transition_out(cardsubtitle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t0);
    			destroy_component(cardtitle, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(cardsubtitle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(43:12) <CardHeader>",
    		ctx
    	});

    	return block;
    }

    // (50:12) <CardText class="h6">
    function create_default_slot_6(ctx) {
    	let sup;
    	let t1_value = /*book*/ ctx[0].price + "";
    	let t1;

    	const block = {
    		c: function create() {
    			sup = element("sup");
    			sup.textContent = "$";
    			t1 = text(t1_value);
    			attr_dev(sup, "class", "mr-1");
    			add_location(sup, file$t, 50, 16, 1723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, sup, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*book*/ 1 && t1_value !== (t1_value = /*book*/ ctx[0].price + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(sup);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(50:12) <CardText class=\\\"h6\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:8) <CardBody>
    function create_default_slot_5(ctx) {
    	let cardtext;
    	let current;

    	cardtext = new CardText({
    			props: {
    				class: "h6",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardtext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardtext, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardtext_changes = {};

    			if (dirty & /*$$scope, book*/ 17) {
    				cardtext_changes.$$scope = { dirty, ctx };
    			}

    			cardtext.$set(cardtext_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardtext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardtext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardtext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(49:8) <CardBody>",
    		ctx
    	});

    	return block;
    }

    // (41:4) <Card class="mb-3">
    function create_default_slot_4(ctx) {
    	let a;
    	let cardheader;
    	let a_href_value;
    	let t;
    	let cardbody;
    	let current;

    	cardheader = new CardHeader({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cardbody = new CardBody({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(cardheader.$$.fragment);
    			t = space();
    			create_component(cardbody.$$.fragment);
    			attr_dev(a, "href", a_href_value = "/#/detail/" + /*book*/ ctx[0]._id);
    			add_location(a, file$t, 41, 8, 1244);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(cardheader, a, null);
    			insert_dev(target, t, anchor);
    			mount_component(cardbody, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardheader_changes = {};

    			if (dirty & /*$$scope, book*/ 17) {
    				cardheader_changes.$$scope = { dirty, ctx };
    			}

    			cardheader.$set(cardheader_changes);

    			if (!current || dirty & /*book*/ 1 && a_href_value !== (a_href_value = "/#/detail/" + /*book*/ ctx[0]._id)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			const cardbody_changes = {};

    			if (dirty & /*$$scope, book*/ 17) {
    				cardbody_changes.$$scope = { dirty, ctx };
    			}

    			cardbody.$set(cardbody_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardheader.$$.fragment, local);
    			transition_in(cardbody.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardheader.$$.fragment, local);
    			transition_out(cardbody.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(cardheader);
    			if (detaching) detach_dev(t);
    			destroy_component(cardbody, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(41:4) <Card class=\\\"mb-3\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:8) <Col xs="12" sm="6" lg="4" class="pb-4 pb-sm-0">
    function create_default_slot_3(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_title_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "w-100");
    			if (img.src !== (img_src_value = "data:image/jpeg;base64, " + /*book*/ ctx[0].img.data)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*book*/ ctx[0].title);
    			attr_dev(img, "title", img_title_value = /*book*/ ctx[0].title);
    			attr_dev(img, "onerror", "this.onerror=null; this.src='image/not-found.png'");
    			add_location(img, file$t, 21, 12, 515);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*book*/ 1 && img.src !== (img_src_value = "data:image/jpeg;base64, " + /*book*/ ctx[0].img.data)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*book*/ 1 && img_alt_value !== (img_alt_value = /*book*/ ctx[0].title)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*book*/ 1 && img_title_value !== (img_title_value = /*book*/ ctx[0].title)) {
    				attr_dev(img, "title", img_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(21:8) <Col xs=\\\"12\\\" sm=\\\"6\\\" lg=\\\"4\\\" class=\\\"pb-4 pb-sm-0\\\">",
    		ctx
    	});

    	return block;
    }

    // (33:12) {:else}
    function create_else_block$a(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No description available.";
    			attr_dev(p, "class", "font-italic");
    			add_location(p, file$t, 33, 16, 1010);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(33:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (31:12) {#if book.description}
    function create_if_block_1$5(ctx) {
    	let p;
    	let t_value = /*book*/ ctx[0].description + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$t, 31, 16, 948);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*book*/ 1 && t_value !== (t_value = /*book*/ ctx[0].description + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(31:12) {#if book.description}",
    		ctx
    	});

    	return block;
    }

    // (37:12) <Button color="primary" on:click={() => handleAddToCart(book)}>
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Add to cart");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(37:12) <Button color=\\\"primary\\\" on:click={() => handleAddToCart(book)}>",
    		ctx
    	});

    	return block;
    }

    // (25:8) <Col xs="12" sm="6" lg="4">
    function create_default_slot_1(ctx) {
    	let h1;
    	let t0_value = /*book*/ ctx[0].title + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2;
    	let t3_value = /*book*/ ctx[0].author + "";
    	let t3;
    	let t4;
    	let p1;
    	let sup;
    	let t6_value = /*book*/ ctx[0].price + "";
    	let t6;
    	let t7;
    	let t8;
    	let button;
    	let current;

    	function select_block_type_1(ctx, dirty) {
    		if (/*book*/ ctx[0].description) return create_if_block_1$5;
    		return create_else_block$a;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	button = new Button({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[3]);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text("by ");
    			t3 = text(t3_value);
    			t4 = space();
    			p1 = element("p");
    			sup = element("sup");
    			sup.textContent = "$";
    			t6 = text(t6_value);
    			t7 = space();
    			if_block.c();
    			t8 = space();
    			create_component(button.$$.fragment);
    			add_location(h1, file$t, 25, 12, 747);
    			attr_dev(p0, "class", "h3 text-muted");
    			add_location(p0, file$t, 26, 12, 781);
    			attr_dev(sup, "class", "mr-1");
    			add_location(sup, file$t, 28, 26, 854);
    			attr_dev(p1, "class", "h5");
    			add_location(p1, file$t, 28, 12, 840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t2);
    			append_dev(p0, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, sup);
    			append_dev(p1, t6);
    			insert_dev(target, t7, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*book*/ 1) && t0_value !== (t0_value = /*book*/ ctx[0].title + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*book*/ 1) && t3_value !== (t3_value = /*book*/ ctx[0].author + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*book*/ 1) && t6_value !== (t6_value = /*book*/ ctx[0].price + "")) set_data_dev(t6, t6_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t8.parentNode, t8);
    				}
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t7);
    			if_block.d(detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(25:8) <Col xs=\\\"12\\\" sm=\\\"6\\\" lg=\\\"4\\\">",
    		ctx
    	});

    	return block;
    }

    // (20:4) <Row class="justify-content-center">
    function create_default_slot$3(ctx) {
    	let col0;
    	let t;
    	let col1;
    	let current;

    	col0 = new Col({
    			props: {
    				xs: "12",
    				sm: "6",
    				lg: "4",
    				class: "pb-4 pb-sm-0",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col1 = new Col({
    			props: {
    				xs: "12",
    				sm: "6",
    				lg: "4",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col0.$$.fragment);
    			t = space();
    			create_component(col1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(col1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col0_changes = {};

    			if (dirty & /*$$scope, book*/ 17) {
    				col0_changes.$$scope = { dirty, ctx };
    			}

    			col0.$set(col0_changes);
    			const col1_changes = {};

    			if (dirty & /*$$scope, handleAddToCart, book*/ 21) {
    				col1_changes.$$scope = { dirty, ctx };
    			}

    			col1.$set(col1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col0.$$.fragment, local);
    			transition_in(col1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col0.$$.fragment, local);
    			transition_out(col1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(col1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(20:4) <Row class=\\\"justify-content-center\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$b, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*context*/ ctx[1] === "detail") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Book", slots, []);
    	let { book } = $$props;
    	let { context = "list" } = $$props;

    	let { handleAddToCart = () => {
    		console.error("unexpected call of handleAddToCart for book", book);
    	} } = $$props;

    	const writable_props = ["book", "context", "handleAddToCart"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Book> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => handleAddToCart(book);

    	$$self.$$set = $$props => {
    		if ("book" in $$props) $$invalidate(0, book = $$props.book);
    		if ("context" in $$props) $$invalidate(1, context = $$props.context);
    		if ("handleAddToCart" in $$props) $$invalidate(2, handleAddToCart = $$props.handleAddToCart);
    	};

    	$$self.$capture_state = () => ({
    		Row,
    		Col,
    		Card,
    		CardBody,
    		CardHeader,
    		CardSubtitle,
    		CardText,
    		CardTitle,
    		Button,
    		book,
    		context,
    		handleAddToCart
    	});

    	$$self.$inject_state = $$props => {
    		if ("book" in $$props) $$invalidate(0, book = $$props.book);
    		if ("context" in $$props) $$invalidate(1, context = $$props.context);
    		if ("handleAddToCart" in $$props) $$invalidate(2, handleAddToCart = $$props.handleAddToCart);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [book, context, handleAddToCart, click_handler];
    }

    class Book extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, { book: 0, context: 1, handleAddToCart: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Book",
    			options,
    			id: create_fragment$x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*book*/ ctx[0] === undefined && !("book" in props)) {
    			console_1$2.warn("<Book> was created without expected prop 'book'");
    		}
    	}

    	get book() {
    		throw new Error("<Book>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set book(value) {
    		throw new Error("<Book>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get context() {
    		throw new Error("<Book>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set context(value) {
    		throw new Error("<Book>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleAddToCart() {
    		throw new Error("<Book>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set handleAddToCart(value) {
    		throw new Error("<Book>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Util\Dump.svelte generated by Svelte v3.32.1 */

    const { console: console_1$3 } = globals;
    const file$u = "src\\Util\\Dump.svelte";

    function create_fragment$y(ctx) {
    	let pre;
    	let code;
    	let t_value = inspect(/*value*/ ctx[0], /*$$props*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			pre = element("pre");
    			code = element("code");
    			t = text(t_value);
    			add_location(code, file$u, 10, 5, 181);
    			add_location(pre, file$u, 10, 0, 176);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, pre, anchor);
    			append_dev(pre, code);
    			append_dev(code, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*value, $$props*/ 3 && t_value !== (t_value = inspect(/*value*/ ctx[0], /*$$props*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(pre);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Dump", slots, []);
    	let { value } = $$props;
    	let { error = false } = $$props;
    	if (error) console.error(value); else console.log(value);

    	$$self.$$set = $$new_props => {
    		$$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ("error" in $$new_props) $$invalidate(2, error = $$new_props.error);
    	};

    	$$self.$capture_state = () => ({ inspect, value, error });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
    		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    		if ("error" in $$props) $$invalidate(2, error = $$new_props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [value, $$props, error];
    }

    class Dump extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { value: 0, error: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dump",
    			options,
    			id: create_fragment$y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console_1$3.warn("<Dump> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<Dump>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Dump>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<Dump>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<Dump>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\UI\Alert.svelte generated by Svelte v3.32.1 */
    const file$v = "src\\UI\\Alert.svelte";

    // (24:4) {#if type === "error"}
    function create_if_block$c(ctx) {
    	let p;
    	let t1;
    	let dump;
    	let current;

    	dump = new Dump({
    			props: { value: /*error*/ ctx[1], error: "true" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Please contact an administrator and provide them the following message:";
    			t1 = space();
    			create_component(dump.$$.fragment);
    			add_location(p, file$v, 24, 8, 453);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dump, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dump_changes = {};
    			if (dirty & /*error*/ 2) dump_changes.value = /*error*/ ctx[1];
    			dump.$set(dump_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dump.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dump.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			destroy_component(dump, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(24:4) {#if type === \\\"error\\\"}",
    		ctx
    	});

    	return block;
    }

    // (20:0) <Alert color={color}>
    function create_default_slot$4(ctx) {
    	let p;
    	let t0;
    	let t1;
    	let t2;
    	let if_block_anchor;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let if_block = /*type*/ ctx[2] === "error" && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(p, "class", "h5 alert-heading text-capitalize");
    			add_location(p, file$v, 20, 4, 343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			insert_dev(target, t1, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			if (/*type*/ ctx[2] === "error") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*type*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(20:0) <Alert color={color}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let alert;
    	let current;

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[3],
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const alert_changes = {};
    			if (dirty & /*color*/ 8) alert_changes.color = /*color*/ ctx[3];

    			if (dirty & /*$$scope, error, type, title*/ 39) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Alert", slots, ['default']);
    	let { title } = $$props;
    	let { error } = $$props;
    	let type;
    	let color;
    	const writable_props = ["title", "error"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Alert> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("error" in $$props) $$invalidate(1, error = $$props.error);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Alert, Dump, title, error, type, color });

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("error" in $$props) $$invalidate(1, error = $$props.error);
    		if ("type" in $$props) $$invalidate(2, type = $$props.type);
    		if ("color" in $$props) $$invalidate(3, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*error*/ 2) {
    			 if (error) {
    				$$invalidate(2, type = "error");
    				$$invalidate(3, color = "danger");
    			} else {
    				$$invalidate(2, type = "info");
    				$$invalidate(3, color = "info");
    			}
    		}
    	};

    	return [title, error, type, color, slots, $$scope];
    }

    class Alert_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { title: 0, error: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Alert_1",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
    			console.warn("<Alert> was created without expected prop 'title'");
    		}

    		if (/*error*/ ctx[1] === undefined && !("error" in props)) {
    			console.warn("<Alert> was created without expected prop 'error'");
    		}
    	}

    	get title() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get error() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Books.svelte generated by Svelte v3.32.1 */
    const file$w = "src\\Pages\\Books.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (77:12) <NavbarBrand href="/">
    function create_default_slot_11(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Book fugue");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(77:12) <NavbarBrand href=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:24) <Button color="success" href="/#/cart">
    function create_default_slot_10(ctx) {
    	let icon;
    	let current;
    	icon = new Icon({ props: { name: "cart" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(92:24) <Button color=\\\"success\\\" href=\\\"/#/cart\\\">",
    		ctx
    	});

    	return block;
    }

    // (91:20) <NavItem>
    function create_default_slot_9$1(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "success",
    				href: "/#/cart",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(91:20) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (81:16) <Nav class="ml-auto" navbar>
    function create_default_slot_8$1(ctx) {
    	let navitem;
    	let current;

    	navitem = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navitem_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navitem_changes.$$scope = { dirty, ctx };
    			}

    			navitem.$set(navitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(81:16) <Nav class=\\\"ml-auto\\\" navbar>",
    		ctx
    	});

    	return block;
    }

    // (80:12) <Collapse isOpen={isNavbarOpen} navbar expand="sm" on:update={handleNavbarUpdate}>
    function create_default_slot_7$1(ctx) {
    	let nav;
    	let current;

    	nav = new Nav({
    			props: {
    				class: "ml-auto",
    				navbar: true,
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(80:12) <Collapse isOpen={isNavbarOpen} navbar expand=\\\"sm\\\" on:update={handleNavbarUpdate}>",
    		ctx
    	});

    	return block;
    }

    // (76:8) <Container>
    function create_default_slot_6$1(ctx) {
    	let navbarbrand;
    	let t0;
    	let navbartoggler;
    	let t1;
    	let collapse;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "/",
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navbartoggler = new NavbarToggler({ $$inline: true });
    	navbartoggler.$on("click", /*click_handler*/ ctx[8]);

    	collapse = new Collapse({
    			props: {
    				isOpen: /*isNavbarOpen*/ ctx[3],
    				navbar: true,
    				expand: "sm",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	collapse.$on("update", /*handleNavbarUpdate*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t0 = space();
    			create_component(navbartoggler.$$.fragment);
    			t1 = space();
    			create_component(collapse.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(navbartoggler, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(collapse, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const collapse_changes = {};
    			if (dirty & /*isNavbarOpen*/ 8) collapse_changes.isOpen = /*isNavbarOpen*/ ctx[3];

    			if (dirty & /*$$scope*/ 8192) {
    				collapse_changes.$$scope = { dirty, ctx };
    			}

    			collapse.$set(collapse_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(navbartoggler.$$.fragment, local);
    			transition_in(collapse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(navbartoggler.$$.fragment, local);
    			transition_out(collapse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(navbartoggler, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(collapse, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(76:8) <Container>",
    		ctx
    	});

    	return block;
    }

    // (75:4) <Navbar color="primary" dark expand="sm" style="position: sticky; top: 0; z-index: 10;">
    function create_default_slot_5$1(ctx) {
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const container_changes = {};

    			if (dirty & /*$$scope, isNavbarOpen*/ 8200) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(75:4) <Navbar color=\\\"primary\\\" dark expand=\\\"sm\\\" style=\\\"position: sticky; top: 0; z-index: 10;\\\">",
    		ctx
    	});

    	return block;
    }

    // (100:8) {#if booksPromise !== null}
    function create_if_block$d(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				class: "justify-content-center",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, booksPromise, books*/ 8198) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(100:8) {#if booksPromise !== null}",
    		ctx
    	});

    	return block;
    }

    // (114:16) {:catch error}
    function create_catch_block(ctx) {
    	let alert;
    	let current;

    	alert = new Alert_1({
    			props: {
    				title: "Unable to fetch books",
    				error: /*error*/ ctx[12],
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};
    			if (dirty & /*booksPromise*/ 2) alert_changes.error = /*error*/ ctx[12];

    			if (dirty & /*$$scope*/ 8192) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(114:16) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (115:20) <Alert title="Unable to fetch books" {error}>
    function create_default_slot_4$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "The connection to the database failed, retry in a few minutes.";
    			add_location(p, file$w, 115, 24, 3648);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(115:20) <Alert title=\\\"Unable to fetch books\\\" {error}>",
    		ctx
    	});

    	return block;
    }

    // (104:16) {:then}
    function create_then_block(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*books*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block$b(ctx);
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			if (each_1_else) {
    				each_1_else.c();
    			}
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*books*/ 4) {
    				each_value = /*books*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (!each_value.length && each_1_else) {
    					each_1_else.p(ctx, dirty);
    				} else if (!each_value.length) {
    					each_1_else = create_else_block$b(ctx);
    					each_1_else.c();
    					transition_in(each_1_else, 1);
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				} else if (each_1_else) {
    					group_outros();

    					transition_out(each_1_else, 1, 1, () => {
    						each_1_else = null;
    					});

    					check_outros();
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(104:16) {:then}",
    		ctx
    	});

    	return block;
    }

    // (109:20) {:else}
    function create_else_block$b(ctx) {
    	let alert;
    	let current;

    	alert = new Alert_1({
    			props: {
    				title: "No books found",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(109:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (110:24) <Alert title="No books found">
    function create_default_slot_3$1(ctx) {
    	let p;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "There is currently no books in the database.";
    			t1 = space();
    			add_location(p, file$w, 110, 28, 3414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(110:24) <Alert title=\\\"No books found\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:24) <Col xs="6" sm="6" md="4" lg="3" xl="2" class="px-2">
    function create_default_slot_2$1(ctx) {
    	let book;
    	let t;
    	let current;

    	book = new Book({
    			props: { book: /*book*/ ctx[9] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(book.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(book, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const book_changes = {};
    			if (dirty & /*books*/ 4) book_changes.book = /*book*/ ctx[9];
    			book.$set(book_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(book.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(book.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(book, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(106:24) <Col xs=\\\"6\\\" sm=\\\"6\\\" md=\\\"4\\\" lg=\\\"3\\\" xl=\\\"2\\\" class=\\\"px-2\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) {#each books as book}
    function create_each_block(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "6",
    				sm: "6",
    				md: "4",
    				lg: "3",
    				xl: "2",
    				class: "px-2",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope, books*/ 8196) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(105:20) {#each books as book}",
    		ctx
    	});

    	return block;
    }

    // (102:37)                      <Spinner color="primary" />                 {:then}
    function create_pending_block(ctx) {
    	let spinner;
    	let current;

    	spinner = new Spinner({
    			props: { color: "primary" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spinner, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(102:37)                      <Spinner color=\\\"primary\\\" />                 {:then}",
    		ctx
    	});

    	return block;
    }

    // (101:12) <Row class="justify-content-center">
    function create_default_slot_1$1(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		error: 12,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*booksPromise*/ ctx[1], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*booksPromise*/ 2 && promise !== (promise = /*booksPromise*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[12] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(101:12) <Row class=\\\"justify-content-center\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:4) <Container class="py-3">
    function create_default_slot$5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*booksPromise*/ ctx[1] !== null && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*booksPromise*/ ctx[1] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*booksPromise*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(99:4) <Container class=\\\"py-3\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let link0;
    	let link1;
    	let style;
    	let t1;
    	let db;
    	let updating_db;
    	let t2;
    	let dbdocs;
    	let updating_docsPromise;
    	let updating_docs;
    	let t3;
    	let main;
    	let navbar;
    	let t4;
    	let container;
    	let current;

    	function db_db_binding(value) {
    		/*db_db_binding*/ ctx[5].call(null, value);
    	}

    	let db_props = {
    		name: "books",
    		initDocsSrc: "./books.json"
    	};

    	if (/*booksDb*/ ctx[0] !== void 0) {
    		db_props.db = /*booksDb*/ ctx[0];
    	}

    	db = new Database({ props: db_props, $$inline: true });
    	binding_callbacks.push(() => bind(db, "db", db_db_binding));

    	function dbdocs_docsPromise_binding(value) {
    		/*dbdocs_docsPromise_binding*/ ctx[6].call(null, value);
    	}

    	function dbdocs_docs_binding(value) {
    		/*dbdocs_docs_binding*/ ctx[7].call(null, value);
    	}

    	let dbdocs_props = { db: /*booksDb*/ ctx[0] };

    	if (/*booksPromise*/ ctx[1] !== void 0) {
    		dbdocs_props.docsPromise = /*booksPromise*/ ctx[1];
    	}

    	if (/*books*/ ctx[2] !== void 0) {
    		dbdocs_props.docs = /*books*/ ctx[2];
    	}

    	dbdocs = new DatabaseDocuments({ props: dbdocs_props, $$inline: true });
    	binding_callbacks.push(() => bind(dbdocs, "docsPromise", dbdocs_docsPromise_binding));
    	binding_callbacks.push(() => bind(dbdocs, "docs", dbdocs_docs_binding));

    	navbar = new Navbar({
    			props: {
    				color: "primary",
    				dark: true,
    				expand: "sm",
    				style: "position: sticky; top: 0; z-index: 10;",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	container = new Container({
    			props: {
    				class: "py-3",
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			link0 = element("link");
    			link1 = element("link");
    			style = element("style");
    			style.textContent = "body {\n            margin: 0;\n            padding: 0;\n        }";
    			t1 = space();
    			create_component(db.$$.fragment);
    			t2 = space();
    			create_component(dbdocs.$$.fragment);
    			t3 = space();
    			main = element("main");
    			create_component(navbar.$$.fragment);
    			t4 = space();
    			create_component(container.$$.fragment);
    			attr_dev(link0, "href", "https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css");
    			attr_dev(link0, "rel", "stylesheet");
    			add_location(link0, file$w, 1, 4, 18);
    			attr_dev(link1, "rel", "stylesheet");
    			attr_dev(link1, "href", "https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css");
    			add_location(link1, file$w, 2, 4, 126);
    			add_location(style, file$w, 4, 4, 235);
    			add_location(main, file$w, 73, 0, 1766);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link0);
    			append_dev(document.head, link1);
    			append_dev(document.head, style);
    			insert_dev(target, t1, anchor);
    			mount_component(db, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dbdocs, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t4);
    			mount_component(container, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const db_changes = {};

    			if (!updating_db && dirty & /*booksDb*/ 1) {
    				updating_db = true;
    				db_changes.db = /*booksDb*/ ctx[0];
    				add_flush_callback(() => updating_db = false);
    			}

    			db.$set(db_changes);
    			const dbdocs_changes = {};
    			if (dirty & /*booksDb*/ 1) dbdocs_changes.db = /*booksDb*/ ctx[0];

    			if (!updating_docsPromise && dirty & /*booksPromise*/ 2) {
    				updating_docsPromise = true;
    				dbdocs_changes.docsPromise = /*booksPromise*/ ctx[1];
    				add_flush_callback(() => updating_docsPromise = false);
    			}

    			if (!updating_docs && dirty & /*books*/ 4) {
    				updating_docs = true;
    				dbdocs_changes.docs = /*books*/ ctx[2];
    				add_flush_callback(() => updating_docs = false);
    			}

    			dbdocs.$set(dbdocs_changes);
    			const navbar_changes = {};

    			if (dirty & /*$$scope, isNavbarOpen*/ 8200) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const container_changes = {};

    			if (dirty & /*$$scope, booksPromise, books*/ 8198) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(db.$$.fragment, local);
    			transition_in(dbdocs.$$.fragment, local);
    			transition_in(navbar.$$.fragment, local);
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(db.$$.fragment, local);
    			transition_out(dbdocs.$$.fragment, local);
    			transition_out(navbar.$$.fragment, local);
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link0);
    			detach_dev(link1);
    			detach_dev(style);
    			if (detaching) detach_dev(t1);
    			destroy_component(db, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dbdocs, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Books", slots, []);
    	let booksDb = null;
    	let booksPromise = null;
    	let books = null;
    	let isNavbarOpen = false;

    	function handleNavbarUpdate(event) {
    		$$invalidate(3, isNavbarOpen = event.detail.isOpen);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Books> was created with unknown prop '${key}'`);
    	});

    	function db_db_binding(value) {
    		booksDb = value;
    		$$invalidate(0, booksDb);
    	}

    	function dbdocs_docsPromise_binding(value) {
    		booksPromise = value;
    		$$invalidate(1, booksPromise);
    	}

    	function dbdocs_docs_binding(value) {
    		books = value;
    		$$invalidate(2, books);
    	}

    	const click_handler = () => $$invalidate(3, isNavbarOpen = !isNavbarOpen);

    	$$self.$capture_state = () => ({
    		Collapse,
    		Navbar,
    		NavbarToggler,
    		NavbarBrand,
    		Nav,
    		NavItem,
    		Form,
    		Input,
    		Button,
    		UncontrolledDropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Container,
    		Row,
    		Col,
    		Spinner,
    		Icon,
    		Db: Database,
    		DbDocs: DatabaseDocuments,
    		Book,
    		Alert: Alert_1,
    		booksDb,
    		booksPromise,
    		books,
    		isNavbarOpen,
    		handleNavbarUpdate
    	});

    	$$self.$inject_state = $$props => {
    		if ("booksDb" in $$props) $$invalidate(0, booksDb = $$props.booksDb);
    		if ("booksPromise" in $$props) $$invalidate(1, booksPromise = $$props.booksPromise);
    		if ("books" in $$props) $$invalidate(2, books = $$props.books);
    		if ("isNavbarOpen" in $$props) $$invalidate(3, isNavbarOpen = $$props.isNavbarOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		booksDb,
    		booksPromise,
    		books,
    		isNavbarOpen,
    		handleNavbarUpdate,
    		db_db_binding,
    		dbdocs_docsPromise_binding,
    		dbdocs_docs_binding,
    		click_handler
    	];
    }

    class Books extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Books",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    function type() {
      return 'Browser';
    }

    /* src\Database\DatabaseDocument.svelte generated by Svelte v3.32.1 */

    const { Error: Error_1$3 } = globals;

    function create_fragment$B(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error_1$3("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DatabaseDocument", slots, []);
    	let { docPromise = null } = $$props;
    	let { doc = null } = $$props;
    	let { db = null } = $$props;
    	let { docId } = $$props;

    	async function pullDoc(database) {
    		if (!database) throw new Error("database must be up");
    		const doc = await database.get(docId);
    		return doc;
    	}

    	const writable_props = ["docPromise", "doc", "db", "docId"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatabaseDocument> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("docPromise" in $$props) $$invalidate(0, docPromise = $$props.docPromise);
    		if ("doc" in $$props) $$invalidate(1, doc = $$props.doc);
    		if ("db" in $$props) $$invalidate(2, db = $$props.db);
    		if ("docId" in $$props) $$invalidate(3, docId = $$props.docId);
    	};

    	$$self.$capture_state = () => ({
    		PouchDB,
    		docPromise,
    		doc,
    		db,
    		docId,
    		pullDoc
    	});

    	$$self.$inject_state = $$props => {
    		if ("docPromise" in $$props) $$invalidate(0, docPromise = $$props.docPromise);
    		if ("doc" in $$props) $$invalidate(1, doc = $$props.doc);
    		if ("db" in $$props) $$invalidate(2, db = $$props.db);
    		if ("docId" in $$props) $$invalidate(3, docId = $$props.docId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*db*/ 4) {
    			 if (db !== null) {
    				// if database is ready
    				$$invalidate(0, docPromise = pullDoc(db));
    			}
    		}

    		if ($$self.$$.dirty & /*docPromise*/ 1) {
    			 if (docPromise !== null) {
    				(async () => {
    					$$invalidate(1, doc = await docPromise);
    				})();
    			}
    		}
    	};

    	return [docPromise, doc, db, docId];
    }

    class DatabaseDocument extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { docPromise: 0, doc: 1, db: 2, docId: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatabaseDocument",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*docId*/ ctx[3] === undefined && !("docId" in props)) {
    			console.warn("<DatabaseDocument> was created without expected prop 'docId'");
    		}
    	}

    	get docPromise() {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set docPromise(value) {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get doc() {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set doc(value) {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get db() {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set db(value) {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get docId() {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set docId(value) {
    		throw new Error_1$3("<DatabaseDocument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Detail.svelte generated by Svelte v3.32.1 */

    const { console: console_1$4 } = globals;
    const file$x = "src\\Pages\\Detail.svelte";

    // (103:12) <NavbarBrand href="/">
    function create_default_slot_8$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Book fugue");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(103:12) <NavbarBrand href=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:24) <Button color="success" href="/#/cart">
    function create_default_slot_7$2(ctx) {
    	let icon;
    	let current;
    	icon = new Icon({ props: { name: "cart" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(118:24) <Button color=\\\"success\\\" href=\\\"/#/cart\\\">",
    		ctx
    	});

    	return block;
    }

    // (117:20) <NavItem>
    function create_default_slot_6$2(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "success",
    				href: "/#/cart",
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(117:20) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (107:16) <Nav class="ml-auto" navbar>
    function create_default_slot_5$2(ctx) {
    	let navitem;
    	let current;

    	navitem = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navitem_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				navitem_changes.$$scope = { dirty, ctx };
    			}

    			navitem.$set(navitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(107:16) <Nav class=\\\"ml-auto\\\" navbar>",
    		ctx
    	});

    	return block;
    }

    // (106:12) <Collapse isOpen={isNavbarOpen} navbar expand="sm" on:update={handleNavbarUpdate}>
    function create_default_slot_4$2(ctx) {
    	let nav;
    	let current;

    	nav = new Nav({
    			props: {
    				class: "ml-auto",
    				navbar: true,
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(106:12) <Collapse isOpen={isNavbarOpen} navbar expand=\\\"sm\\\" on:update={handleNavbarUpdate}>",
    		ctx
    	});

    	return block;
    }

    // (102:8) <Container>
    function create_default_slot_3$2(ctx) {
    	let navbarbrand;
    	let t0;
    	let navbartoggler;
    	let t1;
    	let collapse;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "/",
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navbartoggler = new NavbarToggler({ $$inline: true });
    	navbartoggler.$on("click", /*click_handler*/ ctx[16]);

    	collapse = new Collapse({
    			props: {
    				isOpen: /*isNavbarOpen*/ ctx[7],
    				navbar: true,
    				expand: "sm",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	collapse.$on("update", /*handleNavbarUpdate*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t0 = space();
    			create_component(navbartoggler.$$.fragment);
    			t1 = space();
    			create_component(collapse.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(navbartoggler, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(collapse, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const collapse_changes = {};
    			if (dirty & /*isNavbarOpen*/ 128) collapse_changes.isOpen = /*isNavbarOpen*/ ctx[7];

    			if (dirty & /*$$scope*/ 262144) {
    				collapse_changes.$$scope = { dirty, ctx };
    			}

    			collapse.$set(collapse_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(navbartoggler.$$.fragment, local);
    			transition_in(collapse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(navbartoggler.$$.fragment, local);
    			transition_out(collapse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(navbartoggler, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(collapse, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(102:8) <Container>",
    		ctx
    	});

    	return block;
    }

    // (101:4) <Navbar color="primary" dark expand="sm">
    function create_default_slot_2$2(ctx) {
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const container_changes = {};

    			if (dirty & /*$$scope, isNavbarOpen*/ 262272) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(101:4) <Navbar color=\\\"primary\\\" dark expand=\\\"sm\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:8) {#if bookPromise !== null}
    function create_if_block$e(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		error: 17,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*bookPromise*/ ctx[3], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*bookPromise*/ 8 && promise !== (promise = /*bookPromise*/ ctx[3]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[17] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(126:8) {#if bookPromise !== null}",
    		ctx
    	});

    	return block;
    }

    // (131:12) {:catch error}
    function create_catch_block$1(ctx) {
    	let alert_1;
    	let current;

    	alert_1 = new Alert_1({
    			props: {
    				title: "Unable to fetch book",
    				error: /*error*/ ctx[17],
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_1_changes = {};
    			if (dirty & /*bookPromise*/ 8) alert_1_changes.error = /*error*/ ctx[17];

    			if (dirty & /*$$scope*/ 262144) {
    				alert_1_changes.$$scope = { dirty, ctx };
    			}

    			alert_1.$set(alert_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$1.name,
    		type: "catch",
    		source: "(131:12) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (132:16) <Alert title="Unable to fetch book" {error}>
    function create_default_slot_1$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "The connection to the database failed, retry in a few minutes.";
    			add_location(p, file$x, 132, 20, 3752);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(132:16) <Alert title=\\\"Unable to fetch book\\\" {error}>",
    		ctx
    	});

    	return block;
    }

    // (129:12) {:then}
    function create_then_block$1(ctx) {
    	let book_1;
    	let current;

    	book_1 = new Book({
    			props: {
    				book: /*book*/ ctx[4],
    				context: "detail",
    				handleAddToCart: /*addToCart*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(book_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(book_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const book_1_changes = {};
    			if (dirty & /*book*/ 16) book_1_changes.book = /*book*/ ctx[4];
    			book_1.$set(book_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(book_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(book_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(book_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$1.name,
    		type: "then",
    		source: "(129:12) {:then}",
    		ctx
    	});

    	return block;
    }

    // (127:32)                  <Spinner color="primary" />             {:then}
    function create_pending_block$1(ctx) {
    	let spinner;
    	let current;

    	spinner = new Spinner({
    			props: { color: "primary" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spinner, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$1.name,
    		type: "pending",
    		source: "(127:32)                  <Spinner color=\\\"primary\\\" />             {:then}",
    		ctx
    	});

    	return block;
    }

    // (125:4) <Container class="py-3">
    function create_default_slot$6(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*bookPromise*/ ctx[3] !== null && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*bookPromise*/ ctx[3] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*bookPromise*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(125:4) <Container class=\\\"py-3\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let link0;
    	let link1;
    	let style;
    	let t1;
    	let db0;
    	let updating_db;
    	let t2;
    	let dbdoc;
    	let updating_docPromise;
    	let updating_doc;
    	let t3;
    	let db1;
    	let updating_db_1;
    	let t4;
    	let dbdocs;
    	let updating_docsPromise;
    	let updating_docs;
    	let t5;
    	let main;
    	let navbar;
    	let t6;
    	let container;
    	let current;

    	function db0_db_binding(value) {
    		/*db0_db_binding*/ ctx[10].call(null, value);
    	}

    	let db0_props = {
    		name: "books",
    		initDocsSrc: "./books.json"
    	};

    	if (/*booksDb*/ ctx[2] !== void 0) {
    		db0_props.db = /*booksDb*/ ctx[2];
    	}

    	db0 = new Database({ props: db0_props, $$inline: true });
    	binding_callbacks.push(() => bind(db0, "db", db0_db_binding));

    	function dbdoc_docPromise_binding(value) {
    		/*dbdoc_docPromise_binding*/ ctx[11].call(null, value);
    	}

    	function dbdoc_doc_binding(value) {
    		/*dbdoc_doc_binding*/ ctx[12].call(null, value);
    	}

    	let dbdoc_props = {
    		db: /*booksDb*/ ctx[2],
    		docId: /*params*/ ctx[0].id
    	};

    	if (/*bookPromise*/ ctx[3] !== void 0) {
    		dbdoc_props.docPromise = /*bookPromise*/ ctx[3];
    	}

    	if (/*book*/ ctx[4] !== void 0) {
    		dbdoc_props.doc = /*book*/ ctx[4];
    	}

    	dbdoc = new DatabaseDocument({ props: dbdoc_props, $$inline: true });
    	binding_callbacks.push(() => bind(dbdoc, "docPromise", dbdoc_docPromise_binding));
    	binding_callbacks.push(() => bind(dbdoc, "doc", dbdoc_doc_binding));

    	function db1_db_binding(value) {
    		/*db1_db_binding*/ ctx[13].call(null, value);
    	}

    	let db1_props = { name: "cart" };

    	if (/*cartDb*/ ctx[5] !== void 0) {
    		db1_props.db = /*cartDb*/ ctx[5];
    	}

    	db1 = new Database({ props: db1_props, $$inline: true });
    	binding_callbacks.push(() => bind(db1, "db", db1_db_binding));

    	function dbdocs_docsPromise_binding(value) {
    		/*dbdocs_docsPromise_binding*/ ctx[14].call(null, value);
    	}

    	function dbdocs_docs_binding(value) {
    		/*dbdocs_docs_binding*/ ctx[15].call(null, value);
    	}

    	let dbdocs_props = { db: /*cartDb*/ ctx[5] };

    	if (/*cartPromise*/ ctx[6] !== void 0) {
    		dbdocs_props.docsPromise = /*cartPromise*/ ctx[6];
    	}

    	if (/*cart*/ ctx[1] !== void 0) {
    		dbdocs_props.docs = /*cart*/ ctx[1];
    	}

    	dbdocs = new DatabaseDocuments({ props: dbdocs_props, $$inline: true });
    	binding_callbacks.push(() => bind(dbdocs, "docsPromise", dbdocs_docsPromise_binding));
    	binding_callbacks.push(() => bind(dbdocs, "docs", dbdocs_docs_binding));

    	navbar = new Navbar({
    			props: {
    				color: "primary",
    				dark: true,
    				expand: "sm",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	container = new Container({
    			props: {
    				class: "py-3",
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			link0 = element("link");
    			link1 = element("link");
    			style = element("style");
    			style.textContent = "body {\n            margin: 0;\n            padding: 0;\n        }";
    			t1 = space();
    			create_component(db0.$$.fragment);
    			t2 = space();
    			create_component(dbdoc.$$.fragment);
    			t3 = space();
    			create_component(db1.$$.fragment);
    			t4 = space();
    			create_component(dbdocs.$$.fragment);
    			t5 = space();
    			main = element("main");
    			create_component(navbar.$$.fragment);
    			t6 = space();
    			create_component(container.$$.fragment);
    			attr_dev(link0, "href", "https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css");
    			attr_dev(link0, "rel", "stylesheet");
    			add_location(link0, file$x, 1, 4, 18);
    			attr_dev(link1, "rel", "stylesheet");
    			attr_dev(link1, "href", "https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css");
    			add_location(link1, file$x, 2, 4, 126);
    			add_location(style, file$x, 4, 4, 235);
    			add_location(main, file$x, 99, 0, 2336);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link0);
    			append_dev(document.head, link1);
    			append_dev(document.head, style);
    			insert_dev(target, t1, anchor);
    			mount_component(db0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dbdoc, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(db1, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dbdocs, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t6);
    			mount_component(container, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const db0_changes = {};

    			if (!updating_db && dirty & /*booksDb*/ 4) {
    				updating_db = true;
    				db0_changes.db = /*booksDb*/ ctx[2];
    				add_flush_callback(() => updating_db = false);
    			}

    			db0.$set(db0_changes);
    			const dbdoc_changes = {};
    			if (dirty & /*booksDb*/ 4) dbdoc_changes.db = /*booksDb*/ ctx[2];
    			if (dirty & /*params*/ 1) dbdoc_changes.docId = /*params*/ ctx[0].id;

    			if (!updating_docPromise && dirty & /*bookPromise*/ 8) {
    				updating_docPromise = true;
    				dbdoc_changes.docPromise = /*bookPromise*/ ctx[3];
    				add_flush_callback(() => updating_docPromise = false);
    			}

    			if (!updating_doc && dirty & /*book*/ 16) {
    				updating_doc = true;
    				dbdoc_changes.doc = /*book*/ ctx[4];
    				add_flush_callback(() => updating_doc = false);
    			}

    			dbdoc.$set(dbdoc_changes);
    			const db1_changes = {};

    			if (!updating_db_1 && dirty & /*cartDb*/ 32) {
    				updating_db_1 = true;
    				db1_changes.db = /*cartDb*/ ctx[5];
    				add_flush_callback(() => updating_db_1 = false);
    			}

    			db1.$set(db1_changes);
    			const dbdocs_changes = {};
    			if (dirty & /*cartDb*/ 32) dbdocs_changes.db = /*cartDb*/ ctx[5];

    			if (!updating_docsPromise && dirty & /*cartPromise*/ 64) {
    				updating_docsPromise = true;
    				dbdocs_changes.docsPromise = /*cartPromise*/ ctx[6];
    				add_flush_callback(() => updating_docsPromise = false);
    			}

    			if (!updating_docs && dirty & /*cart*/ 2) {
    				updating_docs = true;
    				dbdocs_changes.docs = /*cart*/ ctx[1];
    				add_flush_callback(() => updating_docs = false);
    			}

    			dbdocs.$set(dbdocs_changes);
    			const navbar_changes = {};

    			if (dirty & /*$$scope, isNavbarOpen*/ 262272) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const container_changes = {};

    			if (dirty & /*$$scope, bookPromise, book*/ 262168) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(db0.$$.fragment, local);
    			transition_in(dbdoc.$$.fragment, local);
    			transition_in(db1.$$.fragment, local);
    			transition_in(dbdocs.$$.fragment, local);
    			transition_in(navbar.$$.fragment, local);
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(db0.$$.fragment, local);
    			transition_out(dbdoc.$$.fragment, local);
    			transition_out(db1.$$.fragment, local);
    			transition_out(dbdocs.$$.fragment, local);
    			transition_out(navbar.$$.fragment, local);
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link0);
    			detach_dev(link1);
    			detach_dev(style);
    			if (detaching) detach_dev(t1);
    			destroy_component(db0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dbdoc, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(db1, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dbdocs, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Detail", slots, []);
    	let { params = {} } = $$props;
    	let booksDb = null;
    	let bookPromise = null;
    	let book = null;
    	let cartDb = null;
    	let cartPromise = null;
    	let cart = null;
    	let isNavbarOpen = false;

    	function handleNavbarUpdate(event) {
    		$$invalidate(7, isNavbarOpen = event.detail.isOpen);
    	}

    	function addToCart(theBook) {
    		let theItem = null;

    		cart.forEach(item => {
    			if (item.bookId == theBook._id) theItem = item;
    		});

    		if (theItem === null) {
    			theItem = {
    				"_id": new Date().toJSON(),
    				"bookId": theBook._id,
    				"amount": 0
    			};

    			cart.push(theItem);
    		}

    		theItem.amount++;
    		$$invalidate(1, cart);
    		alert("Added to cart");
    	}

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<Detail> was created with unknown prop '${key}'`);
    	});

    	function db0_db_binding(value) {
    		booksDb = value;
    		$$invalidate(2, booksDb);
    	}

    	function dbdoc_docPromise_binding(value) {
    		bookPromise = value;
    		$$invalidate(3, bookPromise);
    	}

    	function dbdoc_doc_binding(value) {
    		book = value;
    		$$invalidate(4, book);
    	}

    	function db1_db_binding(value) {
    		cartDb = value;
    		$$invalidate(5, cartDb);
    	}

    	function dbdocs_docsPromise_binding(value) {
    		cartPromise = value;
    		$$invalidate(6, cartPromise);
    	}

    	function dbdocs_docs_binding(value) {
    		cart = value;
    		$$invalidate(1, cart);
    	}

    	const click_handler = () => $$invalidate(7, isNavbarOpen = !isNavbarOpen);

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		type,
    		fade,
    		fly,
    		params,
    		Collapse,
    		Navbar,
    		NavbarToggler,
    		NavbarBrand,
    		Nav,
    		NavItem,
    		Form,
    		Input,
    		Button,
    		UncontrolledDropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Container,
    		Row,
    		Col,
    		Card,
    		CardBody,
    		CardHeader,
    		CardSubtitle,
    		CardText,
    		CardTitle,
    		Spinner,
    		Pagination,
    		PaginationItem,
    		PaginationLink,
    		Icon,
    		Db: Database,
    		DbDoc: DatabaseDocument,
    		DbDocs: DatabaseDocuments,
    		Book,
    		Alert: Alert_1,
    		booksDb,
    		bookPromise,
    		book,
    		cartDb,
    		cartPromise,
    		cart,
    		isNavbarOpen,
    		handleNavbarUpdate,
    		addToCart
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("booksDb" in $$props) $$invalidate(2, booksDb = $$props.booksDb);
    		if ("bookPromise" in $$props) $$invalidate(3, bookPromise = $$props.bookPromise);
    		if ("book" in $$props) $$invalidate(4, book = $$props.book);
    		if ("cartDb" in $$props) $$invalidate(5, cartDb = $$props.cartDb);
    		if ("cartPromise" in $$props) $$invalidate(6, cartPromise = $$props.cartPromise);
    		if ("cart" in $$props) $$invalidate(1, cart = $$props.cart);
    		if ("isNavbarOpen" in $$props) $$invalidate(7, isNavbarOpen = $$props.isNavbarOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*cart*/ 2) {
    			 console.warn("cart", cart);
    		}
    	};

    	return [
    		params,
    		cart,
    		booksDb,
    		bookPromise,
    		book,
    		cartDb,
    		cartPromise,
    		isNavbarOpen,
    		handleNavbarUpdate,
    		addToCart,
    		db0_db_binding,
    		dbdoc_docPromise_binding,
    		dbdoc_doc_binding,
    		db1_db_binding,
    		dbdocs_docsPromise_binding,
    		dbdocs_docs_binding,
    		click_handler
    	];
    }

    class Detail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Detail",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get params() {
    		throw new Error("<Detail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Detail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Cart.svelte generated by Svelte v3.32.1 */
    const file$y = "src\\Pages\\Cart.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	child_ctx[21] = list;
    	child_ctx[22] = i;
    	return child_ctx;
    }

    // (74:12) <NavbarBrand href="/">
    function create_default_slot_12(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Book fugue");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(74:12) <NavbarBrand href=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (89:24) <Button color="success" href="/#/cart">
    function create_default_slot_11$1(ctx) {
    	let icon;
    	let current;
    	icon = new Icon({ props: { name: "cart" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(89:24) <Button color=\\\"success\\\" href=\\\"/#/cart\\\">",
    		ctx
    	});

    	return block;
    }

    // (88:20) <NavItem>
    function create_default_slot_10$1(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "success",
    				href: "/#/cart",
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(88:20) <NavItem>",
    		ctx
    	});

    	return block;
    }

    // (78:16) <Nav class="ml-auto" navbar>
    function create_default_slot_9$2(ctx) {
    	let navitem;
    	let current;

    	navitem = new NavItem({
    			props: {
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navitem_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				navitem_changes.$$scope = { dirty, ctx };
    			}

    			navitem.$set(navitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(78:16) <Nav class=\\\"ml-auto\\\" navbar>",
    		ctx
    	});

    	return block;
    }

    // (77:12) <Collapse isOpen={isNavbarOpen} navbar expand="sm" on:update={handleNavbarUpdate}>
    function create_default_slot_8$3(ctx) {
    	let nav;
    	let current;

    	nav = new Nav({
    			props: {
    				class: "ml-auto",
    				navbar: true,
    				$$slots: { default: [create_default_slot_9$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(77:12) <Collapse isOpen={isNavbarOpen} navbar expand=\\\"sm\\\" on:update={handleNavbarUpdate}>",
    		ctx
    	});

    	return block;
    }

    // (73:8) <Container>
    function create_default_slot_7$3(ctx) {
    	let navbarbrand;
    	let t0;
    	let navbartoggler;
    	let t1;
    	let collapse;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "/",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navbartoggler = new NavbarToggler({ $$inline: true });
    	navbartoggler.$on("click", /*click_handler*/ ctx[13]);

    	collapse = new Collapse({
    			props: {
    				isOpen: /*isNavbarOpen*/ ctx[3],
    				navbar: true,
    				expand: "sm",
    				$$slots: { default: [create_default_slot_8$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	collapse.$on("update", /*handleNavbarUpdate*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t0 = space();
    			create_component(navbartoggler.$$.fragment);
    			t1 = space();
    			create_component(collapse.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(navbartoggler, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(collapse, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const collapse_changes = {};
    			if (dirty & /*isNavbarOpen*/ 8) collapse_changes.isOpen = /*isNavbarOpen*/ ctx[3];

    			if (dirty & /*$$scope*/ 16777216) {
    				collapse_changes.$$scope = { dirty, ctx };
    			}

    			collapse.$set(collapse_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(navbartoggler.$$.fragment, local);
    			transition_in(collapse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(navbartoggler.$$.fragment, local);
    			transition_out(collapse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(navbartoggler, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(collapse, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(73:8) <Container>",
    		ctx
    	});

    	return block;
    }

    // (72:4) <Navbar color="primary" dark expand="sm">
    function create_default_slot_6$3(ctx) {
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const container_changes = {};

    			if (dirty & /*$$scope, isNavbarOpen*/ 16777224) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(72:4) <Navbar color=\\\"primary\\\" dark expand=\\\"sm\\\">",
    		ctx
    	});

    	return block;
    }

    // (100:12) {#if cartPromise !== null}
    function create_if_block$f(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		error: 23,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*cartPromise*/ ctx[1], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*cartPromise*/ 2 && promise !== (promise = /*cartPromise*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[23] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(100:12) {#if cartPromise !== null}",
    		ctx
    	});

    	return block;
    }

    // (159:16) {:catch error}
    function create_catch_block$2(ctx) {
    	let alert;
    	let current;

    	alert = new Alert_1({
    			props: {
    				title: "Unable to fetch cart",
    				error: /*error*/ ctx[23],
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};
    			if (dirty & /*cartPromise*/ 2) alert_changes.error = /*error*/ ctx[23];

    			if (dirty & /*$$scope*/ 16777216) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$2.name,
    		type: "catch",
    		source: "(159:16) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (160:20) <Alert title="Unable to fetch cart" {error}>
    function create_default_slot_5$3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "The connection to the database failed, retry in a few minutes.";
    			add_location(p, file$y, 160, 24, 6017);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(160:20) <Alert title=\\\"Unable to fetch cart\\\" {error}>",
    		ctx
    	});

    	return block;
    }

    // (103:16) {:then}
    function create_then_block$2(ctx) {
    	let table;
    	let current;

    	table = new Table({
    			props: {
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(table.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table_changes = {};

    			if (dirty & /*$$scope, cart, books, booksDb*/ 16777268) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$2.name,
    		type: "then",
    		source: "(103:16) {:then}",
    		ctx
    	});

    	return block;
    }

    // (105:24) {#if cart.length > 0}
    function create_if_block_4$1(ctx) {
    	let tr;
    	let th0;
    	let t0;
    	let th1;
    	let t2;
    	let th2;
    	let t4;
    	let th3;
    	let t6;
    	let th4;
    	let t8;
    	let th5;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			th1.textContent = "Title";
    			t2 = space();
    			th2 = element("th");
    			th2.textContent = "Unit price";
    			t4 = space();
    			th3 = element("th");
    			th3.textContent = "Quantity";
    			t6 = space();
    			th4 = element("th");
    			th4.textContent = "Total";
    			t8 = space();
    			th5 = element("th");
    			add_location(th0, file$y, 106, 32, 3027);
    			add_location(th1, file$y, 107, 32, 3069);
    			set_style(th2, "width", "1px");
    			set_style(th2, "white-space", "nowrap");
    			add_location(th2, file$y, 108, 32, 3116);
    			set_style(th3, "width", "1px");
    			set_style(th3, "white-space", "nowrap");
    			add_location(th3, file$y, 109, 32, 3209);
    			set_style(th4, "width", "1px");
    			set_style(th4, "white-space", "nowrap");
    			add_location(th4, file$y, 110, 32, 3300);
    			add_location(th5, file$y, 111, 32, 3388);
    			add_location(tr, file$y, 105, 28, 2990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th0);
    			append_dev(tr, t0);
    			append_dev(tr, th1);
    			append_dev(tr, t2);
    			append_dev(tr, th2);
    			append_dev(tr, t4);
    			append_dev(tr, th3);
    			append_dev(tr, t6);
    			append_dev(tr, th4);
    			append_dev(tr, t8);
    			append_dev(tr, th5);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(105:24) {#if cart.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (132:24) {:else}
    function create_else_block$c(ctx) {
    	let alert;
    	let current;

    	alert = new Alert_1({
    			props: {
    				title: "Empty cart",
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(132:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (133:28) <Alert title="Empty cart">
    function create_default_slot_4$3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "There is currently no books in your cart.";
    			add_location(p, file$y, 133, 32, 4914);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(133:28) <Alert title=\\\"Empty cart\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:28) {#if books[item.bookId]}
    function create_if_block_3$2(ctx) {
    	let tr;
    	let td0;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_title_value;
    	let t0;
    	let td1;
    	let t1_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].title + "";
    	let t1;
    	let t2;
    	let td2;
    	let sup;
    	let t4_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].price + "";
    	let t4;
    	let t5;
    	let td3;
    	let input;
    	let updating_value;
    	let t6;
    	let td4;
    	let t7_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].price * /*item*/ ctx[18].amount + "";
    	let t7;
    	let t8;
    	let td5;
    	let button;
    	let current;

    	function input_value_binding(value) {
    		/*input_value_binding*/ ctx[15].call(null, value, /*item*/ ctx[18]);
    	}

    	let input_props = {
    		type: "number",
    		min: "1",
    		style: "width: 4rem"
    	};

    	if (/*item*/ ctx[18].amount !== void 0) {
    		input_props.value = /*item*/ ctx[18].amount;
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, "value", input_value_binding));

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[16](/*item*/ ctx[18]);
    	}

    	button = new Button({
    			props: {
    				color: "danger",
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", click_handler_1);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			img = element("img");
    			t0 = space();
    			td1 = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			td2 = element("td");
    			sup = element("sup");
    			sup.textContent = "$";
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			create_component(input.$$.fragment);
    			t6 = space();
    			td4 = element("td");
    			t7 = text(t7_value);
    			t8 = space();
    			td5 = element("td");
    			create_component(button.$$.fragment);
    			attr_dev(img, "class", "w-100");
    			if (img.src !== (img_src_value = "data:image/jpeg;base64, " + /*books*/ ctx[5][/*item*/ ctx[18].bookId].img.data)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].title);
    			attr_dev(img, "title", img_title_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].title);
    			attr_dev(img, "onerror", "this.src='image/not-found.png'");
    			add_location(img, file$y, 119, 91, 3790);
    			attr_dev(td0, "class", "d-none d-sm-table-cell");
    			set_style(td0, "width", "4rem");
    			add_location(td0, file$y, 119, 36, 3735);
    			add_location(td1, file$y, 120, 36, 4022);
    			attr_dev(sup, "class", "mr-1");
    			add_location(sup, file$y, 121, 81, 4139);
    			set_style(td2, "width", "1px");
    			set_style(td2, "white-space", "nowrap");
    			add_location(td2, file$y, 121, 36, 4094);
    			set_style(td3, "width", "1px");
    			set_style(td3, "white-space", "nowrap");
    			add_location(td3, file$y, 122, 36, 4232);
    			set_style(td4, "width", "1px");
    			set_style(td4, "white-space", "nowrap");
    			add_location(td4, file$y, 123, 36, 4395);
    			set_style(td5, "width", "1px");
    			set_style(td5, "white-space", "nowrap");
    			add_location(td5, file$y, 125, 36, 4523);
    			add_location(tr, file$y, 118, 32, 3694);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, img);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, sup);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			mount_component(input, td3, null);
    			append_dev(tr, t6);
    			append_dev(tr, td4);
    			append_dev(td4, t7);
    			append_dev(tr, t8);
    			append_dev(tr, td5);
    			mount_component(button, td5, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (!current || dirty & /*books, cart*/ 36 && img.src !== (img_src_value = "data:image/jpeg;base64, " + /*books*/ ctx[5][/*item*/ ctx[18].bookId].img.data)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*books, cart*/ 36 && img_alt_value !== (img_alt_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].title)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (!current || dirty & /*books, cart*/ 36 && img_title_value !== (img_title_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].title)) {
    				attr_dev(img, "title", img_title_value);
    			}

    			if ((!current || dirty & /*books, cart*/ 36) && t1_value !== (t1_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].title + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*books, cart*/ 36) && t4_value !== (t4_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].price + "")) set_data_dev(t4, t4_value);
    			const input_changes = {};

    			if (!updating_value && dirty & /*cart*/ 4) {
    				updating_value = true;
    				input_changes.value = /*item*/ ctx[18].amount;
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    			if ((!current || dirty & /*books, cart*/ 36) && t7_value !== (t7_value = /*books*/ ctx[5][/*item*/ ctx[18].bookId].price * /*item*/ ctx[18].amount + "")) set_data_dev(t7, t7_value);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_component(input);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(118:28) {#if books[item.bookId]}",
    		ctx
    	});

    	return block;
    }

    // (126:81) <Button color="danger" on:click={() => deleteItem(item)}>
    function create_default_slot_3$3(ctx) {
    	let icon;
    	let current;
    	icon = new Icon({ props: { name: "trash" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(126:81) <Button color=\\\"danger\\\" on:click={() => deleteItem(item)}>",
    		ctx
    	});

    	return block;
    }

    // (116:24) {#each cart as item}
    function create_each_block_1(ctx) {
    	let dbdoc;
    	let updating_doc;
    	let t;
    	let if_block_anchor;
    	let current;

    	function dbdoc_doc_binding(value) {
    		/*dbdoc_doc_binding*/ ctx[14].call(null, value, /*item*/ ctx[18]);
    	}

    	let dbdoc_props = {
    		db: /*booksDb*/ ctx[4],
    		docId: /*item*/ ctx[18].bookId
    	};

    	if (/*books*/ ctx[5][/*item*/ ctx[18].bookId] !== void 0) {
    		dbdoc_props.doc = /*books*/ ctx[5][/*item*/ ctx[18].bookId];
    	}

    	dbdoc = new DatabaseDocument({ props: dbdoc_props, $$inline: true });
    	binding_callbacks.push(() => bind(dbdoc, "doc", dbdoc_doc_binding));
    	let if_block = /*books*/ ctx[5][/*item*/ ctx[18].bookId] && create_if_block_3$2(ctx);

    	const block = {
    		c: function create() {
    			create_component(dbdoc.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(dbdoc, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const dbdoc_changes = {};
    			if (dirty & /*booksDb*/ 16) dbdoc_changes.db = /*booksDb*/ ctx[4];
    			if (dirty & /*cart*/ 4) dbdoc_changes.docId = /*item*/ ctx[18].bookId;

    			if (!updating_doc && dirty & /*books, cart*/ 36) {
    				updating_doc = true;
    				dbdoc_changes.doc = /*books*/ ctx[5][/*item*/ ctx[18].bookId];
    				add_flush_callback(() => updating_doc = false);
    			}

    			dbdoc.$set(dbdoc_changes);

    			if (/*books*/ ctx[5][/*item*/ ctx[18].bookId]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*books, cart*/ 36) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dbdoc.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dbdoc.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dbdoc, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(116:24) {#each cart as item}",
    		ctx
    	});

    	return block;
    }

    // (138:24) {#if cart.length > 0}
    function create_if_block_1$6(ctx) {
    	let tr;
    	let th0;
    	let t0;
    	let th1;
    	let t2;
    	let t3;
    	let th2;
    	let current;
    	let each_value = /*cart*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			th1.textContent = "Total";
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			th2 = element("th");
    			th2.textContent = `${/*total*/ ctx[8]}`;
    			add_location(th0, file$y, 139, 32, 5144);
    			add_location(th1, file$y, 140, 32, 5186);
    			set_style(th2, "width", "1px");
    			set_style(th2, "white-space", "nowrap");
    			add_location(th2, file$y, 152, 37, 5712);
    			add_location(tr, file$y, 138, 28, 5107);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th0);
    			append_dev(tr, t0);
    			append_dev(tr, th1);
    			append_dev(tr, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*total, books, cart, booksDb*/ 308) {
    				each_value = /*cart*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tr, t3);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(138:24) {#if cart.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (144:28) {#if books[item.bookId]}
    function create_if_block_2$4(ctx) {
    	let th;
    	let t_value = (/*total*/ ctx[8] = /*total*/ ctx[8] + /*books*/ ctx[5][/*item*/ ctx[18].bookId].price * /*item*/ ctx[18].amount) + "";
    	let t;

    	const block = {
    		c: function create() {
    			th = element("th");
    			t = text(t_value);
    			set_style(th, "width", "1px");
    			set_style(th, "white-space", "nowrap");
    			add_location(th, file$y, 144, 32, 5436);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*books, cart*/ 36 && t_value !== (t_value = (/*total*/ ctx[8] = /*total*/ ctx[8] + /*books*/ ctx[5][/*item*/ ctx[18].bookId].price * /*item*/ ctx[18].amount) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(144:28) {#if books[item.bookId]}",
    		ctx
    	});

    	return block;
    }

    // (142:28) {#each cart as item}
    function create_each_block$1(ctx) {
    	let dbdoc;
    	let updating_doc;
    	let t;
    	let if_block_anchor;
    	let current;

    	function dbdoc_doc_binding_1(value) {
    		/*dbdoc_doc_binding_1*/ ctx[17].call(null, value, /*item*/ ctx[18]);
    	}

    	let dbdoc_props = {
    		db: /*booksDb*/ ctx[4],
    		docId: /*item*/ ctx[18].bookId
    	};

    	if (/*books*/ ctx[5][/*item*/ ctx[18].bookId] !== void 0) {
    		dbdoc_props.doc = /*books*/ ctx[5][/*item*/ ctx[18].bookId];
    	}

    	dbdoc = new DatabaseDocument({ props: dbdoc_props, $$inline: true });
    	binding_callbacks.push(() => bind(dbdoc, "doc", dbdoc_doc_binding_1));
    	let if_block = /*books*/ ctx[5][/*item*/ ctx[18].bookId] && create_if_block_2$4(ctx);

    	const block = {
    		c: function create() {
    			create_component(dbdoc.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(dbdoc, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const dbdoc_changes = {};
    			if (dirty & /*booksDb*/ 16) dbdoc_changes.db = /*booksDb*/ ctx[4];
    			if (dirty & /*cart*/ 4) dbdoc_changes.docId = /*item*/ ctx[18].bookId;

    			if (!updating_doc && dirty & /*books, cart*/ 36) {
    				updating_doc = true;
    				dbdoc_changes.doc = /*books*/ ctx[5][/*item*/ ctx[18].bookId];
    				add_flush_callback(() => updating_doc = false);
    			}

    			dbdoc.$set(dbdoc_changes);

    			if (/*books*/ ctx[5][/*item*/ ctx[18].bookId]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dbdoc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dbdoc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dbdoc, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(142:28) {#each cart as item}",
    		ctx
    	});

    	return block;
    }

    // (104:20) <Table>
    function create_default_slot_2$3(ctx) {
    	let t0;
    	let t1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*cart*/ ctx[2].length > 0 && create_if_block_4$1(ctx);
    	let each_value_1 = /*cart*/ ctx[2];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value_1.length) {
    		each_1_else = create_else_block$c(ctx);
    	}

    	let if_block1 = /*cart*/ ctx[2].length > 0 && create_if_block_1$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (each_1_else) {
    				each_1_else.c();
    			}

    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*cart*/ ctx[2].length > 0) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*deleteItem, cart, books, booksDb*/ 180) {
    				each_value_1 = /*cart*/ ctx[2];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t1.parentNode, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (!each_value_1.length && each_1_else) {
    					each_1_else.p(ctx, dirty);
    				} else if (!each_value_1.length) {
    					each_1_else = create_else_block$c(ctx);
    					each_1_else.c();
    					transition_in(each_1_else, 1);
    					each_1_else.m(t1.parentNode, t1);
    				} else if (each_1_else) {
    					group_outros();

    					transition_out(each_1_else, 1, 1, () => {
    						each_1_else = null;
    					});

    					check_outros();
    				}
    			}

    			if (/*cart*/ ctx[2].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*cart*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_each(each_blocks, detaching);
    			if (each_1_else) each_1_else.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(104:20) <Table>",
    		ctx
    	});

    	return block;
    }

    // (101:36)                      <Spinner color="primary" />                 {:then}
    function create_pending_block$2(ctx) {
    	let spinner;
    	let current;

    	spinner = new Spinner({
    			props: { color: "primary" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spinner, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$2.name,
    		type: "pending",
    		source: "(101:36)                      <Spinner color=\\\"primary\\\" />                 {:then}",
    		ctx
    	});

    	return block;
    }

    // (99:8) <Row class="justify-content-center">
    function create_default_slot_1$3(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*cartPromise*/ ctx[1] !== null && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*cartPromise*/ ctx[1] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*cartPromise*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(99:8) <Row class=\\\"justify-content-center\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:4) <Container class="py-3">
    function create_default_slot$7(ctx) {
    	let h1;
    	let t1;
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				class: "justify-content-center",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Cart";
    			t1 = space();
    			create_component(row.$$.fragment);
    			add_location(h1, file$y, 96, 8, 2641);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, cartPromise, cart, books, booksDb*/ 16777270) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(96:4) <Container class=\\\"py-3\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let link0;
    	let link1;
    	let style;
    	let t1;
    	let db0;
    	let updating_db;
    	let t2;
    	let dbdocs;
    	let updating_docsPromise;
    	let updating_docs;
    	let t3;
    	let db1;
    	let updating_db_1;
    	let t4;
    	let main;
    	let navbar;
    	let t5;
    	let container;
    	let current;

    	function db0_db_binding(value) {
    		/*db0_db_binding*/ ctx[9].call(null, value);
    	}

    	let db0_props = { name: "cart" };

    	if (/*cartDb*/ ctx[0] !== void 0) {
    		db0_props.db = /*cartDb*/ ctx[0];
    	}

    	db0 = new Database({ props: db0_props, $$inline: true });
    	binding_callbacks.push(() => bind(db0, "db", db0_db_binding));

    	function dbdocs_docsPromise_binding(value) {
    		/*dbdocs_docsPromise_binding*/ ctx[10].call(null, value);
    	}

    	function dbdocs_docs_binding(value) {
    		/*dbdocs_docs_binding*/ ctx[11].call(null, value);
    	}

    	let dbdocs_props = { db: /*cartDb*/ ctx[0] };

    	if (/*cartPromise*/ ctx[1] !== void 0) {
    		dbdocs_props.docsPromise = /*cartPromise*/ ctx[1];
    	}

    	if (/*cart*/ ctx[2] !== void 0) {
    		dbdocs_props.docs = /*cart*/ ctx[2];
    	}

    	dbdocs = new DatabaseDocuments({ props: dbdocs_props, $$inline: true });
    	binding_callbacks.push(() => bind(dbdocs, "docsPromise", dbdocs_docsPromise_binding));
    	binding_callbacks.push(() => bind(dbdocs, "docs", dbdocs_docs_binding));

    	function db1_db_binding(value) {
    		/*db1_db_binding*/ ctx[12].call(null, value);
    	}

    	let db1_props = { name: "books" };

    	if (/*booksDb*/ ctx[4] !== void 0) {
    		db1_props.db = /*booksDb*/ ctx[4];
    	}

    	db1 = new Database({ props: db1_props, $$inline: true });
    	binding_callbacks.push(() => bind(db1, "db", db1_db_binding));

    	navbar = new Navbar({
    			props: {
    				color: "primary",
    				dark: true,
    				expand: "sm",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	container = new Container({
    			props: {
    				class: "py-3",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			link0 = element("link");
    			link1 = element("link");
    			style = element("style");
    			style.textContent = "body {\n            margin: 0;\n            padding: 0;\n        }\n\n        .table td {\n            vertical-align: middle;\n        }";
    			t1 = space();
    			create_component(db0.$$.fragment);
    			t2 = space();
    			create_component(dbdocs.$$.fragment);
    			t3 = space();
    			create_component(db1.$$.fragment);
    			t4 = space();
    			main = element("main");
    			create_component(navbar.$$.fragment);
    			t5 = space();
    			create_component(container.$$.fragment);
    			attr_dev(link0, "href", "https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css");
    			attr_dev(link0, "rel", "stylesheet");
    			add_location(link0, file$y, 1, 4, 18);
    			attr_dev(link1, "rel", "stylesheet");
    			attr_dev(link1, "href", "https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css");
    			add_location(link1, file$y, 2, 4, 126);
    			add_location(style, file$y, 4, 4, 235);
    			add_location(main, file$y, 70, 0, 1577);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link0);
    			append_dev(document.head, link1);
    			append_dev(document.head, style);
    			insert_dev(target, t1, anchor);
    			mount_component(db0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dbdocs, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(db1, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t5);
    			mount_component(container, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const db0_changes = {};

    			if (!updating_db && dirty & /*cartDb*/ 1) {
    				updating_db = true;
    				db0_changes.db = /*cartDb*/ ctx[0];
    				add_flush_callback(() => updating_db = false);
    			}

    			db0.$set(db0_changes);
    			const dbdocs_changes = {};
    			if (dirty & /*cartDb*/ 1) dbdocs_changes.db = /*cartDb*/ ctx[0];

    			if (!updating_docsPromise && dirty & /*cartPromise*/ 2) {
    				updating_docsPromise = true;
    				dbdocs_changes.docsPromise = /*cartPromise*/ ctx[1];
    				add_flush_callback(() => updating_docsPromise = false);
    			}

    			if (!updating_docs && dirty & /*cart*/ 4) {
    				updating_docs = true;
    				dbdocs_changes.docs = /*cart*/ ctx[2];
    				add_flush_callback(() => updating_docs = false);
    			}

    			dbdocs.$set(dbdocs_changes);
    			const db1_changes = {};

    			if (!updating_db_1 && dirty & /*booksDb*/ 16) {
    				updating_db_1 = true;
    				db1_changes.db = /*booksDb*/ ctx[4];
    				add_flush_callback(() => updating_db_1 = false);
    			}

    			db1.$set(db1_changes);
    			const navbar_changes = {};

    			if (dirty & /*$$scope, isNavbarOpen*/ 16777224) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const container_changes = {};

    			if (dirty & /*$$scope, cartPromise, cart, books, booksDb*/ 16777270) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(db0.$$.fragment, local);
    			transition_in(dbdocs.$$.fragment, local);
    			transition_in(db1.$$.fragment, local);
    			transition_in(navbar.$$.fragment, local);
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(db0.$$.fragment, local);
    			transition_out(dbdocs.$$.fragment, local);
    			transition_out(db1.$$.fragment, local);
    			transition_out(navbar.$$.fragment, local);
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link0);
    			detach_dev(link1);
    			detach_dev(style);
    			if (detaching) detach_dev(t1);
    			destroy_component(db0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dbdocs, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(db1, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Cart", slots, []);
    	let cartDb = null;
    	let cartPromise = null;
    	let cart = null;
    	let isNavbarOpen = false;

    	function handleNavbarUpdate(event) {
    		$$invalidate(3, isNavbarOpen = event.detail.isOpen);
    	}

    	function deleteItem(theItem) {
    		theItem._deleted = true;
    		$$invalidate(2, cart);
    	}

    	let booksDb = null;
    	let books = [];
    	let total = 0;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Cart> was created with unknown prop '${key}'`);
    	});

    	function db0_db_binding(value) {
    		cartDb = value;
    		$$invalidate(0, cartDb);
    	}

    	function dbdocs_docsPromise_binding(value) {
    		cartPromise = value;
    		$$invalidate(1, cartPromise);
    	}

    	function dbdocs_docs_binding(value) {
    		cart = value;
    		$$invalidate(2, cart);
    	}

    	function db1_db_binding(value) {
    		booksDb = value;
    		$$invalidate(4, booksDb);
    	}

    	const click_handler = () => $$invalidate(3, isNavbarOpen = !isNavbarOpen);

    	function dbdoc_doc_binding(value, item) {
    		books[item.bookId] = value;
    		$$invalidate(5, books);
    	}

    	function input_value_binding(value, item) {
    		item.amount = value;
    		$$invalidate(2, cart);
    	}

    	const click_handler_1 = item => deleteItem(item);

    	function dbdoc_doc_binding_1(value, item) {
    		books[item.bookId] = value;
    		$$invalidate(5, books);
    	}

    	$$self.$capture_state = () => ({
    		Collapse,
    		Navbar,
    		NavbarToggler,
    		NavbarBrand,
    		Nav,
    		NavItem,
    		Form,
    		Input,
    		Button,
    		UncontrolledDropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Container,
    		Row,
    		Col,
    		Spinner,
    		Icon,
    		Table,
    		Db: Database,
    		DbDocs: DatabaseDocuments,
    		DbDoc: DatabaseDocument,
    		Alert: Alert_1,
    		Dump,
    		cartDb,
    		cartPromise,
    		cart,
    		isNavbarOpen,
    		handleNavbarUpdate,
    		deleteItem,
    		booksDb,
    		books,
    		total
    	});

    	$$self.$inject_state = $$props => {
    		if ("cartDb" in $$props) $$invalidate(0, cartDb = $$props.cartDb);
    		if ("cartPromise" in $$props) $$invalidate(1, cartPromise = $$props.cartPromise);
    		if ("cart" in $$props) $$invalidate(2, cart = $$props.cart);
    		if ("isNavbarOpen" in $$props) $$invalidate(3, isNavbarOpen = $$props.isNavbarOpen);
    		if ("booksDb" in $$props) $$invalidate(4, booksDb = $$props.booksDb);
    		if ("books" in $$props) $$invalidate(5, books = $$props.books);
    		if ("total" in $$props) $$invalidate(8, total = $$props.total);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		cartDb,
    		cartPromise,
    		cart,
    		isNavbarOpen,
    		booksDb,
    		books,
    		handleNavbarUpdate,
    		deleteItem,
    		total,
    		db0_db_binding,
    		dbdocs_docsPromise_binding,
    		dbdocs_docs_binding,
    		db1_db_binding,
    		click_handler,
    		dbdoc_doc_binding,
    		input_value_binding,
    		click_handler_1,
    		dbdoc_doc_binding_1
    	];
    }

    class Cart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cart",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.32.1 */

    function create_fragment$E(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				routes: {
    					"/": Books,
    					"/detail/:id": Detail,
    					"/cart": Cart
    				}
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Router, Books, Detail, Cart });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    var app = new App({
    	target: document.body
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
